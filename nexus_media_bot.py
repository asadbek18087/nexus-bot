# =============================================================================
# NEXUS MEDIA - Barcha media turlarining markazi
#====================================================
# Yangi database: mega_bot.db
# 100% ishlaydigan asosiy funksiyalar
# =============================================================================

import os
import sys                                                                                                                                              
import asyncio
import logging
import datetime as dt
from datetime import datetime, timedelta, date
import json
import random
import re
import shutil
import aiosqlite
import aiohttp
import time
from typing import Optional, List, Dict, Any, Tuple
from contextlib import asynccontextmanager
from io import BytesIO
from pathlib import Path
from dotenv import load_dotenv

# Excel export uchun
try:
    import openpyxl
    from openpyxl import Workbook
    from openpyxl.styles import Font, PatternFill, Alignment
    OPENPYXL_AVAILABLE = True
except ImportError:
    OPENPYXL_AVAILABLE = False

# Sertifikat va Mind Map uchun PIL
try:
    from PIL import Image, ImageDraw, ImageFont, ImageFilter
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    logging.warning("PIL (Pillow) topilmadi. Sertifikat generatsiyasi ishlamaydi. pip install Pillow")

# Chart generation
try:
    import chart_generator
    CHART_AVAILABLE = True
except ImportError:
    CHART_AVAILABLE = False
    logging.warning("Chart generator topilmadi. Grafiklar ishlamaydi.")

from aiogram import Bot, Dispatcher, F, Router
from aiogram.filters import CommandStart, Command
from aiogram.types import (
    Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton,
    ReplyKeyboardMarkup, ReplyKeyboardRemove, FSInputFile, Sticker, WebAppInfo,
    ChatMemberUpdated,
    ChatJoinRequest,
    InlineQuery,
    ChosenInlineResult,
    ShippingQuery,
    PreCheckoutQuery,
    Poll,
    PollAnswer
)
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.utils.keyboard import InlineKeyboardBuilder, ReplyKeyboardBuilder

# AI Agent
from agent_handler import NexusAgent

# Supabase integration
try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False
    logging.warning("Supabase kutubxonasi topilmadi. RPG sync ishlamaydi. pip install supabase")

# Megabook utils import (logger yaratilgandan keyin ishlatiladi)
# Type checking uchun stub'lar
try:
    from megabook_utils import (  # type: ignore
        detect_genre,
        clean_text,
        get_file_type,
        auto_detect_and_clean,
        extract_author_from_caption,
        detect_quality_from_caption,
        BOOK_GENRES,
        MOVIE_GENRES
    )
    UTILS_AVAILABLE = True
except ImportError:
    UTILS_AVAILABLE = False
    # Agar megabook_utils.py topilmasa, stub funksiyalar
    def remove_emoji(text: str) -> str:
        """Emoji va iconlarni olib tashlash"""
        import re
        # Barcha emoji va iconlarni olib tashlash
        emoji_pattern = re.compile("["
            u"\U0001F600-\U0001F64F"  # emoticons
            u"\U0001F300-\U0001F5FF"  # symbols & pictographs
            u"\U0001F680-\U0001F6FF"  # transport & map symbols
            u"\U0001F1E0-\U0001F1FF"  # flags (iOS)
            u"\U00002702-\U000027B0"
            u"\U000024C2-\U0001F251"
            u"\U0001F900-\U0001F9FF"  # supplemental symbols
            u"\U0001FA00-\U0001FA6F"  # chess symbols
            u"\U0001FA70-\U0001FAFF"  # symbols and pictographs extended-A
            u"\U00002600-\U000026FF"  # miscellaneous symbols
            u"\U00002700-\U000027BF"  # dingbats
            "]+", flags=re.UNICODE)
        return emoji_pattern.sub('', text).strip()
    
    def detect_genre(text: str, genre_type: str = "book") -> str:
        return "Boshqa"
    def clean_text(text: str) -> str:
        return text
    def get_file_type(message) -> Optional[str]:
        return None
    def auto_detect_and_clean(caption: str, genre_type: str = "book") -> dict:
        return {'cleaned_caption': caption, 'author': '', 'genre': 'Boshqa'}
    def extract_author_from_caption(caption: str) -> Tuple[str, str]:
        return ("", caption)
    def detect_quality_from_caption(caption: str) -> str:
        return "720p"
    BOOK_GENRES = {}
    MOVIE_GENRES = {}

# UTF-8 encoding setup
try:
    if sys.stdout.encoding != 'utf-8':
        sys.stdout.reconfigure(encoding='utf-8')
    if sys.stderr.encoding != 'utf-8':
        sys.stderr.reconfigure(encoding='utf-8')
except (AttributeError, ValueError):
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

# =============================================================================
# KO'P TILLILIK TIZIMI (i18n)
# =============================================================================

class Translations:
    """Ko'p tillilik tizimi"""
    
    TRANSLATIONS = {
        'uz': {
            'welcome': 'Assalomu alaykum, {name}!',
            'library': 'Kutubxona',
            'cinema': 'Kinoteatr',
            'courses': 'Kurslar',
            'ai_mentor': 'AI Mentor',
            'profile': 'Profil',
            'premium': 'Premium',
            'back': 'Orqaga',
            'main_menu': 'Asosiy menyu',
            'select_language': 'Tilni tanlang / Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ·Ñ‹Ðº / Select language:',
            'language_set': 'Til o\'zgartirildi',
            'choose_language': 'Tilni tanlang:'
        },
        'ru': {
            'welcome': 'Ð—Ð´Ñ€Ð°Ð²ÑÑ‚Ð²ÑƒÐ¹Ñ‚Ðµ, {name}!',
            'library': 'Ð‘Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ°',
            'cinema': 'ÐšÐ¸Ð½Ð¾Ñ‚ÐµÐ°Ñ‚Ñ€',
            'courses': 'ÐšÑƒÑ€ÑÑ‹',
            'ai_mentor': 'AI ÐœÐµÐ½Ñ‚Ð¾Ñ€',
            'profile': 'ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ',
            'premium': 'ÐŸÑ€ÐµÐ¼Ð¸ÑƒÐ¼',
            'back': 'ÐÐ°Ð·Ð°Ð´',
            'main_menu': 'Ð“Ð»Ð°Ð²Ð½Ð¾Ðµ Ð¼ÐµÐ½ÑŽ',
            'select_language': 'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ·Ñ‹Ðº:',
            'language_set': 'Ð¯Ð·Ñ‹Ðº Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½',
            'choose_language': 'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ·Ñ‹Ðº:'
        },
        'en': {
            'welcome': 'Hello, {name}!',
            'library': 'Library',
            'cinema': 'Cinema',
            'courses': 'Courses',
            'ai_mentor': 'AI Mentor',
            'profile': 'Profile',
            'premium': 'Premium',
            'back': 'Back',
            'main_menu': 'Main Menu',
            'select_language': 'Select language:',
            'language_set': 'Language changed',
            'choose_language': 'Choose language:'
        }
    }
    
    @staticmethod
    def get(key: str, lang: str = 'uz', **kwargs) -> str:
        """Tarjimani olish"""
        translation = Translations.TRANSLATIONS.get(lang, Translations.TRANSLATIONS['uz']).get(key, key)
        return translation.format(**kwargs) if kwargs else translation
    
    @staticmethod
    def get_language_name(code: str) -> str:
        """Til nomini olish"""
        names = {
            'uz': 'ðŸ‡ºðŸ‡¿ O\'zbek tili',
            'ru': 'ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹',
            'en': 'ðŸ‡¬ðŸ‡§ English'
        }
        return names.get(code, code)

# =============================================================================
# KONFIGURATSIYA - Barcha sozlamalar bir joyda
# =============================================================================
# Environment variable'larni o'qish (ixtiyoriy - agar mavjud bo'lsa)
def _get_env(key: str, default: str = None) -> str:
    """Environment variable'ni olish (fallback: default qiymat)"""
    return os.environ.get(key, default)

def _get_env_list(key: str, default: list = None) -> list:
    """Environment variable'dan list olish (vergul bilan ajratilgan)"""
    value = os.environ.get(key)
    if value:
        return [int(x.strip()) for x in value.split(',') if x.strip().isdigit()]
    return default or []


class Config:
    """
    NEXUS MEDIA BOT KONFIGURATSIYASI
    ================================
    Barcha sozlamalar shu yerda. O'zgartirish uchun quyidagi qiymatlarni tahrirlang.
    
    XAVFSIZLIK: Production'da BOT_TOKEN va OPENAI_API_KEY ni 
    environment variable sifatida saqlash tavsiya etiladi:
    - export BOT_TOKEN="your_token"
    - export OPENAI_API_KEY="your_key"
    """
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. ASOSIY SOZLAMALAR (Bot credentials)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if "BOT_TOKEN" in os.environ:
        os.environ.pop("BOT_TOKEN", None)
    load_dotenv(Path(__file__).parent / ".env")
    
    # HARDCODED CREDENTIALS (AS REQUESTED)
    BOT_TOKEN = "7483264783:AAGuaeeWXCYNx-NZe_0sFwcbHpBiJImapJM"
    ADMIN_IDS = [5895125141]
    SUPPORT_USERNAME = "@iultimatium"
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. DATABASE SOZLAMALARI
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    DB_NAME = "mega_bot.db"
    
    # Supabase credentials (from user)
    SUPABASE_URL = "https://fjbvkzwcptdkwuyqhptv.supabase.co"
    SUPABASE_KEY = "sbp_100f89a0dee0e7ace0877585f4f49082f081df7a"
    SUPABASE_DB_URL = "postgresql://postgres:Asadbek1807@db.fjbvkzwcptdkwuyqhptv.supabase.co:5432/postgres"
    
    # Railway Configuration
    RAILWAY_PROJECT_ID = "3e3437c9-df48-4cac-a124-bfcfec4c27eb"
    RAILWAY_TOKEN = "21855af5-fc2d-495d-9d12-fd27778922f4"
    
    # Termux yoki Windows muhitini aniqlash
    IS_TERMUX = os.path.exists("/data/data/com.termux/files/home")
    if IS_TERMUX:
        BASE_DIR = os.path.expanduser("~")
        DATA_DIR = os.path.join(BASE_DIR, "megabook_bot", "data")
    else:
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))
        DATA_DIR = os.path.join(BASE_DIR, "data")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. TO'LOV SOZLAMALARI (UZS)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PRICE_PREMIUM = 24990      # Premium tarif narxi
    PRICE_EXCLUSIVE = 34990    # Exclusive tarif narxi
    PRICE_EXCLUSIVE_PRO = 34990  # (eski, ishlatilmaydi)
    PRICE_PRO = 24990            # (eski, ishlatilmaydi)
    
    # To'lov kartasi ma'lumotlari
    PAYMENT_CARD = "9860 1766 2113 5019"
    PAYMENT_CARD_NAME = "Asadbek "
    PAYMENT_CARDS = [PAYMENT_CARD]
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. MARKET / XP TIZIMI
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MARKET_PRICES = {
        1: 4500,     # 1 kunlik Premium
        3: 11250,    # 3 kunlik Premium
        7: 22500,    # 7 kunlik Premium
        15: 40500,   # 15 kunlik Premium
        30: 67500,   # 30 kunlik Premium
        31: 112500   # PRO (30 kun)
    }
    
    XP_GAINS = {
        'referral': 50,
        'referral_limit': 1,
        'daily_bonus': 25,
        'download': 10,
        'watch_movie': 20,
        'complete_course': 50,
        'book_upload': 50,
    }
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. TELEGRAM MEDIA FILE ID'LAR
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    WELCOME_VIDEO_FILE_ID = "BAACAgIAAxkBAAJTKmlG-kkntsOGKrUw4hhX_M5NaV2zAAK2hAACGi84SnKWTKAoullDNgQ"
    PREMIUM_VIDEO_FILE_ID = "BAACAgIAAxkBAAJTSWlG_XjM7jRIC71DbKq4LZ2L9G3-AALIjwAC--8xSqKeZV9BtNn8NgQ"
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. DATABASE & SUPABASE CONFIGURATION
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HARDCODED SUPABASE CREDENTIALS (Placeholder for GitHub)
    SUPABASE_URL = "your-supabase-url"
    SUPABASE_KEY = "your-supabase-key"
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7. OPENAI / AI SOZLAMALARI
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HARDCODED API KEYS (Placeholder for GitHub)
    OPENAI_API_KEY = "your-openai-api-key"
    OPENAI_API_URL = "https://api.openai.com/v1/chat/completions"
    OPENAI_MODEL = "gpt-4o-mini"
    
    # Bing Search API (Copilot)
    BING_SEARCH_API_KEY = "" # Add your Bing Search API Key here if available
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8. RATE LIMITING & ANTI-CHEAT
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    RATE_LIMIT_REQUESTS = 10   # Bir daqiqada maksimal so'rovlar
    RATE_LIMIT_WINDOW = 60     # Vaqt oynasi (sekund)
    
    ENABLE_ANTI_CHEAT = True
    MAX_DOWNLOADS_PER_MINUTE = 3
    MAX_AI_QUESTIONS_PER_MINUTE = 3
    MAX_DOWNLOADS_PER_HOUR = 30
    MAX_DOWNLOADS_PER_DAY = 100
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8. SUBSCRIPTION CHEKLOVLARI
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Subscription turlari: 0=Free, 1=Trial, 2=Premium, 3=Exclusive
    
    # Kunlik AI test yaratish limiti (testlar soni)
    DAILY_QUIZ_LIMITS = {0: 2, 1: 5, 2: 9999, 3: 9999}  # Free: 2 ta, Premium/Excl: Cheksiz
    
    # Bir testdagi maksimal savollar soni
    MAX_QUESTIONS_PER_QUIZ = {0: 30, 1: 50, 2: 100, 3: 999}  # Free: 30, Prem: 100, Excl: 999
    
    DAILY_AI_LIMITS = {0: 10, 1: 15, 2: 100, 3: 999} # Eski limitlar (boshqa AI funksiyalar uchun)
    DOWNLOAD_LIMITS = {0: 5, 1: 15, 2: 100, 3: 999}
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 9. TO'LOV TIZIMI
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PAYMENT_CARD = "9860 1766 2113 5019"
    PAYMENT_HOLDER = "Asadbek O'sarov"
    PREMIUM_PRICES = {
        'premium_week': 12990,        # Premium 1 haftalik
        'premium_1': 24990,           # Premium 1 oylik
        'exclusive_week': 14990,      # Exclusive 1 haftalik
        'exclusive_1': 34990,         # Exclusive 1 oylik
        'exclusive_pro_plus_1': 9990, # Exclusive Pro + (1 kun)
    }
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 10. WEBAPP URL
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    WEBAPP_URL = _get_env("WEBAPP_URL", "https://ultimatium07.github.io/nexusi/nexus-ultimate-v2.html")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 11. SUPABASE (RPG Sync)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Duplicate removed
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # UTILITY METODLAR
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @staticmethod
    def setup_dirs():
        """Kerakli papkalarni yaratish"""
        os.makedirs(Config.DATA_DIR, exist_ok=True)
        os.makedirs(os.path.join(Config.DATA_DIR, "excel"), exist_ok=True)
        os.makedirs(os.path.join(Config.DATA_DIR, "backups"), exist_ok=True)
    
    @staticmethod
    def is_admin(user_id: int) -> bool:
        """Admin tekshiruvi (sync - faqat Config)"""
        return user_id in Config.ADMIN_IDS
    
    @staticmethod
    async def check_admin_async(user_id: int, db_manager) -> bool:
        """Admin tekshiruvi (async - Config + Database)"""
        if user_id in Config.ADMIN_IDS:
            return True
        async with db_manager.connect() as conn:
            cursor = await conn.execute('SELECT 1 FROM admin_users WHERE user_id = ?', (user_id,))
            return await cursor.fetchone() is not None
    
    @staticmethod
    def generate_invoice_id() -> str:
        """Unikal invoice ID yaratish"""
        return f"INV{int(time.time())}{random.randint(1000, 9999)}"
    
    @classmethod
    def get_subscription_limits(cls, subscription_type: int) -> dict:
        """Subscription bo'yicha limitlarni olish"""
        return {
            'ai_limit': cls.DAILY_AI_LIMITS.get(subscription_type, 0),
            'download_limit': cls.DOWNLOAD_LIMITS.get(subscription_type, 5)
        }

# =============================================================================
# LOGGING (Papkalar yaratilgandan keyin)
# =============================================================================

# Avval papkalarni yaratish (log fayl yaratishdan oldin)
Config.setup_dirs()

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(Config.DATA_DIR, 'bot.log'), encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Logger yaratilgandan keyin utils haqida xabar berish
if not UTILS_AVAILABLE:
    logger.warning("megabook_utils.py topilmadi. Avtomatik janr tanlash ishlamaydi.")

# =============================================================================
#                           DATABASE MANAGER
# =============================================================================
# SQLite bilan ishlash uchun async database manager.
# WAL mode, optimized PRAGMA settings, connection pooling.
# =============================================================================

class DatabaseManager:
    """SQLite database manager with async support and optimized settings."""
    
    # -------------------------------------------------------------------------
    # INITIALIZATION & CONNECTION
    # -------------------------------------------------------------------------
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.initialized = False
        self.supabase = None
        
        # Initialize Supabase if available
        if SUPABASE_AVAILABLE:
            try:
                self.supabase = create_client(Config.SUPABASE_URL, Config.SUPABASE_KEY)
                logger.info("Supabase client initialized successfully")
            except Exception as e:
                logger.error(f"Supabase initialization error: {e}")

    @asynccontextmanager
    async def connect(self):
        """Bazaga ulanish kontekst manageri - OPTIMIZATSIYA"""
        async with aiosqlite.connect(self.db_path, timeout=60.0) as db:
            db.row_factory = aiosqlite.Row
            # Performance optimizatsiya
            await db.execute("PRAGMA foreign_keys = ON")
            await db.execute("PRAGMA journal_mode = WAL")  # Write-Ahead Logging (parallel o'qish/yozish)
            await db.execute("PRAGMA synchronous = NORMAL")  # Tezroq yozish
            await db.execute("PRAGMA cache_size = -128000")  # 128MB cache (optimallashtirilgan)
            await db.execute("PRAGMA temp_store = MEMORY")  # Temp memory da
            await db.execute("PRAGMA busy_timeout = 300000")  # 300 soniya (5 daqiqa) kutish
            await db.execute("PRAGMA read_uncommitted = 1")  # Uncommitted o'qish (parallel ishlash uchun)
            try:
                yield db
            finally:
                await db.commit()
    
    async def sync_user_to_supabase(self, user_id: int):
        """Sync user data from local SQLite to Supabase"""
        if not self.supabase:
            return
            
        try:
            async with self.connect() as db:
                cursor = await db.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return
                    
                user_data = dict(row)
                
                # Prepare data for Supabase (convert types if needed)
                supabase_data = {
                    'user_id': user_data['user_id'],
                    'full_name': user_data.get('full_name'),
                    'username': user_data.get('username'),
                    'xp': user_data.get('xp', 0),
                    'gold': user_data.get('gold', 0),
                    'level': user_data.get('level', 1),
                    'streak_count': user_data.get('streak_count', 0),
                    'subscription_type': 'premium' if user_data.get('subscription_type') == 2 else 
                                         'exclusive' if user_data.get('subscription_type') == 3 else 'free',
                    'is_premium': user_data.get('subscription_type', 0) > 0,
                    'last_active_date': datetime.now().isoformat()
                }
                
                # Upsert to Supabase
                # Note: supabase-py is sync by default, wrapping in executor might be needed for heavy load,
                # but for simple upsert it's usually fine or we can run in thread.
                await asyncio.to_thread(
                    lambda: self.supabase.table('users').upsert(supabase_data).execute()
                )
                
        except Exception as e:
            logger.error(f"Supabase sync error for user {user_id}: {e}")

    async def init_db(self):
        """Database jadvallarini yaratish"""
        if self.initialized:
            return
        
        async with self.connect() as db:
            # Users jadvali (kengaytirilgan)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    full_name TEXT,
                    username TEXT,
                    phone TEXT,
                    email TEXT,
                    email_notifications BOOLEAN DEFAULT 0,
                    language TEXT DEFAULT 'uz',
                    joined_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    subscription_type INTEGER DEFAULT 0,
                    subscription_end TEXT,
                    trial_used BOOLEAN DEFAULT 0,
                    xp INTEGER DEFAULT 100,
                    balance INTEGER DEFAULT 0,
                    daily_downloads INTEGER DEFAULT 0,
                    daily_ai_usage INTEGER DEFAULT 0,
                    ai_limit INTEGER DEFAULT 3,
                    total_downloads INTEGER DEFAULT 0,
                    streak_count INTEGER DEFAULT 0,
                    streak_last_date TEXT,
                    last_active_date TEXT,
                    last_bonus_date TEXT,
                    last_notification_date TEXT,
                    is_banned BOOLEAN DEFAULT 0,
                    ban_reason TEXT,
                    ban_end TEXT,
                    referral_id INTEGER,
                    referral_count INTEGER DEFAULT 0,
                    total_spent INTEGER DEFAULT 0,
                    avatar_frame TEXT DEFAULT 'default',
                    achievements TEXT DEFAULT '[]',
                    settings TEXT DEFAULT '{}',
                    current_chat_state TEXT DEFAULT NULL,
                    FOREIGN KEY (referral_id) REFERENCES users(user_id)
                )
            ''')
            
            # Migration: qo'shimcha ustunlarni qo'shish
            migration_columns = [
                ('phone', 'TEXT'),
                ('email', 'TEXT'),
                ('email_notifications', 'BOOLEAN DEFAULT 0'),
                ('trial_used', 'BOOLEAN DEFAULT 0'),
                ('balance', 'INTEGER DEFAULT 0'),
                ('daily_downloads', 'INTEGER DEFAULT 0'),
                ('daily_ai_usage', 'INTEGER DEFAULT 0'),
                ('total_downloads', 'INTEGER DEFAULT 0'),
                ('referral_count', 'INTEGER DEFAULT 0'),
                ('streak_count', 'INTEGER DEFAULT 0'),
                ('streak_last_date', 'TEXT'),
                ('ai_limit', 'INTEGER DEFAULT 3'),
                ('total_spent', 'INTEGER DEFAULT 0'),
                ('last_bonus_date', 'TEXT'),
                ('last_notification_date', 'TEXT'),
                ('is_banned', 'BOOLEAN DEFAULT 0'),
                ('ban_reason', 'TEXT'),
                ('ban_end', 'TEXT'),
                ('referral_id', 'INTEGER'),
                ('avatar_frame', 'TEXT DEFAULT \'default\''),
                ('achievements', 'TEXT DEFAULT \'[]\''),
                ('settings', 'TEXT DEFAULT \'{}\''),
                ('current_chat_state', 'TEXT DEFAULT NULL'),
            ]
            
            for col_name, col_type in migration_columns:
                try:
                    await db.execute(f'ALTER TABLE users ADD COLUMN {col_name} {col_type}')
                except Exception:
                    pass  # Ustun allaqachon mavjud
            
            # Battle va gamification uchun ustunlar
            battle_columns = [
                ('weekly_xp', 'INTEGER DEFAULT 0'),
                ('battle_streak', 'INTEGER DEFAULT 0'),
                ('battles_won', 'INTEGER DEFAULT 0'),
                ('battles_played', 'INTEGER DEFAULT 0'),
                ('gold', 'INTEGER DEFAULT 0'),
                ('premium_until', 'TEXT'),
            ]
            
            for col_name, col_type in battle_columns:
                try:
                    await db.execute(f'ALTER TABLE users ADD COLUMN {col_name} {col_type}')
                except Exception:
                    pass
            
            # Trial tizimi uchun ustunlar
            trial_columns = [
                ('trial_started_at', 'TEXT'),
                ('trial_ends_at', 'TEXT'),
                ('trial_offered', 'BOOLEAN DEFAULT 0'),
                ('last_push_sent', 'TEXT'),
                ('last_ai_recommendation_date', 'TEXT'),
            ]
            
            for col_name, col_type in trial_columns:
                try:
                    await db.execute(f'ALTER TABLE users ADD COLUMN {col_name} {col_type}')
                except Exception:
                    pass
            
            # Quiz credit tizimi uchun ustunlar
            quiz_credit_columns = [
                ('quiz_credits_used_today', 'INTEGER DEFAULT 0'),
                ('quiz_credits_date', 'TEXT'),
            ]
            
            for col_name, col_type in quiz_credit_columns:
                try:
                    await db.execute(f'ALTER TABLE users ADD COLUMN {col_name} {col_type}')
                except Exception:
                    pass
            
            # Gamification tizimi uchun ustunlar
            gamification_columns = [
                ('gold', 'INTEGER DEFAULT 0'),  # Oltin valyutasi
                ('level', 'INTEGER DEFAULT 1'),  # Foydalanuvchi darajasi
                ('total_xp', 'INTEGER DEFAULT 0'),  # Jami yig'ilgan XP
                ('weekly_xp', 'INTEGER DEFAULT 0'),  # Haftalik XP
                ('monthly_xp', 'INTEGER DEFAULT 0'),  # Oylik XP
                ('last_daily_challenge', 'TEXT'),  # Oxirgi kunlik challenge
                ('daily_challenges_completed', 'INTEGER DEFAULT 0'),  # Bajarilgan kunlik challengelar
                ('badges', 'TEXT DEFAULT "[]"'),  # Badgelar JSON
                ('notifications_enabled', 'BOOLEAN DEFAULT 1'),  # Bildirishnomalar
                ('last_weekly_reset', 'TEXT'),  # Haftalik reset sanasi
                ('last_monthly_reset', 'TEXT'),  # Oylik reset sanasi
                ('battle_streak', 'INTEGER DEFAULT 0'),  # Live Battle g'oliblik seriyasi
                ('total_battles', 'INTEGER DEFAULT 0'),  # Jami battle soni
                ('battles_won', 'INTEGER DEFAULT 0'),  # G'olib bo'lgan battlelar
            ]
            
            for col_name, col_type in gamification_columns:
                try:
                    await db.execute(f'ALTER TABLE users ADD COLUMN {col_name} {col_type}')
                except Exception:
                    pass
            
            # Leaderboard jadvali (haftalik/oylik snapshot)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS leaderboard_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    period_type TEXT,
                    period_start TEXT,
                    period_end TEXT,
                    xp_earned INTEGER DEFAULT 0,
                    rank INTEGER,
                    reward_xp INTEGER DEFAULT 0,
                    reward_gold INTEGER DEFAULT 0,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Achievements/Badges jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS user_achievements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    achievement_id TEXT,
                    achievement_name TEXT,
                    earned_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    xp_reward INTEGER DEFAULT 0,
                    gold_reward INTEGER DEFAULT 0,
                    UNIQUE(user_id, achievement_id)
                )
            ''')
            
            # Daily Challenges jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS daily_challenges (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    challenge_date TEXT UNIQUE,
                    challenge_type TEXT,
                    challenge_data TEXT,
                    xp_reward INTEGER DEFAULT 50,
                    gold_reward INTEGER DEFAULT 5,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # User daily challenge progress
            await db.execute('''
                CREATE TABLE IF NOT EXISTS user_daily_challenges (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    challenge_date TEXT,
                    progress INTEGER DEFAULT 0,
                    target INTEGER DEFAULT 1,
                    completed BOOLEAN DEFAULT 0,
                    completed_at TEXT,
                    UNIQUE(user_id, challenge_date)
                )
            ''')
            
            # Challenge actions jadvali (ANTI-CHEATING TIZIMI)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS challenge_actions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    action_id TEXT,
                    action_type TEXT,
                    challenge_date TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, action_id, challenge_date)
                )
            ''')
            
            # Challenge actions uchun indexlar (tez qidiruv)
            try:
                await db.execute('CREATE INDEX IF NOT EXISTS idx_challenge_actions_user ON challenge_actions(user_id, challenge_date)')
                await db.execute('CREATE INDEX IF NOT EXISTS idx_challenge_actions_time ON challenge_actions(created_at)')
            except Exception:
                pass
            
            # Notifications jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS user_notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    notification_type TEXT,
                    title TEXT,
                    message TEXT,
                    is_read BOOLEAN DEFAULT 0,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Gold transactions jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS gold_transactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    amount INTEGER,
                    transaction_type TEXT,
                    description TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Payment requests jadvali (to'lov so'rovlari)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS payment_requests (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    payment_id TEXT UNIQUE,
                    user_id INTEGER,
                    plan TEXT,
                    amount INTEGER,
                    receipt_file_id TEXT,
                    status TEXT DEFAULT 'pending',
                    approved_by INTEGER,
                    approved_at TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')

            # Battle Rooms jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS battle_rooms (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    creator_id INTEGER,
                    status TEXT DEFAULT 'waiting',
                    current_question_index INTEGER DEFAULT 0,
                    questions TEXT,
                    started_at TEXT,
                    finished_at TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (creator_id) REFERENCES users(user_id)
                )
            ''')

            # Battle Participants jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS battle_participants (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    room_id INTEGER,
                    user_id INTEGER,
                    score INTEGER DEFAULT 0,
                    joined_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (room_id) REFERENCES battle_rooms(id),
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    UNIQUE(room_id, user_id)
                )
            ''')
            
            # Indexlar (performance uchun)
            indexes = [
                ('idx_last_active', 'users(last_active_date)'),
                ('idx_trial_ends', 'users(trial_ends_at)'),
                ('idx_last_push', 'users(last_push_sent)'),
                ('idx_subscription_type', 'users(subscription_type)'),
                ('idx_is_banned', 'users(is_banned)'),
            ]
            
            for idx_name, idx_def in indexes:
                try:
                    await db.execute(f'CREATE INDEX IF NOT EXISTS {idx_name} ON {idx_def}')
                except Exception:
                    pass
            
            # Books jadvali (order_number OLIB TASHLANDI, premium qo'shildi)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS books (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    code TEXT UNIQUE,
                    file_id TEXT,
                    caption TEXT,
                    author TEXT,
                    genre TEXT,
                    file_type TEXT DEFAULT 'pdf',
                    is_premium INTEGER DEFAULT 0,
                    is_active INTEGER DEFAULT 1,
                    status TEXT DEFAULT 'approved',
                    upload_date TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Books jadvaliga qo'shimcha ustunlarni qo'shish (mavjud ma'lumotlarni saqlab qolish uchun migration)
            try:
                await db.execute('ALTER TABLE books ADD COLUMN description TEXT')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE books ADD COLUMN rating REAL DEFAULT 0.0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE books ADD COLUMN rating_count INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE books ADD COLUMN downloads INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE books ADD COLUMN views INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE books ADD COLUMN file_size INTEGER')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE books ADD COLUMN uploader_id INTEGER')
            except Exception:
                pass
            
            # Book ratings jadvali (kitob reytinglari)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS book_ratings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    book_code TEXT,
                    rating INTEGER,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, book_code),
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Book downloads tracking (kitob yuklashlar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS book_downloads (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    book_code TEXT,
                    download_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Book search index (qidiruv optimizatsiyasi)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS book_search_index (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    book_code TEXT UNIQUE,
                    search_text TEXT,
                    FOREIGN KEY (book_code) REFERENCES books(code)
                )
            ''')
            
            # Book search index uchun index yaratish (tez qidiruv uchun)
            try:
                await db.execute('CREATE INDEX IF NOT EXISTS idx_book_search_text ON book_search_index(search_text)')
            except Exception:
                pass
            
            # Migration: books jadvaliga is_premium qo'shish (AVVAL)
            try:
                await db.execute('ALTER TABLE books ADD COLUMN is_premium INTEGER DEFAULT 0')
                logger.info("Books jadvaliga is_premium qo'shildi")
            except Exception:
                pass  # Ustun allaqachon mavjud
            
            # Book audios jadvali (audio kitoblar uchun)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS book_audios (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    book_id INTEGER,
                    book_code TEXT,
                    file_id TEXT,
                    file_name TEXT,
                    audio_order INTEGER DEFAULT 0,
                    is_premium INTEGER DEFAULT 0,
                    is_active INTEGER DEFAULT 1,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (book_id) REFERENCES books(id)
                )
            ''')
            
            # Migration: books jadvalidan order_number ni olib tashlash (agar mavjud bo'lsa)
            try:
                # Avval books jadvalida order_number borligini tekshirish
                cursor = await db.execute("PRAGMA table_info(books)")
                columns = await cursor.fetchall()
                column_names = [col[1] for col in columns]
                
                # Agar order_number ustuni mavjud bo'lsa, uni olib tashlash
                if 'order_number' in column_names:
                    # SQLite da to'g'ridan-to'g'ri ustunni o'chirib bo'lmaydi
                    # Shuning uchun yangi jadval yaratib, ma'lumotlarni ko'chiramiz
                    await db.execute('''
                        CREATE TABLE IF NOT EXISTS books_new (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            code TEXT UNIQUE,
                            file_id TEXT,
                            caption TEXT,
                            author TEXT,
                            genre TEXT,
                            file_type TEXT DEFAULT 'pdf',
                            is_premium INTEGER DEFAULT 0,
                            is_active INTEGER DEFAULT 1,
                            status TEXT DEFAULT 'approved',
                            upload_date TEXT DEFAULT CURRENT_TIMESTAMP
                        )
                    ''')
                    await db.execute('''
                        INSERT INTO books_new (id, code, file_id, caption, author, genre, file_type, is_premium, is_active, status, upload_date)
                        SELECT id, code, file_id, caption, author, genre, file_type, 
                               COALESCE(is_premium, 0) as is_premium,
                               is_active, status, upload_date
                        FROM books
                    ''')
                    await db.execute('DROP TABLE books')
                    await db.execute('ALTER TABLE books_new RENAME TO books')
                    logger.info("Books jadvalidan order_number olib tashlandi va is_premium qo'shildi")
            except Exception as e:
                logger.debug(f"Books migration: {e}")
                pass
            
            # Movies jadvali (order_number QO'SHILDI)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS movies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    file_id TEXT,
                    caption TEXT,
                    genre TEXT,
                    quality TEXT DEFAULT '720p',
                    order_number INTEGER,
                    is_active INTEGER DEFAULT 1,
                    status TEXT DEFAULT 'approved',
                    upload_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    downloads INTEGER DEFAULT 0,
                    views INTEGER DEFAULT 0,
                    rating REAL DEFAULT 0,
                    rating_count INTEGER DEFAULT 0,
                    year INTEGER,
                    description TEXT
                )
            ''')
            
            # Migration: movies jadvaliga yangi ustunlar qo'shish
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN order_number INTEGER')
                logger.info("Movies jadvaliga order_number qo'shildi")
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN downloads INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN views INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN rating REAL DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN rating_count INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN year INTEGER')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN description TEXT')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN language TEXT DEFAULT "uz"')
                logger.info("Movies jadvaliga language qo'shildi")
            except Exception:
                pass
            
            # Order number index
            try:
                await db.execute('CREATE INDEX IF NOT EXISTS idx_movies_order ON movies(order_number)')
            except Exception:
                pass
            
            # Movie codes jadvali (qidiruv uchun kodlar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS movie_codes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    movie_id INTEGER,
                    code TEXT UNIQUE,
                    FOREIGN KEY (movie_id) REFERENCES movies(id)
                )
            ''')
            
            # Movie episodes jadvali (seriallar uchun qismlar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS movie_episodes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    movie_id INTEGER,
                    episode_number INTEGER,
                    file_id TEXT,
                    title TEXT,
                    duration TEXT,
                    upload_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    downloads INTEGER DEFAULT 0,
                    FOREIGN KEY (movie_id) REFERENCES movies(id)
                )
            ''')
            
            # is_series ustunini movies jadvaliga qo'shish
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN is_series INTEGER DEFAULT 0')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN total_episodes INTEGER DEFAULT 0')
            except Exception:
                pass
            
            # Migration: Mavjud kinolarga order_number va kod qo'yish
            try:
                cursor = await db.execute('SELECT id, caption FROM movies WHERE order_number IS NULL ORDER BY id')
                rows = await cursor.fetchall()
                
                # 1 dan 10 gacha kodlar
                code_counter = 1
                for idx, row in enumerate(rows, start=1):
                    movie_id = row[0]
                    
                    # Order number qo'yish
                    await db.execute('UPDATE movies SET order_number = ? WHERE id = ?', (idx, movie_id))
                    
                    # Kod qo'yish (1-10 gacha)
                    if code_counter <= 10:
                        code = str(code_counter)
                        try:
                            await db.execute('INSERT INTO movie_codes (movie_id, code) VALUES (?, ?)', (movie_id, code))
                        except Exception:
                            pass  # Kod allaqachon mavjud
                        code_counter += 1
                    
                if rows:
                    logger.info(f"Mavjud {len(rows)} ta kinoga order_number va kod qo'yildi")
            except Exception as e:
                logger.debug(f"Movies order_number migration: {e}")
                pass
            
            # Migration: Mavjud kinolarga 1-10 gacha kodlar qo'yish (agar yo'q bo'lsa)
            try:
                cursor = await db.execute('''
                    SELECT m.id FROM movies m
                    LEFT JOIN movie_codes mc ON m.id = mc.movie_id
                    WHERE mc.id IS NULL AND m.is_active = 1
                    ORDER BY m.id
                    LIMIT 10
                ''')
                rows = await cursor.fetchall()
                for idx, row in enumerate(rows, start=1):
                    movie_id = row[0]
                    code = str(idx)
                    try:
                        await db.execute('INSERT INTO movie_codes (movie_id, code) VALUES (?, ?)', (movie_id, code))
                    except Exception:
                        pass
                if rows:
                    logger.info(f"{len(rows)} ta kinoga kod qo'yildi (1-10)")
            except Exception as e:
                logger.debug(f"Movie codes migration: {e}")
                pass
            
            # Courses jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS courses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT,
                    description TEXT,
                    full_description TEXT,
                    instructor TEXT,
                    file_id TEXT,
                    category TEXT,
                    subcategory TEXT,
                    duration TEXT,
                    lessons_count INTEGER DEFAULT 1,
                    price INTEGER DEFAULT 19990,
                    discount_price INTEGER,
                    students_count INTEGER DEFAULT 0,
                    rating REAL DEFAULT 0.0,
                    rating_count INTEGER DEFAULT 0,
                    requirements TEXT,
                    what_you_get TEXT,
                    tags TEXT DEFAULT '[]',
                    order_number INTEGER,
                    is_active INTEGER DEFAULT 1,
                    status TEXT DEFAULT 'approved',
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Course videos jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS course_videos (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    course_id INTEGER,
                    video_id TEXT,
                    video_order INTEGER,
                    is_demo INTEGER DEFAULT 0,
                    title TEXT,
                    duration TEXT,
                    FOREIGN KEY (course_id) REFERENCES courses(id)
                )
            ''')
            
            # User courses (purchases)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS user_courses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    course_id INTEGER,
                    purchase_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    price_paid INTEGER,
                    progress INTEGER DEFAULT 0,
                    last_accessed TEXT,
                    completed BOOLEAN DEFAULT 0,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (course_id) REFERENCES courses(id)
                )
            ''')
            
            # Payments jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS payments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    payment_id TEXT UNIQUE,
                    user_id INTEGER,
                    amount INTEGER,
                    currency TEXT DEFAULT 'UZS',
                    payment_method TEXT,
                    status TEXT DEFAULT 'pending',
                    description TEXT,
                    invoice_id TEXT,
                    transaction_id TEXT,
                    payment_date TEXT,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    confirmed_by INTEGER,
                    confirmed_date TEXT,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (confirmed_by) REFERENCES users(user_id)
                )
            ''')
            
            # Pending uploads (admin tasdiqlashi uchun)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS pending_uploads (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    item_type TEXT,
                    item_data TEXT,
                    item_name TEXT,
                    status TEXT DEFAULT 'pending',
                    uploaded_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    approved_by INTEGER,
                    approved_at TEXT,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (approved_by) REFERENCES users(user_id)
                )
            ''')
            
            # Download history jadvali (statistika uchun)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS download_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    item_type TEXT,
                    item_id INTEGER,
                    download_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Migration: payment_requests jadvaliga payment_id qo'shish
            try:
                await db.execute('ALTER TABLE payment_requests ADD COLUMN payment_id TEXT UNIQUE')
                logger.info("payment_requests jadvaliga payment_id qo'shildi")
            except Exception:
                pass
            
            # Migration: courses jadvaliga full_description qo'shish (agar yo'q bo'lsa)
            try:
                await db.execute('ALTER TABLE courses ADD COLUMN full_description TEXT')
                logger.info("Courses jadvaliga full_description qo'shildi")
            except Exception:
                pass  # Ustun allaqachon mavjud
            
            # XP transactions
            await db.execute('''
                CREATE TABLE IF NOT EXISTS xp_transactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    amount INTEGER,
                    type TEXT,
                    description TEXT,
                    related_id TEXT,
                    date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Referrals jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS referrals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    referrer_id INTEGER,
                    referred_id INTEGER UNIQUE,
                    xp_gained INTEGER DEFAULT 75,
                    limit_gained INTEGER DEFAULT 1,
                    date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (referrer_id) REFERENCES users(user_id),
                    FOREIGN KEY (referred_id) REFERENCES users(user_id)
                )
            ''')
            
            # Podcasts jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS podcasts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    description TEXT,
                    file_id TEXT,
                    video_file_id TEXT,
                    content_type TEXT DEFAULT 'audio',
                    category TEXT DEFAULT 'Boshqa',
                    language TEXT DEFAULT 'uz',
                    duration INTEGER,
                    host TEXT,
                    episode_number INTEGER,
                    is_premium INTEGER DEFAULT 0,
                    is_active INTEGER DEFAULT 1,
                    downloads INTEGER DEFAULT 0,
                    views INTEGER DEFAULT 0,
                    rating REAL DEFAULT 0,
                    rating_count INTEGER DEFAULT 0,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    created_by INTEGER,
                    status TEXT DEFAULT 'approved',
                    FOREIGN KEY (created_by) REFERENCES users(user_id)
                )
            ''')
            
            # Podcasts jadvaliga yangi ustunlar qo'shish (migration)
            try:
                await db.execute('ALTER TABLE podcasts ADD COLUMN language TEXT DEFAULT "uz"')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE podcasts ADD COLUMN video_file_id TEXT')
            except Exception:
                pass
            try:
                await db.execute('ALTER TABLE podcasts ADD COLUMN content_type TEXT DEFAULT "audio"')
            except Exception:
                pass
            
            # Support tickets jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS support_tickets (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    ticket_id TEXT UNIQUE,
                    category TEXT,
                    message TEXT,
                    status TEXT DEFAULT 'open',
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    resolved_date TEXT,
                    resolved_by INTEGER,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (resolved_by) REFERENCES users(user_id)
                )
            ''')
            
            # Promo codes jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS promo_codes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    code TEXT UNIQUE,
                    discount_percent INTEGER DEFAULT 0,
                    discount_amount INTEGER DEFAULT 0,
                    max_uses INTEGER DEFAULT 1,
                    used_count INTEGER DEFAULT 0,
                    valid_from TEXT,
                    valid_until TEXT,
                    is_active INTEGER DEFAULT 1,
                    created_by INTEGER,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (created_by) REFERENCES users(user_id)
                )
            ''')
            
            # Favorites jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS favorites (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    item_type TEXT,
                    item_id INTEGER,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, item_type, item_id),
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Genres jadvali (janrlar tizimi)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS genres (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE,
                    type TEXT,
                    icon TEXT,
                    description TEXT,
                    min_subscription INTEGER DEFAULT 0,
                    is_active BOOLEAN DEFAULT 1,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Mining farms jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS mining_farms (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER UNIQUE,
                    level INTEGER DEFAULT 1,
                    xp_per_hour INTEGER DEFAULT 10,
                    last_collected TEXT,
                    total_collected INTEGER DEFAULT 0,
                    upgrade_cost INTEGER DEFAULT 1000,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Duels jadvali (duel o'yinlari)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS duels (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    player1_id INTEGER,
                    player2_id INTEGER,
                    game_type TEXT DEFAULT 'rps',
                    player1_choice TEXT,
                    player2_choice TEXT,
                    winner_id INTEGER,
                    xp_bet INTEGER DEFAULT 50,
                    status TEXT DEFAULT 'pending',
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    finished_at TEXT,
                    FOREIGN KEY (player1_id) REFERENCES users(user_id),
                    FOREIGN KEY (player2_id) REFERENCES users(user_id),
                    FOREIGN KEY (winner_id) REFERENCES users(user_id)
                )
            ''')
            
            # Leagues jadvali (liga tizimi)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS leagues (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    league_name TEXT UNIQUE,
                    min_xp INTEGER DEFAULT 0,
                    max_xp INTEGER DEFAULT 999999,
                    icon TEXT,
                    description TEXT
                )
            ''')
            
            # Excel exports jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS excel_exports (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    export_type TEXT,
                    file_path TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Sent files jadvali (avtomatik yuborish uchun)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS sent_files (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    file_id TEXT,
                    item_id TEXT,
                    item_type TEXT,
                    title TEXT,
                    sent_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(file_id, item_id, item_type)
                )
            ''')
            
            # Email subscriptions jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS email_subscriptions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    email TEXT,
                    subscription_type TEXT,
                    is_active BOOLEAN DEFAULT 1,
                    subscribed_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Push notifications jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS push_notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    notification_type TEXT,
                    title TEXT,
                    message TEXT,
                    sent_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    read_at TEXT,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Achievements definitions jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS achievement_definitions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    achievement_id TEXT UNIQUE,
                    name TEXT,
                    description TEXT,
                    icon TEXT,
                    xp_reward INTEGER DEFAULT 0,
                    condition_type TEXT,
                    condition_value INTEGER,
                    is_active BOOLEAN DEFAULT 1
                )
            ''')
            
            # Payment cards jadvali (to'lov kartalari)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS payment_cards (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    card_number TEXT UNIQUE,
                    card_name TEXT,
                    added_by INTEGER,
                    added_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1,
                    FOREIGN KEY (added_by) REFERENCES users(user_id)
                )
            ''')
            
            # User activity log jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS user_activity_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    activity_type TEXT,
                    details TEXT,
                    timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # System stats jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS system_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    stat_type TEXT,
                    stat_value INTEGER,
                    stat_date TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Command stats jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS command_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    command TEXT,
                    usage_count INTEGER DEFAULT 0,
                    last_used TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Backups jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS backups (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    backup_type TEXT,
                    file_path TEXT,
                    file_size INTEGER,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    created_by INTEGER,
                    FOREIGN KEY (created_by) REFERENCES users(user_id)
                )
            ''')
            
            # User history jadvali (ko'rilgan/yuklanganlar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS user_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    item_type TEXT,
                    item_id INTEGER,
                    item_name TEXT,
                    action_type TEXT,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Reviews jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS reviews (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    item_type TEXT,
                    item_id INTEGER,
                    rating INTEGER,
                    comment TEXT,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Bonuses jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS bonuses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    bonus_type TEXT,
                    amount INTEGER,
                    description TEXT,
                    expiry_date TEXT,
                    is_used INTEGER DEFAULT 0,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Admin users jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS admin_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER UNIQUE,
                    role TEXT DEFAULT 'admin',
                    permissions TEXT DEFAULT 'all',
                    added_by INTEGER,
                    added_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (added_by) REFERENCES users(user_id)
                )
            ''')
            
            # Broadcast messages jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS broadcast_messages (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    sent_by INTEGER,
                    message_text TEXT,
                    sent_count INTEGER DEFAULT 0,
                    failed_count INTEGER DEFAULT 0,
                    created_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (sent_by) REFERENCES users(user_id)
                )
            ''')
            
            # Order number index
            try:
                await db.execute('CREATE INDEX IF NOT EXISTS idx_courses_order ON courses(order_number)')
            except Exception:
                pass
            
            # Migration: Courses jadvaliga order_number qo'shish (agar mavjud bo'lmasa)
            try:
                await db.execute('ALTER TABLE courses ADD COLUMN order_number INTEGER')
                logger.info("Added order_number column to courses table")
            except Exception:
                pass  # Ustun allaqachon mavjud
            
            # =================================================================
            # AI QUIZ MAKER JADVALLARI
            # =================================================================
            
            # Quizzes jadvali (testlar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quizzes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    title TEXT NOT NULL,
                    description TEXT,
                    source_type TEXT DEFAULT 'topic',
                    source_id TEXT,
                    category TEXT DEFAULT 'Umumiy',
                    difficulty TEXT DEFAULT 'medium',
                    questions_json TEXT,
                    total_questions INTEGER DEFAULT 0,
                    time_limit INTEGER DEFAULT 0,
                    pass_score INTEGER DEFAULT 60,
                    is_public INTEGER DEFAULT 0,
                    is_active INTEGER DEFAULT 1,
                    plays_count INTEGER DEFAULT 0,
                    avg_score REAL DEFAULT 0,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Quiz questions jadvali (test savollari)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_questions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    quiz_id INTEGER,
                    question TEXT NOT NULL,
                    options TEXT,
                    correct_answer TEXT,
                    explanation TEXT,
                    order_num INTEGER DEFAULT 0,
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
                )
            ''')
            
            # Migration: quiz_questions jadvalini yaratish (eski database uchun)
            try:
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS quiz_questions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        quiz_id INTEGER,
                        question TEXT NOT NULL,
                        options TEXT,
                        correct_answer TEXT,
                        explanation TEXT,
                        order_num INTEGER DEFAULT 0
                    )
                ''')
            except Exception:
                pass
            
            # Quiz attempts jadvali (test urinishlari)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_attempts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    quiz_id INTEGER,
                    score INTEGER DEFAULT 0,
                    total_questions INTEGER,
                    correct_answers INTEGER DEFAULT 0,
                    wrong_answers INTEGER DEFAULT 0,
                    answers_json TEXT,
                    time_spent INTEGER DEFAULT 0,
                    xp_earned INTEGER DEFAULT 0,
                    completed INTEGER DEFAULT 0,
                    started_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    completed_at TEXT,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
                )
            ''')
            
            # Quiz SRS jadvali (Spaced Repetition System - Interval takrorlash)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_srs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    quiz_id INTEGER,
                    question_index INTEGER,
                    question_text TEXT,
                    easiness_factor REAL DEFAULT 2.5,
                    repetition_count INTEGER DEFAULT 0,
                    interval_days INTEGER DEFAULT 1,
                    last_reviewed_at TEXT,
                    next_review_at TEXT,
                    is_mastered INTEGER DEFAULT 0,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, quiz_id, question_index),
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
                )
            ''')
            
            # Quiz mistakes jadvali (xatolar banki)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_mistakes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    quiz_id INTEGER,
                    question_index INTEGER,
                    question_text TEXT,
                    correct_answer TEXT,
                    user_answer TEXT,
                    mistake_count INTEGER DEFAULT 1,
                    last_mistake_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    is_resolved INTEGER DEFAULT 0,
                    UNIQUE(user_id, quiz_id, question_index),
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
                )
            ''')
            
            # Duels jadvali (oddiy duel - tosh/qaychi/qog'oz)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS duels (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    player1_id INTEGER,
                    player2_id INTEGER,
                    player1_choice TEXT,
                    player2_choice TEXT,
                    winner_id INTEGER,
                    xp_bet INTEGER DEFAULT 50,
                    status TEXT DEFAULT 'pending',
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    finished_at TEXT
                )
            ''')
            
            # Quiz duels jadvali (test duel/battle)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_duels (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    player1_id INTEGER,
                    player2_id INTEGER,
                    quiz_id INTEGER,
                    category TEXT,
                    player1_score INTEGER DEFAULT 0,
                    player2_score INTEGER DEFAULT 0,
                    player1_time INTEGER DEFAULT 0,
                    player2_time INTEGER DEFAULT 0,
                    current_question INTEGER DEFAULT 0,
                    total_questions INTEGER DEFAULT 5,
                    winner_id INTEGER,
                    xp_bet INTEGER DEFAULT 50,
                    status TEXT DEFAULT 'waiting',
                    invite_link TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    started_at TEXT,
                    finished_at TEXT,
                    FOREIGN KEY (player1_id) REFERENCES users(user_id),
                    FOREIGN KEY (player2_id) REFERENCES users(user_id),
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id),
                    FOREIGN KEY (winner_id) REFERENCES users(user_id)
                )
            ''')
            
            # Quiz streaks jadvali (seriya tizimi + RPG)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_streaks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER UNIQUE,
                    current_streak INTEGER DEFAULT 0,
                    longest_streak INTEGER DEFAULT 0,
                    last_quiz_date TEXT,
                    total_quizzes_taken INTEGER DEFAULT 0,
                    total_correct_answers INTEGER DEFAULT 0,
                    streak_xp_bonus INTEGER DEFAULT 0,
                    gold INTEGER DEFAULT 0,
                    hints INTEGER DEFAULT 0,
                    fifty_fifty INTEGER DEFAULT 0,
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Quiz certificates jadvali (sertifikatlar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_certificates (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    quiz_id INTEGER,
                    certificate_id TEXT UNIQUE,
                    score INTEGER,
                    grade TEXT,
                    file_id TEXT,
                    issued_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
                )
            ''')
            
            # Quiz leaderboard jadvali (haftalik reyting)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_leaderboard (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    week_start TEXT,
                    total_score INTEGER DEFAULT 0,
                    quizzes_completed INTEGER DEFAULT 0,
                    correct_answers INTEGER DEFAULT 0,
                    avg_time INTEGER DEFAULT 0,
                    rank INTEGER,
                    UNIQUE(user_id, week_start),
                    FOREIGN KEY (user_id) REFERENCES users(user_id)
                )
            ''')
            
            # Quiz categories jadvali
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_categories (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE,
                    icon TEXT,
                    description TEXT,
                    quiz_count INTEGER DEFAULT 0,
                    is_active INTEGER DEFAULT 1
                )
            ''')
            
            # Quiz flashcards jadvali (flesh-kartalar)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS quiz_flashcards (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    quiz_id INTEGER,
                    term TEXT,
                    definition TEXT,
                    is_learned INTEGER DEFAULT 0,
                    review_count INTEGER DEFAULT 0,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(user_id),
                    FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
                )
            ''')
            
            # Quiz indexes
            try:
                await db.execute('CREATE INDEX IF NOT EXISTS idx_quiz_user ON quizzes(user_id)')
                await db.execute('CREATE INDEX IF NOT EXISTS idx_quiz_attempts_user ON quiz_attempts(user_id)')
                await db.execute('CREATE INDEX IF NOT EXISTS idx_quiz_srs_review ON quiz_srs(next_review_at)')
                await db.execute('CREATE INDEX IF NOT EXISTS idx_quiz_duels_status ON quiz_duels(status)')
                await db.execute('CREATE INDEX IF NOT EXISTS idx_quiz_streaks_user ON quiz_streaks(user_id)')
            except Exception:
                pass
            
            # Default quiz categories
            quiz_categories = [
                ("ðŸ“š Adabiyot", "ðŸ“š", "Adabiyot va til bo'yicha testlar"),
                ("ðŸ”¬ Fan va texnologiya", "ðŸ”¬", "Ilm-fan va texnologiya testlari"),
                ("ðŸŒ Tarix va geografiya", "ðŸŒ", "Tarix va geografiya testlari"),
                ("ðŸ’¼ Biznes va iqtisod", "ðŸ’¼", "Biznes va iqtisodiyot testlari"),
                ("ðŸ§  Psixologiya", "ðŸ§ ", "Psixologiya va shaxsiy rivojlanish"),
                ("ðŸ’» Dasturlash", "ðŸ’»", "Dasturlash va IT testlari"),
                ("ðŸ‡¬ðŸ‡§ Ingliz tili", "ðŸ‡¬ðŸ‡§", "Ingliz tili testlari"),
                ("ðŸŽ“ Umumiy bilim", "ðŸŽ“", "Umumiy bilim testlari"),
                ("ðŸŽ¬ Kino va san'at", "ðŸŽ¬", "Kino, musiqa va san'at"),
                ("âš½ Sport", "âš½", "Sport testlari")
            ]
            
            for cat in quiz_categories:
                try:
                    await db.execute('''
                        INSERT OR IGNORE INTO quiz_categories (name, icon, description)
                        VALUES (?, ?, ?)
                    ''', cat)
                except Exception:
                    pass
            
            logger.info("Database initialized successfully (with Quiz tables)")
            self.initialized = True
            
            # Dastlabki ma'lumotlarni qo'shish (genres)
            await self.initialize_default_data(db)
    
    async def initialize_default_data(self, db):
        """Dastlabki ma'lumotlarni qo'shish (genres)"""
        try:
            # Genres (kitob va film janrlari)
            book_genres = [
                ("ðŸ“š Badiiy adabiyot", "book", "ðŸ“š", "Badiiy asarlar, romanlar, qissalar"),
                ("ðŸŒ Jahon adabiyoti", "book", "ðŸŒ", "Jahon adabiyoti asarlari"),
                ("ðŸ•Œ Diniy adabiyot", "book", "ðŸ•Œ", "Diniy kitoblar va qo'llanmalar"),
                ("ðŸ’¼ Biznes va moliya", "book", "ðŸ’¼", "Biznes, marketing, moliya"),
                ("ðŸ’» Dasturlash va IT", "book", "ðŸ’»", "Dasturlash, sun'iy intellekt, texnologiya"),
                ("ðŸ§  Psixologiya", "book", "ðŸ§ ", "Psixologiya, shaxsiy rivojlanish"),
                ("ðŸ›ï¸ Tarix va siyosat", "book", "ðŸ›ï¸", "Tarixiy asarlar va siyosiy adabiyot"),
                ("ðŸ”¬ Ilm-fan", "book", "ðŸ”¬", "Ilmiy adabiyotlar"),
                ("ðŸ³ Oshxona va salomatlik", "book", "ðŸ³", "Oshxona kitoblari, sog'lom turmush"),
                ("ðŸ‘¶ Bolalar adabiyoti", "book", "ðŸ‘¶", "Bolalar uchun kitoblar"),
                ("ðŸŽ¨ San'at va dizayn", "book", "ðŸŽ¨", "San'at, dizayn, arxitektura"),
                ("ðŸ“– Talim kitoblari", "book", "ðŸ“–", "Maktab va universitet adabiyotlari")
            ]
            
            movie_genres = [
                ("ðŸŽ¬ Jangari filmlar", "movie", "ðŸŽ¬", "Jangari va triller filmlar"),
                ("ðŸ˜‚ Komediya", "movie", "ðŸ˜‚", "Komediya va hazil filmlar"),
                ("â¤ï¸ Romantika", "movie", "â¤ï¸", "Romantik va sevgi hikoyalari"),
                ("ðŸ‘» Qo'rqinchli", "movie", "ðŸ‘»", "Qo'rqinchli va dahshatli filmlar"),
                ("ðŸš€ Fantastika", "movie", "ðŸš€", "Fantastika va ilmiy fantastika"),
                ("ðŸº Tarixiy", "movie", "ðŸº", "Tarixiy filmlar"),
                ("ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Oila", "movie", "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦", "Oila uchun filmlar"),
                ("ðŸ° Multfilmlar", "movie", "ðŸ°", "Multfilmlar va animatsiya"),
                ("ðŸ‡¯ðŸ‡µ Anime", "movie", "ðŸ‡¯ðŸ‡µ", "Anime va manga"),
                ("ðŸ“½ï¸ Hujjatli filmlar", "movie", "ðŸ“½ï¸", "Hujjatli filmlar"),
                ("ðŸŽ­ Drama", "movie", "ðŸŽ­", "Dramatik filmlar"),
                ("ðŸ” Detektiv", "movie", "ðŸ”", "Detektiv va sirli filmlar")
            ]
            
            for genre in book_genres + movie_genres:
                try:
                    await db.execute('''
                        INSERT OR IGNORE INTO genres (name, type, icon, description)
                        VALUES (?, ?, ?, ?)
                    ''', genre)
                except Exception as e:
                    logger.debug(f"Genre insert warning: {e}")
                    pass
            
            logger.info("Default data (genres) initialized successfully")
        except Exception as e:
            logger.error(f"initialize_default_data error: {e}")
    
    # -------------------------------------------------------------------------
    # GENRE METHODS
    # -------------------------------------------------------------------------
    
    async def get_genres(self, genre_type: str = None) -> List[Dict]:
        """Janrlarni olish"""
        try:
            async with self.connect() as db:
                if genre_type:
                    cursor = await db.execute('''
                        SELECT * FROM genres 
                        WHERE type = ? AND is_active = 1
                        ORDER BY name
                    ''', (genre_type,))
                else:
                    cursor = await db.execute('''
                        SELECT * FROM genres 
                        WHERE is_active = 1
                        ORDER BY type, name
                    ''')
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_genres error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # USER METHODS
    # -------------------------------------------------------------------------
    
    async def add_user(self, user_id: int, full_name: str = None, username: str = None, referral_id: int = None):
        """Yangi foydalanuvchi qo'shish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute("SELECT 1 FROM users WHERE user_id = ?", (user_id,))
                if not await cursor.fetchone():
                    await db.execute('''
                        INSERT INTO users (user_id, full_name, username, referral_id, joined_date, last_active_date, streak_last_date, ai_limit, xp)
                        VALUES (?, ?, ?, ?, datetime('now'), datetime('now'), date('now', '-1 day'), 3, 100)
                    ''', (user_id, full_name, username, referral_id))
                    
                    # Mining farm yaratish
                    try:
                        await db.execute('INSERT INTO mining_farms (user_id) VALUES (?)', (user_id,))
                    except Exception:
                        pass
                    
                    # Referal tizimi
                    if referral_id and referral_id != user_id:
                        ref_check = await db.execute("SELECT 1 FROM users WHERE user_id = ?", (referral_id,))
                        if await ref_check.fetchone():
                            await db.execute('''
                                INSERT OR IGNORE INTO referrals (referrer_id, referred_id, xp_gained, limit_gained)
                                VALUES (?, ?, ?, ?)
                            ''', (referral_id, user_id, Config.XP_GAINS['referral'], Config.XP_GAINS['referral_limit']))
                            
                            # XP va limit qo'shish
                            await db.execute('''
                                UPDATE users 
                                SET xp = xp + ?, 
                                    ai_limit = ai_limit + ?,
                                    referral_count = referral_count + 1
                                WHERE user_id = ?
                            ''', (Config.XP_GAINS['referral'], Config.XP_GAINS['referral_limit'], referral_id))
                            await db.commit()
                    
                    logger.info(f"Yangi foydalanuvchi qo'shildi: {user_id}")
                    return True
            return False
        except Exception as e:
            logger.error(f"add_user error: {e}")
            return False
    
    async def get_user(self, user_id: int) -> Optional[Dict]:
        """Foydalanuvchi ma'lumotlari"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_user error: {e}")
            return None
    
    # -------------------------------------------------------------------------
    # BOOK METHODS
    # -------------------------------------------------------------------------
    
    async def add_book(self, code: str, file_id: str, caption: str, author: str = "", genre: str = "Boshqa", is_premium: int = 0):
        """Kitob qo'shish (order_number OLIB TASHLANDI, premium qo'shildi)"""
        try:
            # Agar janr "Boshqa" bo'lsa va utils mavjud bo'lsa, avtomatik aniqlash
            if genre == "Boshqa" and UTILS_AVAILABLE:
                try:
                    detected_genre = detect_genre(caption, "book")
                    if detected_genre != "Boshqa":
                        genre = detected_genre
                except Exception as e:
                    logger.debug(f"Avtomatik janr aniqlash xatosi: {e}")
            
            async with self.connect() as db:
                await db.execute('''
                    INSERT OR IGNORE INTO books (code, file_id, caption, author, genre, is_premium, is_active, status)
                    VALUES (?, ?, ?, ?, ?, ?, 1, 'approved')
                ''', (code, file_id, caption, author, genre, is_premium))
                await db.commit()
                logger.info(f"Kitob qo'shildi: code={code}, caption={caption}, genre={genre}, is_premium={is_premium}")
                return True
        except Exception as e:
            logger.error(f"add_book error: {e}", exc_info=True)
            return False
    
    async def add_audio_book(self, book_code: str, file_id: str, file_name: str = "", audio_order: int = 0, is_premium: int = 0):
        """Audio kitob qo'shish"""
        try:
            async with self.connect() as db:
                # Book ID ni olish
                cursor = await db.execute('SELECT id FROM books WHERE code = ?', (book_code,))
                row = await cursor.fetchone()
                book_id = row[0] if row else None
                
                await db.execute('''
                    INSERT INTO book_audios (book_id, book_code, file_id, file_name, audio_order, is_premium, is_active)
                    VALUES (?, ?, ?, ?, ?, ?, 1)
                ''', (book_id, book_code, file_id, file_name, audio_order, is_premium))
                await db.commit()
                logger.info(f"Audio kitob qo'shildi: book_code={book_code}, file_name={file_name}, is_premium={is_premium}")
                return True
        except Exception as e:
            logger.error(f"add_audio_book error: {e}", exc_info=True)
            return False
    
    async def get_audio_books(self, book_code: str = None, is_premium: int = None, limit: int = 50) -> List[Dict]:
        """Audio kitoblarni olish"""
        try:
            async with self.connect() as db:
                query = 'SELECT * FROM book_audios WHERE is_active = 1'
                params = []
                
                if book_code:
                    query += ' AND book_code = ?'
                    params.append(book_code)
                
                if is_premium is not None:
                    query += ' AND is_premium = ?'
                    params.append(is_premium)
                
                query += ' ORDER BY audio_order ASC LIMIT ?'
                params.append(limit)
                
                cursor = await db.execute(query, tuple(params))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_audio_books error: {e}")
            return []
    
    async def get_premium_books(self, limit: int = 50) -> List[Dict]:
        """Premium kitoblarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM books 
                    WHERE is_premium = 1 AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY upload_date DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_premium_books error: {e}")
            return []
    
    async def get_book(self, code: str) -> Optional[Dict]:
        """Kitob ma'lumotlari (rating bilan)"""
        try:
            async with self.connect() as db:
                # Rating ustunlarini qo'shish uchun COALESCE ishlatamiz (agar mavjud bo'lmasa, 0 qaytaradi)
                cursor = await db.execute('''
                    SELECT *, 
                           COALESCE(rating, 0.0) as rating,
                           COALESCE(rating_count, 0) as rating_count,
                           COALESCE(downloads, 0) as downloads,
                           COALESCE(views, 0) as views
                    FROM books 
                    WHERE code = ? AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                ''', (code,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_book error: {e}")
            return None
    
    async def search_books(self, query: str, limit: int = 20) -> List[Dict]:
        """Kitoblarni qidirish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM books 
                    WHERE (caption LIKE ? OR author LIKE ?) 
                    AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    LIMIT ?
                ''', (f'%{query}%', f'%{query}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"search_books error: {e}")
            return []
    
    async def get_random_books(self, limit: int = 5) -> List[Dict]:
        """Tasodifiy kitoblar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM books 
                    WHERE is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY RANDOM()
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_random_books error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # MOVIE METHODS
    # -------------------------------------------------------------------------
    
    async def add_movie(self, file_id: str, caption: str, genre: str = "Boshqa", quality: str = "720p", language: str = "uz"):
        """Film qo'shish (AVTOMATIK order_number, kod va quality bilan)"""
        try:
            # Agar janr "Boshqa" bo'lsa va utils mavjud bo'lsa, avtomatik aniqlash
            if genre == "Boshqa" and UTILS_AVAILABLE:
                try:
                    detected_genre = detect_genre(caption, "movie")
                    if detected_genre != "Boshqa":
                        genre = detected_genre
                except Exception as e:
                    logger.debug(f"Avtomatik janr aniqlash xatosi: {e}")
            
            async with self.connect() as db:
                # Avtomatik order_number olish
                cursor = await db.execute('SELECT MAX(order_number) FROM movies WHERE is_active = 1')
                row = await cursor.fetchone()
                max_order = row[0] if row[0] is not None else 0
                order_number = max_order + 1
                
                # Film qo'shish (quality va language qo'shildi)
                cursor = await db.execute('''
                    INSERT INTO movies (file_id, caption, genre, quality, order_number, is_active, status, language)
                    VALUES (?, ?, ?, ?, ?, 1, 'approved', ?)
                ''', (file_id, caption, genre, quality, order_number, language))
                movie_id = cursor.lastrowid
                
                # Kod qo'yish (10 dan keyin order_number kod sifatida)
                if order_number > 10:
                    code = str(order_number)
                else:
                    # 1-10 orasida bo'lsa, kod qo'yish (agar bo'sh bo'lsa)
                    cursor = await db.execute('SELECT COUNT(*) FROM movie_codes WHERE code = ?', (str(order_number),))
                    exists = (await cursor.fetchone())[0]
                    if exists == 0:
                        code = str(order_number)
                    else:
                        # Agar kod allaqachon mavjud bo'lsa, order_number kod sifatida
                        code = str(order_number)
                
                try:
                    await db.execute('INSERT INTO movie_codes (movie_id, code) VALUES (?, ?)', (movie_id, code))
                except Exception:
                    # Kod allaqachon mavjud bo'lsa, order_number kod sifatida
                    code = str(order_number)
                    await db.execute('INSERT OR IGNORE INTO movie_codes (movie_id, code) VALUES (?, ?)', (movie_id, code))
                
                await db.commit()
                logger.info(f"Film qo'shildi: caption={caption}, order_number={order_number}, code={code}")
                return True
        except Exception as e:
            logger.error(f"add_movie error: {e}", exc_info=True)
            return False
    
    async def get_movies_by_name(self, movie_name: str, limit: int = 20) -> List[Dict]:
        """Nomlari bir xil bo'lgan barcha kinolarni olish (qismlar)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM movies 
                    WHERE caption LIKE ? 
                    AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY order_number ASC
                    LIMIT ?
                ''', (f'%{movie_name}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_movies_by_name error: {e}")
            return []
    
    async def get_movie(self, movie_id: int) -> Optional[Dict]:
        """Kino ma'lumotlari"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM movies 
                    WHERE id = ? AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                ''', (movie_id,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_movie error: {e}")
            return None
    
    async def get_premium_movies(self, limit: int = 50) -> List[Dict]:
        """Premium HD/4K kinolarni olish (1080p, 4K)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM movies 
                    WHERE (quality LIKE '%1080%' OR quality LIKE '%4K%' OR quality LIKE '%2160%' OR quality LIKE '%2160p%')
                    AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY upload_date DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_premium_movies error: {e}")
            return []
    
    async def search_movies(self, query: str, limit: int = 20) -> List[Dict]:
        """Kinolarni qidirish (optimallashtirilgan)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM movies 
                    WHERE (caption LIKE ? OR genre LIKE ?) 
                    AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY order_number ASC
                    LIMIT ?
                ''', (f'%{query}%', f'%{query}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"search_movies error: {e}")
            return []
    
    async def get_top_movies(self, limit: int = 10, sort_by: str = "views") -> List[Dict]:
        """Top filmlar (eng ko'p izlangan yoki yuklangan) - OPTIMALLASHTIRILGAN"""
        try:
            async with self.connect() as db:
                # views va downloads ustunlarini tekshirish
                try:
                    if sort_by == "views":
                        cursor = await db.execute('''
                            SELECT * FROM movies 
                            WHERE is_active = 1 
                            AND (status = "approved" OR status IS NULL)
                            ORDER BY COALESCE(views, 0) DESC, order_number ASC
                            LIMIT ?
                        ''', (limit,))
                    else:  # downloads
                        cursor = await db.execute('''
                            SELECT * FROM movies 
                            WHERE is_active = 1 
                            AND (status = "approved" OR status IS NULL)
                            ORDER BY COALESCE(downloads, 0) DESC, order_number ASC
                            LIMIT ?
                        ''', (limit,))
                except Exception:
                    # Agar views/downloads ustunlari yo'q bo'lsa, oddiy tartiblash
                    cursor = await db.execute('''
                        SELECT * FROM movies 
                        WHERE is_active = 1 
                        AND (status = "approved" OR status IS NULL)
                        ORDER BY order_number ASC
                        LIMIT ?
                    ''', (limit,))
                
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_top_movies error: {e}")
            return []
    
    async def get_random_movies(self, limit: int = 5) -> List[Dict]:
        """Tasodifiy filmlar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM movies 
                    WHERE is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY RANDOM()
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_random_movies error: {e}")
            return []
    
    async def increment_movie_views(self, movie_id: int):
        """Film ko'rishlar sonini oshirish"""
        try:
            async with self.connect() as db:
                # views ustunini tekshirish va qo'shish (agar yo'q bo'lsa)
                try:
                    await db.execute('ALTER TABLE movies ADD COLUMN views INTEGER DEFAULT 0')
                    await db.commit()
                except Exception:
                    pass  # Ustun allaqachon mavjud
                
                await db.execute('''
                    UPDATE movies 
                    SET views = COALESCE(views, 0) + 1
                    WHERE id = ?
                ''', (movie_id,))
        except Exception as e:
            logger.error(f"increment_movie_views error: {e}")
    
    async def get_movie_by_code(self, code: str) -> Optional[Dict]:
        """Kino kod bo'yicha olish (agar mavjud bo'lsa)"""
        try:
            # Agar movie_codes jadvali mavjud bo'lsa
            async with self.connect() as db:
                try:
                    cursor = await db.execute('''
                        SELECT m.* FROM movies m
                        JOIN movie_codes mc ON m.id = mc.movie_id
                        WHERE mc.code = ? AND m.is_active = 1
                    ''', (code.upper(),))
                    row = await cursor.fetchone()
                    if row:
                        return dict(row)
                except Exception:
                    pass  # movie_codes jadvali mavjud emas
            return None
        except Exception as e:
            logger.error(f"get_movie_by_code error: {e}")
            return None
    
    # -------------------------------------------------------------------------
    # COURSE METHODS
    # -------------------------------------------------------------------------
    
    async def add_course(self, title: str, description: str, full_description: str = "",
                        instructor: str = "", file_id: str = "", category: str = "Boshqa",
                        subcategory: str = None, duration: str = "", price: int = 19990,
                        discount_price: int = None, requirements: str = None,
                        what_you_get: str = None, tags: List[str] = None,
                        lessons_count: int = 1):
        """Kurs qo'shish (tartib raqami bilan va to'liq ma'lumotlar)"""
        try:
            async with self.connect() as db:
                # Tartib raqamini olish (eng katta + 1)
                cursor = await db.execute("SELECT MAX(order_number) FROM courses WHERE is_active = 1")
                max_order = (await cursor.fetchone())[0]
                new_order_number = (max_order if max_order is not None else 0) + 1
                
                cursor = await db.execute('''
                    INSERT INTO courses (title, description, full_description, instructor, file_id,
                                       category, subcategory, duration, price, discount_price,
                                       requirements, what_you_get, tags, lessons_count, order_number,
                                       is_active, status)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1, 'approved')
                ''', (title, description, full_description, instructor, file_id,
                      category, subcategory, duration, price, discount_price,
                      requirements, what_you_get, json.dumps(tags or []), lessons_count, new_order_number))
                await db.commit()
                course_id = cursor.lastrowid
                logger.info(f"Kurs qo'shildi: title={title}, order_number={new_order_number}, id={course_id}")
                return course_id
        except Exception as e:
            logger.error(f"add_course error: {e}", exc_info=True)
            return None
    
    async def get_course(self, course_id: int) -> Optional[Dict]:
        """Kurs ma'lumotlari"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM courses 
                    WHERE id = ? AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                ''', (course_id,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_course error: {e}")
            return None
    
    async def search_courses(self, query: str, limit: int = 20) -> List[Dict]:
        """Kurslarni qidirish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM courses 
                    WHERE (title LIKE ? OR description LIKE ?) 
                    AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    LIMIT ?
                ''', (f'%{query}%', f'%{query}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"search_courses error: {e}")
            return []
    
    async def get_random_courses(self, limit: int = 5) -> List[Dict]:
        """Tasodifiy kurslar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM courses 
                    WHERE is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY RANDOM()
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                courses = []
                for row in rows:
                    course = dict(row)
                    if 'tags' in course:
                        try:
                            course['tags'] = json.loads(course.get('tags', '[]')) if isinstance(course.get('tags'), str) else course.get('tags', [])
                        except Exception:
                            course['tags'] = []
                    courses.append(course)
                return courses
        except Exception as e:
            logger.error(f"get_random_courses error: {e}")
            return []
    
    async def get_top_courses(self, limit: int = 10, sort_by: str = "students") -> List[Dict]:
        """Top kurslarni olish (eng ko'p izlangan va eng ko'p sotib olingan)"""
        try:
            async with self.connect() as db:
                if sort_by == "students":
                    order_by = "students_count DESC, rating DESC"
                elif sort_by == "purchases":
                    order_by = "(SELECT COUNT(*) FROM user_courses WHERE course_id = c.id) DESC, rating DESC"
                else:
                    order_by = "rating DESC, students_count DESC"
                
                cursor = await db.execute(f'''
                    SELECT c.*, 
                           (SELECT COUNT(*) FROM user_courses WHERE course_id = c.id) as purchase_count
                    FROM courses c
                    WHERE c.is_active = 1 AND (c.status = "approved" OR c.status IS NULL)
                    ORDER BY {order_by}
                    LIMIT ?
                ''', (limit,))
                
                rows = await cursor.fetchall()
                courses = []
                for row in rows:
                    course = dict(row)
                    if 'tags' in course:
                        try:
                            course['tags'] = json.loads(course.get('tags', '[]')) if isinstance(course.get('tags'), str) else course.get('tags', [])
                        except Exception:
                            course['tags'] = []
                    courses.append(course)
                return courses
        except Exception as e:
            logger.error(f"get_top_courses error: {e}")
            return []
    
    async def get_cheap_courses(self, max_price: int = 15000, limit: int = 10) -> List[Dict]:
        """Arzon kurslarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM courses 
                    WHERE (price <= ? OR discount_price <= ?) 
                      AND is_active = 1 AND (status = "approved" OR status IS NULL)
                    ORDER BY COALESCE(discount_price, price) ASC, rating DESC
                    LIMIT ?
                ''', (max_price, max_price, limit))
                
                rows = await cursor.fetchall()
                courses = []
                for row in rows:
                    course = dict(row)
                    if 'tags' in course:
                        try:
                            course['tags'] = json.loads(course.get('tags', '[]')) if isinstance(course.get('tags'), str) else course.get('tags', [])
                        except Exception:
                            course['tags'] = []
                    courses.append(course)
                return courses
        except Exception as e:
            logger.error(f"get_cheap_courses error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # PODCAST METHODS
    # -------------------------------------------------------------------------
    
    async def search_podcasts(self, query: str, limit: int = 20) -> List[Dict]:
        """Podcastlarni qidirish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM podcasts 
                    WHERE (title LIKE ? OR description LIKE ? OR host LIKE ?) 
                    AND is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY downloads DESC
                    LIMIT ?
                ''', (f'%{query}%', f'%{query}%', f'%{query}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"search_podcasts error: {e}")
            return []
    
    async def get_podcast(self, podcast_id: int) -> Dict:
        """Podcast olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM podcasts 
                    WHERE id = ? AND is_active = 1
                ''', (podcast_id,))
                row = await cursor.fetchone()
                return dict(row) if row else {}
        except Exception as e:
            logger.error(f"get_podcast error: {e}")
            return {}
    
    async def get_random_podcasts(self, limit: int = 5, language: str = None) -> List[Dict]:
        """Tasodifiy podcastlar (til bo'yicha filtrlash)"""
        try:
            async with self.connect() as db:
                if language:
                    cursor = await db.execute('''
                        SELECT * FROM podcasts 
                        WHERE is_active = 1 
                        AND (status = "approved" OR status IS NULL)
                        AND language = ?
                        ORDER BY RANDOM()
                        LIMIT ?
                    ''', (language, limit))
                else:
                    cursor = await db.execute('''
                        SELECT * FROM podcasts 
                        WHERE is_active = 1 
                        AND (status = "approved" OR status IS NULL)
                        ORDER BY RANDOM()
                        LIMIT ?
                    ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_random_podcasts error: {e}")
            return []
    
    async def get_podcasts_by_category(self, category: str, limit: int = 20) -> List[Dict]:
        """Kategoriya bo'yicha podcastlar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM podcasts 
                    WHERE is_active = 1 
                    AND category = ?
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY downloads DESC
                    LIMIT ?
                ''', (category, limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_podcasts_by_category error: {e}")
            return []
    
    async def get_video_podcasts(self, limit: int = 20) -> List[Dict]:
        """Video podcastlar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM podcasts 
                    WHERE is_active = 1 
                    AND content_type = 'video'
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY downloads DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_video_podcasts error: {e}")
            return []
    
    async def get_motivational_podcasts(self, limit: int = 20) -> List[Dict]:
        """Motivatsion podcastlar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM podcasts 
                    WHERE is_active = 1 
                    AND (category LIKE '%Motivatsion%' OR category LIKE '%Motivational%' OR title LIKE '%motivatsion%' OR title LIKE '%motivational%')
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY downloads DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_motivational_podcasts error: {e}")
            return []
    
    async def add_podcast(self, title: str, description: str, file_id: str, category: str = "Boshqa", host: str = "", language: str = "uz", content_type: str = "audio", video_file_id: str = None, is_premium: int = 0, created_by: int = None):
        """Podcast qo'shish"""
        try:
            async with self.connect() as db:
                # Admin tomonidan qo'shilgan podcastlar darhol approved bo'ladi
                status = 'approved' if created_by else 'pending'
                await db.execute('''
                    INSERT INTO podcasts (title, description, file_id, video_file_id, content_type, category, host, language, is_premium, created_by, status, is_active)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1)
                ''', (title, description, file_id, video_file_id, content_type, category, host, language, is_premium, created_by, status))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"add_podcast error: {e}")
            return False
    
    async def get_top_podcasts(self, limit: int = 10) -> List[Dict]:
        """Top podcastlar"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM podcasts 
                    WHERE is_active = 1 
                    AND (status = "approved" OR status IS NULL)
                    ORDER BY downloads DESC, rating DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_top_podcasts error: {e}")
            return []
    
    async def get_courses_by_category(self, category: str, limit: int = 20) -> List[Dict]:
        """Kategoriya bo'yicha kurslarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM courses 
                    WHERE category = ? AND is_active = 1 AND (status = "approved" OR status IS NULL)
                    ORDER BY students_count DESC, rating DESC
                    LIMIT ?
                ''', (category, limit))
                
                rows = await cursor.fetchall()
                courses = []
                for row in rows:
                    course = dict(row)
                    if 'tags' in course:
                        try:
                            course['tags'] = json.loads(course.get('tags', '[]')) if isinstance(course.get('tags'), str) else course.get('tags', [])
                        except Exception:
                            course['tags'] = []
                    courses.append(course)
                
                return courses
        except Exception as e:
            logger.error(f"get_courses_by_category error: {e}")
            return []
    
    async def get_course_demo_video(self, course_id: int) -> Optional[str]:
        """Kurs demo videosini olish (birinchi video)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT video_id FROM course_videos 
                    WHERE course_id = ? AND is_demo = 1
                    ORDER BY video_order ASC
                    LIMIT 1
                ''', (course_id,))
                row = await cursor.fetchone()
                return row[0] if row else None
        except Exception as e:
            logger.error(f"get_course_demo_video error: {e}")
            return None
    
    async def purchase_course(self, user_id: int, course_id: int, price_paid: int) -> bool:
        """Kurs sotib olish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT OR IGNORE INTO user_courses (user_id, course_id, price_paid)
                    VALUES (?, ?, ?)
                ''', (user_id, course_id, price_paid))
                
                await db.execute('UPDATE courses SET students_count = students_count + 1 WHERE id = ?', (course_id,))
                await db.commit()
                
                return True
        except Exception as e:
            logger.error(f"purchase_course error: {e}")
            return False
    
    async def get_user_courses(self, user_id: int) -> List[Dict]:
        """Foydalanuvchi sotib olgan kurslarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT c.*, uc.purchase_date, uc.progress, uc.completed, uc.last_accessed
                    FROM user_courses uc
                    JOIN courses c ON uc.course_id = c.id
                    WHERE uc.user_id = ? AND c.is_active = 1
                    ORDER BY uc.purchase_date DESC
                ''', (user_id,))
                rows = await cursor.fetchall()
                courses = []
                for row in rows:
                    course = dict(row)
                    if 'tags' in course:
                        try:
                            course['tags'] = json.loads(course.get('tags', '[]')) if isinstance(course.get('tags'), str) else course.get('tags', [])
                        except Exception:
                            course['tags'] = []
                    courses.append(course)
                return courses
        except Exception as e:
            logger.error(f"get_user_courses error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # GAMIFICATION BONUS METHODS
    # -------------------------------------------------------------------------
    
    async def check_and_update_streak(self, user_id: int) -> Dict:
        """Kunlik streak ni tekshirish va yangilash"""
        try:
            async with self.connect() as db:
                today = datetime.now().strftime('%Y-%m-%d')
                yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
                
                cursor = await db.execute('''
                    SELECT streak_count, streak_last_date, last_bonus_date
                    FROM users WHERE user_id = ?
                ''', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return {"streak": 0, "bonus": 0, "new_streak": False}
                
                current_streak = row[0] or 0
                last_streak_date = row[1]
                last_bonus_date = row[2]
                
                result = {"streak": current_streak, "bonus": 0, "new_streak": False}
                
                # Agar bugun allaqachon bonus olgan bo'lsa
                if last_bonus_date == today:
                    return result
                
                # Streak yangilash
                if last_streak_date == yesterday:
                    # Ketma-ket kun - streak davom etadi
                    new_streak = current_streak + 1
                elif last_streak_date == today:
                    # Bugun allaqachon yangilangan
                    new_streak = current_streak
                else:
                    # Streak uzildi - qaytadan boshlash
                    new_streak = 1
                
                # Streak bonus hisoblash (har 7 kun uchun ko'proq)
                base_bonus = 10  # Kunlik bonus
                streak_multiplier = min(new_streak // 7 + 1, 5)  # Max 5x
                bonus_xp = base_bonus * streak_multiplier
                
                # Maxsus streak bonuslari
                if new_streak == 7:
                    bonus_xp += 50  # Haftalik bonus
                elif new_streak == 30:
                    bonus_xp += 200  # Oylik bonus
                elif new_streak == 100:
                    bonus_xp += 500  # 100 kunlik bonus
                
                # Bazani yangilash
                await db.execute('''
                    UPDATE users 
                    SET streak_count = ?, 
                        streak_last_date = ?,
                        last_bonus_date = ?,
                        xp = xp + ?
                    WHERE user_id = ?
                ''', (new_streak, today, today, bonus_xp, user_id))
                await db.commit()
                
                result = {
                    "streak": new_streak,
                    "bonus": bonus_xp,
                    "new_streak": True,
                    "milestone": new_streak in [7, 30, 100]
                }
                
                return result
        except Exception as e:
            logger.error(f"check_and_update_streak error: {e}")
            return {"streak": 0, "bonus": 0, "new_streak": False}
    
    async def add_referral_bonus(self, referrer_id: int, new_user_id: int) -> int:
        """Referral bonus qo'shish"""
        try:
            async with self.connect() as db:
                # Referral bonus - 75 XP
                bonus_xp = 75
                
                await db.execute('''
                    UPDATE users 
                    SET xp = xp + ?,
                        referral_count = referral_count + 1
                    WHERE user_id = ?
                ''', (bonus_xp, referrer_id))
                
                # Yangi foydalanuvchiga ham bonus
                await db.execute('''
                    UPDATE users 
                    SET xp = xp + 25,
                        referral_id = ?
                    WHERE user_id = ?
                ''', (referrer_id, new_user_id))
                
                await db.commit()
                
                return bonus_xp
        except Exception as e:
            logger.error(f"add_referral_bonus error: {e}")
            return 0
    
    async def add_quiz_completion_bonus(self, user_id: int, score_percent: int, question_count: int) -> int:
        """Quiz tugatish bonusi"""
        try:
            async with self.connect() as db:
                # Asosiy bonus
                base_xp = question_count * 2  # Har bir savol uchun 2 XP
                
                # Natija bo'yicha bonus
                if score_percent >= 90:
                    bonus_multiplier = 2.0  # A'lo natija
                elif score_percent >= 70:
                    bonus_multiplier = 1.5  # Yaxshi natija
                elif score_percent >= 50:
                    bonus_multiplier = 1.0  # O'rtacha
                else:
                    bonus_multiplier = 0.5  # Past natija
                
                total_xp = int(base_xp * bonus_multiplier)
                
                await db.execute('''
                    UPDATE users SET xp = xp + ? WHERE user_id = ?
                ''', (total_xp, user_id))
                await db.commit()
                
                return total_xp
        except Exception as e:
            logger.error(f"add_quiz_completion_bonus error: {e}")
            return 0
    
    async def add_download_bonus(self, user_id: int, content_type: str) -> int:
        """Yuklash bonusi (kitob, kino, kurs)"""
        try:
            async with self.connect() as db:
                # Kontent turiga qarab bonus
                bonus_map = {
                    "book": 5,
                    "movie": 3,
                    "course": 10,
                    "podcast": 2
                }
                bonus_xp = bonus_map.get(content_type, 2)
                
                await db.execute('''
                    UPDATE users SET xp = xp + ? WHERE user_id = ?
                ''', (bonus_xp, user_id))
                await db.commit()
                
                return bonus_xp
        except Exception as e:
            logger.error(f"add_download_bonus error: {e}")
            return 0
    
    # =========================================================================
    # GOLD TIZIMI - XP evaziga Gold sotib olish, Gold bilan Premium olish
    # =========================================================================
    
    async def buy_gold_with_xp(self, user_id: int, gold_amount: int) -> Dict:
        """XP evaziga Gold sotib olish (200 XP = 1 Gold)"""
        try:
            xp_cost = gold_amount * 200  # 200 XP = 1 Gold (qiyinroq)
            
            async with self.connect() as db:
                cursor = await db.execute('SELECT xp, gold FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return {"success": False, "error": "Foydalanuvchi topilmadi"}
                
                current_xp = row[0] or 0
                current_gold = row[1] or 0
                
                if current_xp < xp_cost:
                    return {"success": False, "error": f"XP yetarli emas! Kerak: {xp_cost:,}, Sizda: {current_xp:,}"}
                
                # XP ayirish va Gold qo'shish
                await db.execute('''
                    UPDATE users SET xp = xp - ?, gold = gold + ? WHERE user_id = ?
                ''', (xp_cost, gold_amount, user_id))
                
                # Transaction log
                await db.execute('''
                    INSERT INTO gold_transactions (user_id, amount, transaction_type, description)
                    VALUES (?, ?, 'buy', ?)
                ''', (user_id, gold_amount, f"XP evaziga sotib olindi ({xp_cost} XP)"))
                
                await db.commit()
                
                return {
                    "success": True,
                    "gold_bought": gold_amount,
                    "xp_spent": xp_cost,
                    "new_gold": current_gold + gold_amount,
                    "new_xp": current_xp - xp_cost
                }
        except Exception as e:
            logger.error(f"buy_gold_with_xp error: {e}")
            return {"success": False, "error": str(e)}
    
    async def buy_premium_with_gold(self, user_id: int, days: int) -> Dict:
        """Gold evaziga Premium sotib olish"""
        try:
            # Gold narxlari (1 kun = 50 Gold - qiyinroq)
            gold_prices = {
                1: 50,     # 1 kun = 50 Gold
                3: 120,    # 3 kun = 120 Gold
                7: 250,    # 7 kun = 250 Gold
                15: 450,   # 15 kun = 450 Gold
                30: 800,   # 30 kun = 800 Gold
            }
            
            gold_cost = gold_prices.get(days)
            if not gold_cost:
                return {"success": False, "error": "Noto'g'ri kun soni"}
            
            async with self.connect() as db:
                cursor = await db.execute('SELECT gold FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return {"success": False, "error": "Foydalanuvchi topilmadi"}
                
                current_gold = row[0] or 0
                
                if current_gold < gold_cost:
                    return {"success": False, "error": f"Gold yetarli emas! Kerak: {gold_cost}, Sizda: {current_gold}"}
                
                # Gold ayirish
                await db.execute('UPDATE users SET gold = gold - ? WHERE user_id = ?', (gold_cost, user_id))
                
                # Transaction log
                await db.execute('''
                    INSERT INTO gold_transactions (user_id, amount, transaction_type, description)
                    VALUES (?, ?, 'spend', ?)
                ''', (user_id, -gold_cost, f"Premium {days} kun sotib olindi"))
                
                await db.commit()
            
            # Premium aktivlashtirish
            await self.activate_premium(user_id, days, 2)  # Exclusive
            
            return {
                "success": True,
                "days": days,
                "gold_spent": gold_cost,
                "new_gold": current_gold - gold_cost
            }
        except Exception as e:
            logger.error(f"buy_premium_with_gold error: {e}")
            return {"success": False, "error": str(e)}
    
    async def add_gold(self, user_id: int, amount: int, reason: str = "bonus") -> bool:
        """Foydalanuvchiga Gold qo'shish"""
        try:
            async with self.connect() as db:
                await db.execute('UPDATE users SET gold = gold + ? WHERE user_id = ?', (amount, user_id))
                await db.execute('''
                    INSERT INTO gold_transactions (user_id, amount, transaction_type, description)
                    VALUES (?, ?, 'earn', ?)
                ''', (user_id, amount, reason))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"add_gold error: {e}")
            return False
    
    async def add_xp_with_leaderboard(self, user_id: int, amount: int) -> bool:
        """XP qo'shish va leaderboard uchun weekly/monthly XP yangilash"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE users SET 
                        xp = xp + ?,
                        weekly_xp = weekly_xp + ?,
                        monthly_xp = monthly_xp + ?,
                        total_xp = total_xp + ?
                    WHERE user_id = ?
                ''', (amount, amount, amount, amount, user_id))
                await db.commit()
                
                # Level yangilash
                await self.update_user_level(user_id)
                
                # XP achievements tekshirish
                cursor = await db.execute('SELECT xp FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                if row:
                    total_xp = row[0] or 0
                    if total_xp >= 1000:
                        await self.check_and_award_achievement(user_id, 'xp_1000')
                    if total_xp >= 10000:
                        await self.check_and_award_achievement(user_id, 'xp_10000')
                    if total_xp >= 100000:
                        await self.check_and_award_achievement(user_id, 'xp_100000')
                
                return True
        except Exception as e:
            logger.error(f"add_xp_with_leaderboard error: {e}")
            return False
    
    # =========================================================================
    # LEADERBOARD TIZIMI - Haftalik/Oylik reyting
    # =========================================================================
    
    async def get_leaderboard(self, period: str = "weekly", limit: int = 10) -> List[Dict]:
        """Leaderboard olish (weekly/monthly/all_time)"""
        try:
            async with self.connect() as db:
                if period == "weekly":
                    cursor = await db.execute('''
                        SELECT user_id, full_name, username, weekly_xp as xp, level, gold
                        FROM users 
                        WHERE is_banned = 0 AND weekly_xp > 0
                        ORDER BY weekly_xp DESC
                        LIMIT ?
                    ''', (limit,))
                elif period == "monthly":
                    cursor = await db.execute('''
                        SELECT user_id, full_name, username, monthly_xp as xp, level, gold
                        FROM users 
                        WHERE is_banned = 0 AND monthly_xp > 0
                        ORDER BY monthly_xp DESC
                        LIMIT ?
                    ''', (limit,))
                else:  # all_time
                    cursor = await db.execute('''
                        SELECT user_id, full_name, username, xp, level, gold
                        FROM users 
                        WHERE is_banned = 0 AND xp > 0
                        ORDER BY xp DESC
                        LIMIT ?
                    ''', (limit,))
                
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_leaderboard error: {e}")
            return []
    
    async def get_user_rank(self, user_id: int, period: str = "weekly") -> int:
        """Foydalanuvchining reytingdagi o'rnini olish"""
        try:
            async with self.connect() as db:
                if period == "weekly":
                    xp_field = "weekly_xp"
                elif period == "monthly":
                    xp_field = "monthly_xp"
                else:
                    xp_field = "xp"
                
                cursor = await db.execute(f'''
                    SELECT COUNT(*) + 1 FROM users 
                    WHERE {xp_field} > (SELECT {xp_field} FROM users WHERE user_id = ?)
                    AND is_banned = 0
                ''', (user_id,))
                row = await cursor.fetchone()
                return row[0] if row else 0
        except Exception as e:
            logger.error(f"get_user_rank error: {e}")
            return 0
    
    async def reset_weekly_xp(self) -> int:
        """Haftalik XP ni reset qilish va mukofotlar berish"""
        try:
            async with self.connect() as db:
                # Top 10 ga mukofot
                cursor = await db.execute('''
                    SELECT user_id, weekly_xp, full_name FROM users 
                    WHERE is_banned = 0 AND weekly_xp > 0
                    ORDER BY weekly_xp DESC LIMIT 10
                ''')
                top_users = await cursor.fetchall()
                
                rewards = {1: 500, 2: 300, 3: 200, 4: 100, 5: 80, 6: 60, 7: 50, 8: 40, 9: 30, 10: 20}
                gold_rewards = {1: 50, 2: 30, 3: 20, 4: 10, 5: 8, 6: 6, 7: 5, 8: 4, 9: 3, 10: 2}
                
                rewarded = 0
                for i, user in enumerate(top_users, 1):
                    user_id = user[0]
                    xp_reward = rewards.get(i, 0)
                    gold_reward = gold_rewards.get(i, 0)
                    
                    if xp_reward > 0:
                        await db.execute('''
                            UPDATE users SET xp = xp + ?, gold = gold + ? WHERE user_id = ?
                        ''', (xp_reward, gold_reward, user_id))
                        
                        # Tarixga saqlash
                        await db.execute('''
                            INSERT INTO leaderboard_history 
                            (user_id, period_type, period_start, period_end, xp_earned, rank, reward_xp, reward_gold)
                            VALUES (?, 'weekly', date('now', '-7 days'), date('now'), ?, ?, ?, ?)
                        ''', (user_id, user[1], i, xp_reward, gold_reward))
                        rewarded += 1
                
                # Barcha foydalanuvchilarning weekly_xp ni 0 ga tushirish
                await db.execute("UPDATE users SET weekly_xp = 0, last_weekly_reset = date('now')")
                await db.commit()
                
                return rewarded
        except Exception as e:
            logger.error(f"reset_weekly_xp error: {e}")
            return 0
    
    async def reset_monthly_xp(self) -> int:
        """Oylik XP ni reset qilish va mukofotlar berish"""
        try:
            async with self.connect() as db:
                # Top 10 ga mukofot
                cursor = await db.execute('''
                    SELECT user_id, monthly_xp, full_name FROM users 
                    WHERE is_banned = 0 AND monthly_xp > 0
                    ORDER BY monthly_xp DESC LIMIT 10
                ''')
                top_users = await cursor.fetchall()
                
                rewards = {1: 2000, 2: 1500, 3: 1000, 4: 500, 5: 400, 6: 300, 7: 200, 8: 150, 9: 100, 10: 50}
                gold_rewards = {1: 200, 2: 150, 3: 100, 4: 50, 5: 40, 6: 30, 7: 20, 8: 15, 9: 10, 10: 5}
                
                rewarded = 0
                for i, user in enumerate(top_users, 1):
                    user_id = user[0]
                    xp_reward = rewards.get(i, 0)
                    gold_reward = gold_rewards.get(i, 0)
                    
                    if xp_reward > 0:
                        await db.execute('''
                            UPDATE users SET xp = xp + ?, gold = gold + ? WHERE user_id = ?
                        ''', (xp_reward, gold_reward, user_id))
                        
                        await db.execute('''
                            INSERT INTO leaderboard_history 
                            (user_id, period_type, period_start, period_end, xp_earned, rank, reward_xp, reward_gold)
                            VALUES (?, 'monthly', date('now', '-30 days'), date('now'), ?, ?, ?, ?)
                        ''', (user_id, user[1], i, xp_reward, gold_reward))
                        rewarded += 1
                
                await db.execute("UPDATE users SET monthly_xp = 0, last_monthly_reset = date('now')")
                await db.commit()
                
                return rewarded
        except Exception as e:
            logger.error(f"reset_monthly_xp error: {e}")
            return 0
    
    # =========================================================================
    # ACHIEVEMENT/BADGE TIZIMI
    # =========================================================================
    
    ACHIEVEMENTS = {
        # Streak achievements
        'streak_7': {'name': 'ðŸ”¥ Haftalik Streak', 'desc': '7 kun ketma-ket kirish', 'xp': 100, 'gold': 10},
        'streak_30': {'name': 'ðŸ”¥ Oylik Streak', 'desc': '30 kun ketma-ket kirish', 'xp': 500, 'gold': 50},
        'streak_100': {'name': 'ðŸ”¥ 100 Kunlik Streak', 'desc': '100 kun ketma-ket kirish', 'xp': 2000, 'gold': 200},
        
        # Quiz achievements
        'quiz_master_10': {'name': 'ðŸŽ¯ Quiz Starter', 'desc': '10 ta test yechish', 'xp': 50, 'gold': 5},
        'quiz_master_50': {'name': 'ðŸŽ¯ Quiz Pro', 'desc': '50 ta test yechish', 'xp': 200, 'gold': 20},
        'quiz_master_100': {'name': 'ðŸŽ¯ Quiz Master', 'desc': '100 ta test yechish', 'xp': 500, 'gold': 50},
        'perfect_score': {'name': 'ðŸ’¯ Perfect Score', 'desc': 'Testda 100% natija', 'xp': 100, 'gold': 10},
        
        # Book achievements
        'bookworm_10': {'name': 'ðŸ“š Kitobxon', 'desc': '10 ta kitob yuklab olish', 'xp': 50, 'gold': 5},
        'bookworm_50': {'name': 'ðŸ“š Kitob Ishqibozi', 'desc': '50 ta kitob yuklab olish', 'xp': 200, 'gold': 20},
        'bookworm_100': {'name': 'ðŸ“š Kutubxonachi', 'desc': '100 ta kitob yuklab olish', 'xp': 500, 'gold': 50},
        
        # Movie achievements
        'movie_fan_10': {'name': 'ðŸŽ¬ Kino Ishqibozi', 'desc': '10 ta kino ko\'rish', 'xp': 50, 'gold': 5},
        'movie_fan_50': {'name': 'ðŸŽ¬ Kinoman', 'desc': '50 ta kino ko\'rish', 'xp': 200, 'gold': 20},
        
        # Referral achievements
        'first_referral': {'name': 'ðŸ‘¥ Birinchi Do\'st', 'desc': 'Birinchi do\'stingizni taklif qiling', 'xp': 100, 'gold': 10},
        'referral_5': {'name': 'ðŸ‘¥ Taklif Ustasi', 'desc': '5 ta do\'stingizni taklif qiling', 'xp': 300, 'gold': 30},
        'referral_10': {'name': 'ðŸ‘¥ Referral Pro', 'desc': '10 ta do\'stingizni taklif qiling', 'xp': 500, 'gold': 50},
        
        # XP achievements
        'xp_1000': {'name': 'â­ 1K XP', 'desc': '1,000 XP to\'plash', 'xp': 100, 'gold': 10},
        'xp_10000': {'name': 'â­ 10K XP', 'desc': '10,000 XP to\'plash', 'xp': 500, 'gold': 50},
        'xp_100000': {'name': 'â­ 100K XP', 'desc': '100,000 XP to\'plash', 'xp': 2000, 'gold': 200},
        
        # Gold achievements
        'gold_100': {'name': 'ðŸª™ 100 Gold', 'desc': '100 Gold to\'plash', 'xp': 200, 'gold': 20},
        'gold_500': {'name': 'ðŸª™ 500 Gold', 'desc': '500 Gold to\'plash', 'xp': 500, 'gold': 50},
        
        # Level achievements
        'level_5': {'name': 'ðŸ“ˆ Level 5', 'desc': '5-darajaga yetish', 'xp': 100, 'gold': 10},
        'level_10': {'name': 'ðŸ“ˆ Level 10', 'desc': '10-darajaga yetish', 'xp': 300, 'gold': 30},
        'level_25': {'name': 'ðŸ“ˆ Level 25', 'desc': '25-darajaga yetish', 'xp': 1000, 'gold': 100},
        
        # Daily challenge achievements
        'daily_7': {'name': 'ðŸ“… Haftalik Challenge', 'desc': '7 ta kunlik challenge bajarish', 'xp': 100, 'gold': 10},
        'daily_30': {'name': 'ðŸ“… Oylik Challenge', 'desc': '30 ta kunlik challenge bajarish', 'xp': 500, 'gold': 50},
        
        # Course achievements
        'course_complete': {'name': 'ðŸŽ“ Kurs Bitiruvchi', 'desc': 'Birinchi kursni tugatish', 'xp': 200, 'gold': 20},
        'course_5': {'name': 'ðŸŽ“ 5 Kurs', 'desc': '5 ta kursni tugatish', 'xp': 500, 'gold': 50},
        
        # Leaderboard achievements
        'top_10_weekly': {'name': 'ðŸ† Top 10 Haftalik', 'desc': 'Haftalik reytingda Top 10', 'xp': 200, 'gold': 20},
        'top_3_weekly': {'name': 'ðŸ¥‡ Top 3 Haftalik', 'desc': 'Haftalik reytingda Top 3', 'xp': 500, 'gold': 50},
        'top_1_weekly': {'name': 'ðŸ‘‘ Hafta Chempioni', 'desc': 'Haftalik reytingda 1-o\'rin', 'xp': 1000, 'gold': 100},
    }
    
    async def check_and_award_achievement(self, user_id: int, achievement_id: str) -> Dict:
        """Achievement tekshirish va berish"""
        try:
            if achievement_id not in self.ACHIEVEMENTS:
                return {"awarded": False, "error": "Achievement topilmadi"}
            
            achievement = self.ACHIEVEMENTS[achievement_id]
            
            async with self.connect() as db:
                # Allaqachon olinganmi tekshirish
                cursor = await db.execute('''
                    SELECT id FROM user_achievements WHERE user_id = ? AND achievement_id = ?
                ''', (user_id, achievement_id))
                
                if await cursor.fetchone():
                    return {"awarded": False, "already_earned": True}
                
                # Achievement berish
                await db.execute('''
                    INSERT INTO user_achievements (user_id, achievement_id, achievement_name, xp_reward, gold_reward)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, achievement_id, achievement['name'], achievement['xp'], achievement['gold']))
                
                # XP va Gold qo'shish
                await db.execute('''
                    UPDATE users SET xp = xp + ?, gold = gold + ? WHERE user_id = ?
                ''', (achievement['xp'], achievement['gold'], user_id))
                
                await db.commit()
                
                return {
                    "awarded": True,
                    "achievement": achievement,
                    "xp_reward": achievement['xp'],
                    "gold_reward": achievement['gold']
                }
        except Exception as e:
            logger.error(f"check_and_award_achievement error: {e}")
            return {"awarded": False, "error": str(e)}
    
    async def get_user_achievements(self, user_id: int) -> List[Dict]:
        """Foydalanuvchining achievementlarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT achievement_id, achievement_name, earned_at, xp_reward, gold_reward
                    FROM user_achievements WHERE user_id = ?
                    ORDER BY earned_at DESC
                ''', (user_id,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_user_achievements error: {e}")
            return []
    
    # =========================================================================
    # USER LEVEL TIZIMI
    # =========================================================================
    
    LEVEL_THRESHOLDS = {
        1: 0, 2: 100, 3: 300, 4: 600, 5: 1000,
        6: 1500, 7: 2100, 8: 2800, 9: 3600, 10: 4500,
        11: 5500, 12: 6600, 13: 7800, 14: 9100, 15: 10500,
        16: 12000, 17: 13600, 18: 15300, 19: 17100, 20: 19000,
        21: 21000, 22: 23100, 23: 25300, 24: 27600, 25: 30000,
        26: 33000, 27: 36500, 28: 40500, 29: 45000, 30: 50000,
    }
    
    LEVEL_NAMES = {
        1: "ðŸŒ± Yangi boshlovchi", 2: "ðŸŒ¿ Boshlang'ich", 3: "ðŸŒ³ O'rganuvchi",
        4: "ðŸ“– Kitobxon", 5: "ðŸ“š Bilimdon", 6: "ðŸŽ¯ Faol",
        7: "â­ Yulduz", 8: "ðŸŒŸ Yorqin Yulduz", 9: "ðŸ’« Super Yulduz",
        10: "ðŸ”¥ Olovli", 11: "ðŸ”¥ Alanga", 12: "ðŸ”¥ Vulqon",
        13: "ðŸ’Ž Olmos", 14: "ðŸ’Ž Brilliant", 15: "ðŸ’Ž Nodir",
        16: "ðŸ† Chempion", 17: "ðŸ† G'olib", 18: "ðŸ† Qahramon",
        19: "ðŸ‘‘ Shoh", 20: "ðŸ‘‘ Imperator", 21: "ðŸ‘‘ Afsonaviy",
        22: "ðŸŒŒ Kosmik", 23: "ðŸŒŒ Galaktik", 24: "ðŸŒŒ Universal",
        25: "ðŸ”® Sehrgar", 26: "ðŸ”® Arxisehrgar", 27: "ðŸ”® Afsonaviy Sehrgar",
        28: "âš¡ Titan", 29: "âš¡ Olimp", 30: "âš¡ Xudo",
    }
    
    def calculate_level(self, total_xp: int) -> Dict:
        """XP asosida darajani hisoblash"""
        level = 1
        for lvl, threshold in sorted(self.LEVEL_THRESHOLDS.items()):
            if total_xp >= threshold:
                level = lvl
            else:
                break
        
        current_threshold = self.LEVEL_THRESHOLDS.get(level, 0)
        next_threshold = self.LEVEL_THRESHOLDS.get(level + 1, current_threshold + 5000)
        
        progress = total_xp - current_threshold
        needed = next_threshold - current_threshold
        percent = min(100, int((progress / needed) * 100)) if needed > 0 else 100
        
        return {
            "level": level,
            "name": self.LEVEL_NAMES.get(level, f"Level {level}"),
            "current_xp": total_xp,
            "level_xp": progress,
            "next_level_xp": needed,
            "percent": percent,
            "next_level": level + 1 if level < 30 else 30
        }
    
    async def update_user_level(self, user_id: int) -> Dict:
        """Foydalanuvchi darajasini yangilash"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('SELECT xp, level FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return {"level_up": False}
                
                current_xp = row[0] or 0
                old_level = row[1] or 1
                
                level_info = self.calculate_level(current_xp)
                new_level = level_info['level']
                
                if new_level != old_level:
                    await db.execute('UPDATE users SET level = ? WHERE user_id = ?', (new_level, user_id))
                    await db.commit()
                    
                    # Level achievement tekshirish
                    if new_level >= 5:
                        await self.check_and_award_achievement(user_id, 'level_5')
                    if new_level >= 10:
                        await self.check_and_award_achievement(user_id, 'level_10')
                    if new_level >= 25:
                        await self.check_and_award_achievement(user_id, 'level_25')
                    
                    return {
                        "level_up": new_level > old_level,
                        "old_level": old_level,
                        "new_level": new_level,
                        "level_name": level_info['name']
                    }
                
                return {"level_up": False, "level": new_level}
        except Exception as e:
            logger.error(f"update_user_level error: {e}")
            return {"level_up": False}
    
    # =========================================================================
    # 30-DAY DAILY CHALLENGE TIZIMI (ANTI-CHEATING BILAN)
    # =========================================================================
    
    # 30 kunlik challenge kalendari - har kun uchun maxsus vazifalar
    THIRTY_DAY_CHALLENGES = [
        # Hafta 1: Boshlang'ich - Oson vazifalar
        {"day": 1, "type": "download_book", "desc": "1 ta kitob yuklab olish", "target": 1, "xp": 30, "gold": 3, "emoji": "ðŸ“š"},
        {"day": 2, "type": "watch_movie", "desc": "1 ta kino ko'rish", "target": 1, "xp": 30, "gold": 3, "emoji": "ðŸŽ¬"},
        {"day": 3, "type": "quiz", "desc": "1 ta test yechish", "target": 1, "xp": 25, "gold": 2, "emoji": "ðŸ§ "},
        {"day": 4, "type": "download_book", "desc": "2 ta kitob yuklab olish", "target": 2, "xp": 50, "gold": 5, "emoji": "ðŸ“š"},
        {"day": 5, "type": "quiz", "desc": "2 ta test yechish", "target": 2, "xp": 45, "gold": 4, "emoji": "ðŸ§ "},
        {"day": 6, "type": "watch_movie", "desc": "2 ta kino ko'rish", "target": 2, "xp": 50, "gold": 5, "emoji": "ðŸŽ¬"},
        {"day": 7, "type": "combo", "desc": "1 kitob + 1 test", "target": 2, "xp": 75, "gold": 8, "emoji": "ðŸ†", "combo": ["download_book", "quiz"]},
        
        # Hafta 2: O'rta qiyinlik
        {"day": 8, "type": "download_book", "desc": "3 ta kitob yuklab olish", "target": 3, "xp": 70, "gold": 7, "emoji": "ðŸ“š"},
        {"day": 9, "type": "quiz", "desc": "3 ta test yechish", "target": 3, "xp": 65, "gold": 6, "emoji": "ðŸ§ "},
        {"day": 10, "type": "watch_movie", "desc": "3 ta kino ko'rish", "target": 3, "xp": 70, "gold": 7, "emoji": "ðŸŽ¬"},
        {"day": 11, "type": "mining", "desc": "1000 coin yig'ish", "target": 1000, "xp": 40, "gold": 4, "emoji": "â›ï¸"},
        {"day": 12, "type": "combo", "desc": "2 kitob + 1 kino", "target": 3, "xp": 85, "gold": 9, "emoji": "ðŸ†", "combo": ["download_book", "download_book", "watch_movie"]},
        {"day": 13, "type": "quiz", "desc": "4 ta test yechish", "target": 4, "xp": 80, "gold": 8, "emoji": "ðŸ§ "},
        {"day": 14, "type": "combo", "desc": "Haftalik super: 2 kitob + 2 test", "target": 4, "xp": 120, "gold": 15, "emoji": "ðŸ‘‘", "combo": ["download_book", "download_book", "quiz", "quiz"]},
        
        # Hafta 3: Qiyin vazifalar
        {"day": 15, "type": "download_book", "desc": "4 ta kitob yuklab olish", "target": 4, "xp": 90, "gold": 9, "emoji": "ðŸ“š"},
        {"day": 16, "type": "watch_movie", "desc": "4 ta kino ko'rish", "target": 4, "xp": 90, "gold": 9, "emoji": "ðŸŽ¬"},
        {"day": 17, "type": "quiz", "desc": "5 ta test yechish", "target": 5, "xp": 95, "gold": 10, "emoji": "ðŸ§ "},
        {"day": 18, "type": "mining", "desc": "2500 coin yig'ish", "target": 2500, "xp": 60, "gold": 6, "emoji": "â›ï¸"},
        {"day": 19, "type": "combo", "desc": "3 kitob + 2 test", "target": 5, "xp": 130, "gold": 14, "emoji": "ðŸ†", "combo": ["download_book", "download_book", "download_book", "quiz", "quiz"]},
        {"day": 20, "type": "streak", "desc": "20 kunlik streak!", "target": 20, "xp": 200, "gold": 25, "emoji": "ðŸ”¥"},
        {"day": 21, "type": "combo", "desc": "3 xil faoliyat: kitob + kino + test", "target": 3, "xp": 150, "gold": 18, "emoji": "ðŸ‘‘", "combo": ["download_book", "watch_movie", "quiz"]},
        
        # Hafta 4: Master darajasi
        {"day": 22, "type": "download_book", "desc": "5 ta kitob yuklab olish", "target": 5, "xp": 110, "gold": 11, "emoji": "ðŸ“š"},
        {"day": 23, "type": "quiz", "desc": "6 ta test yechish", "target": 6, "xp": 115, "gold": 12, "emoji": "ðŸ§ "},
        {"day": 24, "type": "watch_movie", "desc": "5 ta kino ko'rish", "target": 5, "xp": 110, "gold": 11, "emoji": "ðŸŽ¬"},
        {"day": 25, "type": "mining", "desc": "5000 coin yig'ish", "target": 5000, "xp": 80, "gold": 8, "emoji": "â›ï¸"},
        {"day": 26, "type": "combo", "desc": "4 kitob + 3 test", "target": 7, "xp": 170, "gold": 20, "emoji": "ðŸ†", "combo": ["download_book"] * 4 + ["quiz"] * 3},
        {"day": 27, "type": "quiz", "desc": "7 ta test yechish", "target": 7, "xp": 135, "gold": 14, "emoji": "ðŸ§ "},
        {"day": 28, "type": "combo", "desc": "2 kitob + 2 kino + 2 test", "target": 6, "xp": 180, "gold": 22, "emoji": "ðŸ‘‘", "combo": ["download_book"] * 2 + ["watch_movie"] * 2 + ["quiz"] * 2},
        
        # Final kunlar - Juda qiyin
        {"day": 29, "type": "download_book", "desc": "6 ta kitob yuklab olish", "target": 6, "xp": 140, "gold": 15, "emoji": "ðŸ“š"},
        {"day": 30, "type": "grand_finale", "desc": "GRAND FINALE: 3 kitob + 3 kino + 3 test", "target": 9, "xp": 500, "gold": 50, "emoji": "ðŸŽŠ", "combo": ["download_book"] * 3 + ["watch_movie"] * 3 + ["quiz"] * 3},
    ]
    
    async def get_daily_challenge(self) -> Dict:
        """Bugungi kunlik challengeni olish yoki yaratish (30-kunlik tizim)"""
        try:
            today = date.today().isoformat()
            
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT id, challenge_type, challenge_data, xp_reward, gold_reward
                    FROM daily_challenges WHERE challenge_date = ?
                ''', (today,))
                row = await cursor.fetchone()
                
                if row:
                    return {
                        "id": row[0],
                        "type": row[1],
                        "data": json.loads(row[2]) if row[2] else {},
                        "xp_reward": row[3],
                        "gold_reward": row[4],
                        "date": today
                    }
                
                # 30 kunlik challenge tizimidan mos kunni tanlash
                # Yil boshidan beri o'tgan kunlar soni % 30
                day_of_year = date.today().timetuple().tm_yday
                challenge_day = (day_of_year % 30) + 1  # 1-30 orasida
                
                challenge = next((c for c in self.THIRTY_DAY_CHALLENGES if c["day"] == challenge_day), self.THIRTY_DAY_CHALLENGES[0])
                xp_reward = challenge.get('xp', 30)
                gold_reward = challenge.get('gold', 3)
                
                await db.execute('''
                    INSERT INTO daily_challenges (challenge_date, challenge_type, challenge_data, xp_reward, gold_reward)
                    VALUES (?, ?, ?, ?, ?)
                ''', (today, challenge['type'], json.dumps(challenge), xp_reward, gold_reward))
                await db.commit()
                
                return {
                    "id": None,
                    "type": challenge['type'],
                    "data": challenge,
                    "xp_reward": xp_reward,
                    "gold_reward": gold_reward,
                    "date": today
                }
        except Exception as e:
            logger.error(f"get_daily_challenge error: {e}")
            return {}
    
    async def track_daily_challenge_progress(self, user_id: int, action_type: str, action_id: str = None) -> Dict:
        """Kunlik challenge progressini track qilish (ANTI-CHEATING BILAN)
        
        Anti-cheating mexanizmlari:
        1. Har bir action faqat bir marta hisoblanadi (action_id orqali)
        2. Tezlik limiti - 1 daqiqada maksimum 5 ta action
        3. Kunlik maksimum limit - 50 ta action
        4. Bir xil content takror yuklanmaydi
        """
        try:
            today = date.today().isoformat()
            now = datetime.now()
            challenge = await self.get_daily_challenge()
            
            if not challenge:
                return {"progress_added": False}
            
            challenge_type = challenge.get('type', '')
            challenge_data = challenge.get('data', {})
            target = challenge_data.get('target', 1)
            combo_types = challenge_data.get('combo', [])
            
            # Combo challenge uchun maxsus tekshirish
            if challenge_type in ['combo', 'grand_finale']:
                if action_type not in combo_types:
                    return {"progress_added": False, "wrong_type": True}
            else:
                # Oddiy challenge uchun type mapping
                type_mapping = {
                    'download_book': ['download_book', 'download_book_2', 'download_book_3'],
                    'watch_movie': ['watch_movie', 'watch_movie_2', 'watch_movie_3'],
                    'quiz': ['quiz'],
                    'mining': ['mining'],
                    'streak': ['streak'],
                }
                matching_types = type_mapping.get(action_type, [])
                if challenge_type not in matching_types and action_type != challenge_type:
                    return {"progress_added": False, "wrong_type": True}
            
            async with self.connect() as db:
                # ========== ANTI-CHEATING TEKSHIRUVLARI ==========
                
                # 1. Action ID tekshirish - bir xil action takror hisoblanmasin
                if action_id:
                    cursor = await db.execute('''
                        SELECT 1 FROM challenge_actions 
                        WHERE user_id = ? AND action_id = ? AND challenge_date = ?
                    ''', (user_id, action_id, today))
                    if await cursor.fetchone():
                        return {"progress_added": False, "duplicate_action": True, "reason": "Bu action allaqachon hisoblab bo'lingan"}
                
                # 2. Tezlik limiti - oxirgi 1 daqiqadagi actionlar
                one_minute_ago = (now - timedelta(minutes=1)).isoformat()
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM challenge_actions 
                    WHERE user_id = ? AND created_at > ?
                ''', (user_id, one_minute_ago))
                recent_count = (await cursor.fetchone())[0]
                
                if recent_count >= 5:
                    return {"progress_added": False, "rate_limited": True, "reason": "Juda tez! 1 daqiqa kutib turing."}
                
                # 3. Kunlik maksimum limit
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM challenge_actions 
                    WHERE user_id = ? AND challenge_date = ?
                ''', (user_id, today))
                daily_count = (await cursor.fetchone())[0]
                
                if daily_count >= 50:
                    return {"progress_added": False, "daily_limit": True, "reason": "Kunlik limit (50) tugadi"}
                
                # Action ni qayd etish (anti-cheat uchun)
                action_id = action_id or f"{action_type}_{user_id}_{now.timestamp()}"
                await db.execute('''
                    INSERT OR IGNORE INTO challenge_actions (user_id, action_id, action_type, challenge_date, created_at)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, action_id, action_type, today, now.isoformat()))
                
                # ========== PROGRESS YANGILASH ==========
                
                # Mavjud progressni olish
                cursor = await db.execute('''
                    SELECT progress, completed FROM user_daily_challenges 
                    WHERE user_id = ? AND challenge_date = ?
                ''', (user_id, today))
                row = await cursor.fetchone()
                
                if row and row[1]:  # Allaqachon bajarilgan
                    return {"progress_added": False, "already_completed": True}
                
                current_progress = row[0] if row else 0
                new_progress = current_progress + 1
                
                # Progress yangilash yoki yaratish
                await db.execute('''
                    INSERT INTO user_daily_challenges (user_id, challenge_date, progress, target, completed)
                    VALUES (?, ?, ?, ?, 0)
                    ON CONFLICT(user_id, challenge_date) DO UPDATE SET progress = ?
                ''', (user_id, today, new_progress, target, new_progress))
                
                await db.commit()
                
                # Agar target ga yetilsa, avtomatik complete
                if new_progress >= target:
                    return await self._complete_daily_challenge_internal(user_id, challenge)
                
                return {
                    "progress_added": True,
                    "current_progress": new_progress,
                    "target": target,
                    "completed": False
                }
        except Exception as e:
            logger.error(f"track_daily_challenge_progress error: {e}")
            return {"progress_added": False, "error": str(e)}
    
    async def _complete_daily_challenge_internal(self, user_id: int, challenge: Dict) -> Dict:
        """Ichki metod - challenge bajarilganda mukofot berish"""
        try:
            today = date.today().isoformat()
            
            async with self.connect() as db:
                # Bajarildi deb belgilash
                await db.execute('''
                    UPDATE user_daily_challenges SET completed = 1, completed_at = datetime('now')
                    WHERE user_id = ? AND challenge_date = ?
                ''', (user_id, today))
                
                # Mukofot berish
                await db.execute('''
                    UPDATE users SET 
                        xp = xp + ?, 
                        gold = gold + ?,
                        daily_challenges_completed = daily_challenges_completed + 1,
                        last_daily_challenge = ?
                    WHERE user_id = ?
                ''', (challenge['xp_reward'], challenge['gold_reward'], today, user_id))
                
                await db.commit()
                
                # Achievement tekshirish
                cursor = await db.execute(
                    'SELECT daily_challenges_completed FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                completed_count = row[0] if row else 0
                
                if completed_count >= 7:
                    await self.check_and_award_achievement(user_id, 'daily_7')
                if completed_count >= 30:
                    await self.check_and_award_achievement(user_id, 'daily_30')
                
                return {
                    "progress_added": True,
                    "completed": True,
                    "xp_reward": challenge['xp_reward'],
                    "gold_reward": challenge['gold_reward'],
                    "total_completed": completed_count
                }
        except Exception as e:
            logger.error(f"_complete_daily_challenge_internal error: {e}")
            return {"progress_added": False, "error": str(e)}
    
    async def check_daily_challenge_status(self, user_id: int) -> Dict:
        """Foydalanuvchining kunlik challenge holatini tekshirish (progress bilan)"""
        try:
            today = date.today().isoformat()
            challenge = await self.get_daily_challenge()
            target = challenge.get('data', {}).get('target', 1) if challenge else 1
            
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT progress, completed FROM user_daily_challenges 
                    WHERE user_id = ? AND challenge_date = ?
                ''', (user_id, today))
                row = await cursor.fetchone()
                
                return {
                    "completed": bool(row and row[1]),
                    "progress": row[0] if row else 0,
                    "target": target,
                    "date": today
                }
        except Exception as e:
            logger.error(f"check_daily_challenge_status error: {e}")
            return {"completed": False, "progress": 0, "target": 1}
    
    async def get_30day_challenge_roadmap(self, user_id: int) -> Dict:
        """30 kunlik challenge roadmapini olish (user progress bilan)"""
        try:
            day_of_year = date.today().timetuple().tm_yday
            current_day = (day_of_year % 30) + 1
            
            async with self.connect() as db:
                # Oxirgi 30 kun ichidagi bajarilgan challengelarni olish
                cursor = await db.execute('''
                    SELECT challenge_date, completed FROM user_daily_challenges 
                    WHERE user_id = ? AND completed = 1
                    ORDER BY challenge_date DESC LIMIT 30
                ''', (user_id,))
                completed_dates = {row[0] for row in await cursor.fetchall()}
                
                # User ning umumiy statistikasi
                cursor = await db.execute('''
                    SELECT daily_challenges_completed, streak_count FROM users WHERE user_id = ?
                ''', (user_id,))
                user_row = await cursor.fetchone()
                total_completed = user_row[0] if user_row else 0
                current_streak = user_row[1] if user_row else 0
            
            # Roadmap yaratish
            roadmap = []
            for challenge in self.THIRTY_DAY_CHALLENGES:
                day = challenge["day"]
                is_current = day == current_day
                is_completed = any(d for d in completed_dates if d)  # Simplified check
                is_locked = day > current_day
                
                roadmap.append({
                    "day": day,
                    "emoji": challenge["emoji"],
                    "desc": challenge["desc"],
                    "xp": challenge["xp"],
                    "gold": challenge["gold"],
                    "type": challenge["type"],
                    "is_current": is_current,
                    "is_completed": is_completed if not is_locked else False,
                    "is_locked": is_locked
                })
            
            return {
                "roadmap": roadmap,
                "current_day": current_day,
                "total_completed": total_completed,
                "current_streak": current_streak,
                "total_xp_available": sum(c["xp"] for c in self.THIRTY_DAY_CHALLENGES),
                "total_gold_available": sum(c["gold"] for c in self.THIRTY_DAY_CHALLENGES)
            }
        except Exception as e:
            logger.error(f"get_30day_challenge_roadmap error: {e}")
            return {"roadmap": [], "current_day": 1, "total_completed": 0}
    
    # =========================================================================
    # NOTIFICATION TIZIMI
    # =========================================================================
    
    async def add_notification(self, user_id: int, notification_type: str, title: str, message: str) -> bool:
        """Foydalanuvchiga notification qo'shish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO user_notifications (user_id, notification_type, title, message)
                    VALUES (?, ?, ?, ?)
                ''', (user_id, notification_type, title, message))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"add_notification error: {e}")
            return False
    
    async def get_unread_notifications(self, user_id: int, limit: int = 10) -> List[Dict]:
        """O'qilmagan notificationlarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT id, notification_type, title, message, created_at
                    FROM user_notifications 
                    WHERE user_id = ? AND is_read = 0
                    ORDER BY created_at DESC LIMIT ?
                ''', (user_id, limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_unread_notifications error: {e}")
            return []
    
    async def mark_notifications_read(self, user_id: int) -> bool:
        """Barcha notificationlarni o'qilgan deb belgilash"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE user_notifications SET is_read = 1 WHERE user_id = ?
                ''', (user_id,))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"mark_notifications_read error: {e}")
            return False
    
    async def get_unread_count(self, user_id: int) -> int:
        """O'qilmagan notificationlar sonini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM user_notifications 
                    WHERE user_id = ? AND is_read = 0
                ''', (user_id,))
                row = await cursor.fetchone()
                return row[0] if row else 0
        except Exception as e:
            logger.error(f"get_unread_count error: {e}")
            return 0
    
    # =========================================================================
    # REFERRAL DASHBOARD
    # =========================================================================
    
    async def get_referral_stats(self, user_id: int) -> Dict:
        """Foydalanuvchining referral statistikasini olish"""
        try:
            async with self.connect() as db:
                # Jami referrallar
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM users WHERE referral_id = ?
                ''', (user_id,))
                total_referrals = (await cursor.fetchone())[0] or 0
                
                # Oxirgi 7 kun
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM users 
                    WHERE referral_id = ? AND date(joined_date) >= date('now', '-7 days')
                ''', (user_id,))
                weekly_referrals = (await cursor.fetchone())[0] or 0
                
                # Oxirgi 30 kun
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM users 
                    WHERE referral_id = ? AND date(joined_date) >= date('now', '-30 days')
                ''', (user_id,))
                monthly_referrals = (await cursor.fetchone())[0] or 0
                
                # Referrallar ro'yxati
                cursor = await db.execute('''
                    SELECT user_id, full_name, username, joined_date
                    FROM users WHERE referral_id = ?
                    ORDER BY joined_date DESC LIMIT 10
                ''', (user_id,))
                recent_referrals = [dict(row) for row in await cursor.fetchall()]
                
                # Jami yig'ilgan XP referrallardan
                earned_xp = total_referrals * 75  # Har bir referral uchun 75 XP
                
                return {
                    "total": total_referrals,
                    "weekly": weekly_referrals,
                    "monthly": monthly_referrals,
                    "earned_xp": earned_xp,
                    "recent": recent_referrals
                }
        except Exception as e:
            logger.error(f"get_referral_stats error: {e}")
            return {"total": 0, "weekly": 0, "monthly": 0, "earned_xp": 0, "recent": []}
    
    async def get_course_videos(self, course_id: int) -> List[Dict]:
        """Kursning barcha videolarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT video_id, video_order, is_demo, title, duration
                    FROM course_videos 
                    WHERE course_id = ?
                    ORDER BY video_order ASC
                ''', (course_id,))
                rows = await cursor.fetchall()
                videos = []
                for row in rows:
                    videos.append({
                        'video_id': row[0],
                        'video_order': row[1],
                        'is_demo': row[2],
                        'title': row[3],
                        'duration': row[4]
                    })
                return videos
        except Exception as e:
            logger.error(f"get_course_videos error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # BOOK RATING METHODS
    # -------------------------------------------------------------------------
    
    async def set_book_rating(self, user_id: int, book_code: str, rating: int) -> Tuple[bool, str]:
        """Kitobga reyting qo'yish"""
        try:
            if rating < 1 or rating > 5:
                return False, "Reyting 1-5 oralig'ida bo'lishi kerak"
            
            async with self.connect() as db:
                # Oldingi baholashni tekshirish
                cursor = await db.execute('''
                    SELECT rating FROM book_ratings 
                    WHERE user_id = ? AND book_code = ?
                ''', (user_id, book_code))
                existing = await cursor.fetchone()
                
                if existing:
                    # Yangilash
                    await db.execute('''
                        UPDATE book_ratings 
                        SET rating = ? 
                        WHERE user_id = ? AND book_code = ?
                    ''', (rating, user_id, book_code))
                else:
                    # Yangi baholash
                    await db.execute('''
                        INSERT INTO book_ratings (user_id, book_code, rating)
                        VALUES (?, ?, ?)
                    ''', (user_id, book_code, rating))
                
                # Kitobning umumiy reytingini yangilash
                cursor = await db.execute('''
                    SELECT AVG(rating) as avg_rating, COUNT(*) as count
                    FROM book_ratings
                    WHERE book_code = ?
                ''', (book_code,))
                stats = await cursor.fetchone()
                
                if stats and stats['count'] > 0:
                    avg_rating = round(stats['avg_rating'], 1)
                    rating_count = stats['count']
                    
                    await db.execute('''
                        UPDATE books 
                        SET rating = ?, rating_count = ?
                        WHERE code = ?
                    ''', (avg_rating, rating_count, book_code))
                    await db.commit()
                
                return True, f"âœ… {rating} yulduz bilan baholandi!"
        except Exception as e:
            logger.error(f"set_book_rating error: {e}")
            return False, f"Xatolik: {e}"
    
    async def get_book_rating(self, user_id: int, book_code: str) -> Optional[int]:
        """Foydalanuvchining kitobga qo'ygan reytingini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT rating FROM book_ratings 
                    WHERE user_id = ? AND book_code = ?
                ''', (user_id, book_code))
                row = await cursor.fetchone()
                return row['rating'] if row else None
        except Exception as e:
            logger.error(f"get_book_rating error: {e}")
            return None
    
    # -------------------------------------------------------------------------
    # BOOK DOWNLOADS METHODS
    # -------------------------------------------------------------------------
    
    async def add_book_download(self, user_id: int, book_code: str) -> bool:
        """Kitob yuklashini qayd etish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO book_downloads (user_id, book_code)
                    VALUES (?, ?)
                ''', (user_id, book_code))
                
                # Books jadvalidagi downloads sonini yangilash
                await db.execute('''
                    UPDATE books 
                    SET downloads = downloads + 1 
                    WHERE code = ?
                ''', (book_code,))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"add_book_download error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # MINING FARM METHODS
    # -------------------------------------------------------------------------
    
    async def get_mining_farm(self, user_id: int) -> Optional[Dict]:
        """Mining fermasini olish (lazy calculation bilan)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('SELECT * FROM mining_farms WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                if not row:
                    return None
                
                farm = dict(row)
                
                # LAZY CALCULATION: Kutilayotgan XP ni hisoblash (DB ga yozmasdan)
                last_collected = farm.get('last_collected')
                if last_collected:
                    try:
                        current_time = datetime.now()
                        if ' ' in str(last_collected):
                            last_time = datetime.strptime(str(last_collected), '%Y-%m-%d %H:%M:%S')
                        elif 'T' in str(last_collected):
                            last_time = datetime.fromisoformat(str(last_collected).replace('Z', ''))
                        else:
                            last_time = datetime.strptime(str(last_collected), '%Y-%m-%d')
                        
                        hours_passed = (current_time - last_time).total_seconds() / 3600
                        pending_xp = int(hours_passed * farm.get('xp_per_hour', 10))
                        can_collect = hours_passed >= 1
                        minutes_until_collect = max(0, int(60 - (hours_passed * 60))) if hours_passed < 1 else 0
                        
                        farm['pending_xp'] = pending_xp
                        farm['can_collect'] = can_collect
                        farm['hours_passed'] = round(hours_passed, 2)
                        farm['minutes_until_collect'] = minutes_until_collect
                    except Exception as e:
                        logger.debug(f"Mining farm time parse error: {e}")
                        farm['pending_xp'] = farm.get('xp_per_hour', 10)
                        farm['can_collect'] = True
                        farm['hours_passed'] = 1
                        farm['minutes_until_collect'] = 0
                else:
                    farm['pending_xp'] = farm.get('xp_per_hour', 10)
                    farm['can_collect'] = True
                    farm['hours_passed'] = 1
                    farm['minutes_until_collect'] = 0
                
                return farm
        except Exception as e:
            logger.error(f"get_mining_farm error: {e}")
            return None
    
    async def collect_mining_rewards(self, user_id: int) -> Tuple[bool, str, int]:
        """Mining rewardlarini yig'ib olish"""
        try:
            async with self.connect() as db:
                farm = await self.get_mining_farm(user_id)
                if not farm:
                    return False, "Mining fermasi topilmadi", 0
                
                last_collected = farm.get('last_collected')
                current_time = datetime.now()
                
                if last_collected:
                    try:
                        if ' ' in last_collected:
                            last_time = datetime.strptime(last_collected, '%Y-%m-%d %H:%M:%S')
                        else:
                            last_time = datetime.strptime(last_collected, '%Y-%m-%d')
                        
                        hours_passed = (current_time - last_time).total_seconds() / 3600
                        
                        if hours_passed < 1:
                            return False, f"1 soat o'tmadi. Qolgan: {60 - int(hours_passed * 60)} daqiqa", 0
                        
                        xp_earned = int(hours_passed * farm['xp_per_hour'])
                    except Exception:
                        xp_earned = farm['xp_per_hour']
                else:
                    xp_earned = farm['xp_per_hour']
                
                await db.execute('UPDATE users SET xp = xp + ? WHERE user_id = ?', (xp_earned, user_id))
                await db.execute('UPDATE mining_farms SET last_collected = ?, total_collected = total_collected + ? WHERE user_id = ?',
                               (current_time.isoformat(), xp_earned, user_id))
                
                await db.execute('''
                    INSERT INTO xp_transactions (user_id, amount, type, description)
                    VALUES (?, ?, ?, ?)
                ''', (user_id, xp_earned, 'mining', 'Mining fermasi'))
                await db.commit()
                
                return True, f"Muvaffaqiyatli yig'ildi: {xp_earned} XP", xp_earned
                
        except Exception as e:
            logger.error(f"collect_mining_rewards error: {e}")
            return False, f"Xatolik: {e}", 0
    
    async def upgrade_mining_farm(self, user_id: int) -> Tuple[bool, str]:
        """Mining fermasini yangilash"""
        try:
            async with self.connect() as db:
                farm = await self.get_mining_farm(user_id)
                if not farm:
                    return False, "Mining fermasi topilmadi"
                
                upgrade_cost = farm['upgrade_cost']
                user = await self.get_user(user_id)
                
                if user['xp'] < upgrade_cost:
                    return False, f"Yetarli XP yo'q. Sizda {user['xp']} XP, kerak {upgrade_cost} XP"
                
                await db.execute('UPDATE users SET xp = xp - ? WHERE user_id = ?', (upgrade_cost, user_id))
                
                new_level = farm['level'] + 1
                new_xp_per_hour = farm['xp_per_hour'] * 2  # 2 baravar oshirildi
                new_upgrade_cost = upgrade_cost * 3  # 3 baravar oshirildi
                
                await db.execute('''
                    UPDATE mining_farms 
                    SET level = ?, 
                        xp_per_hour = ?,
                        upgrade_cost = ?
                    WHERE user_id = ?
                ''', (new_level, int(new_xp_per_hour), new_upgrade_cost, user_id))
                
                await db.execute('''
                    INSERT INTO xp_transactions (user_id, amount, type, description)
                    VALUES (?, ?, ?, ?)
                ''', (user_id, -upgrade_cost, 'mining_upgrade', f'Mining ferma upgrade (level {new_level})'))
                await db.commit()
                
                return True, f"âœ… Mining fermasi level {new_level} ga yangilandi!"
        except Exception as e:
            logger.error(f"upgrade_mining_farm error: {e}")
            return False, f"Xatolik: {e}"
    
    # -------------------------------------------------------------------------
    # USER ACTIVITY LOG METHODS
    # -------------------------------------------------------------------------
    
    async def log_user_activity(self, user_id: int, activity_type: str, details: Dict = None):
        """Foydalanuvchi faolligini log qilish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO user_activity_log (user_id, activity_type, details, timestamp)
                    VALUES (?, ?, ?, datetime('now'))
                ''', (user_id, activity_type, json.dumps(details or {})))
                await db.commit()
        except Exception as e:
            logger.error(f"log_user_activity error: {e}")
    
    # -------------------------------------------------------------------------
    # PAYMENT CARD METHODS
    # -------------------------------------------------------------------------
    
    async def add_payment_card(self, card_number: str, card_name: str, added_by: int) -> bool:
        """To'lov kartasini qo'shish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO payment_cards (card_number, card_name, added_by)
                    VALUES (?, ?, ?)
                ''', (card_number, card_name, added_by))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"add_payment_card error: {e}")
            return False
    
    async def get_payment_cards(self) -> List[Dict]:
        """To'lov kartalarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM payment_cards 
                    WHERE is_active = 1
                    ORDER BY added_at DESC
                ''')
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_payment_cards error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # DUEL METHODS
    # -------------------------------------------------------------------------
    
    async def create_duel(self, player1_id: int, player2_id: int, xp_bet: int = 50) -> Optional[int]:
        """Yangi duel yaratish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    INSERT INTO duels (player1_id, player2_id, xp_bet, status)
                    VALUES (?, ?, ?, 'pending')
                ''', (player1_id, player2_id, xp_bet))
                await db.commit()
                return cursor.lastrowid
        except Exception as e:
            logger.error(f"create_duel error: {e}")
            return None
    
    async def get_duel(self, duel_id: int) -> Optional[Dict]:
        """Duel ma'lumotlarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('SELECT * FROM duels WHERE id = ?', (duel_id,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_duel error: {e}")
            return None
    
    async def update_duel_choice(self, duel_id: int, player_id: int, choice: str) -> bool:
        """Duel tanlovini yangilash"""
        try:
            async with self.connect() as db:
                duel = await self.get_duel(duel_id)
                if not duel:
                    return False
                
                if duel['player1_id'] == player_id:
                    await db.execute('UPDATE duels SET player1_choice = ? WHERE id = ?', (choice, duel_id))
                elif duel['player2_id'] == player_id:
                    await db.execute('UPDATE duels SET player2_choice = ? WHERE id = ?', (choice, duel_id))
                else:
                    return False
                
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"update_duel_choice error: {e}")
            return False
    
    async def complete_duel(self, duel_id: int, winner_id: Optional[int] = None) -> bool:
        """Duelni yakunlash"""
        try:
            async with self.connect() as db:
                duel = await self.get_duel(duel_id)
                if not duel:
                    return False
                
                xp_bet = duel.get('xp_bet', 50)
                
                # XP transfer
                if winner_id:
                    # G'olib XP qaytariladi
                    await db.execute('UPDATE users SET xp = xp + ? WHERE user_id = ?', (xp_bet, winner_id))
                    # Mag'lub XP yo'qotadi (avval minus qilinadi)
                    loser_id = duel['player2_id'] if duel['player1_id'] == winner_id else duel['player1_id']
                    await db.execute('UPDATE users SET xp = xp - ? WHERE user_id = ?', (xp_bet, loser_id))
                # Durang bo'lsa, XP qaytarilmaydi
                
                await db.execute('''
                    UPDATE duels 
                    SET status = 'completed', winner_id = ?, finished_at = datetime('now')
                    WHERE id = ?
                ''', (winner_id, duel_id))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"complete_duel error: {e}")
            return False
    
    async def get_user_duel_stats(self, user_id: int) -> Dict:
        """Foydalanuvchi duel statistikasini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT 
                        COUNT(*) as total_duels,
                        SUM(CASE WHEN winner_id = ? THEN 1 ELSE 0 END) as wins,
                        SUM(CASE WHEN winner_id != ? AND winner_id IS NOT NULL AND status = 'completed' THEN 1 ELSE 0 END) as losses
                    FROM duels
                    WHERE (player1_id = ? OR player2_id = ?) AND status = 'completed'
                ''', (user_id, user_id, user_id, user_id))
                row = await cursor.fetchone()
                if row:
                    stats = dict(row)
                    stats['total_duels'] = stats.get('total_duels', 0) or 0
                    stats['wins'] = stats.get('wins', 0) or 0
                    stats['losses'] = stats.get('losses', 0) or 0
                    stats['draws'] = stats['total_duels'] - stats['wins'] - stats['losses']
                    return stats
                return {'total_duels': 0, 'wins': 0, 'losses': 0, 'draws': 0}
        except Exception as e:
            logger.error(f"get_user_duel_stats error: {e}")
            return {'total_duels': 0, 'wins': 0, 'losses': 0, 'draws': 0}
    
    # -------------------------------------------------------------------------
    # LEAGUE METHODS
    # -------------------------------------------------------------------------
    
    async def get_leagues(self) -> List[Dict]:
        """Barcha ligalarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM leagues 
                    ORDER BY min_xp ASC
                ''')
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_leagues error: {e}")
            return []
    
    async def get_user_league(self, user_xp: int) -> Optional[Dict]:
        """Foydalanuvchi ligasini olish (XP ga qarab)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM leagues 
                    WHERE min_xp <= ? AND max_xp >= ?
                    ORDER BY min_xp DESC
                    LIMIT 1
                ''', (user_xp, user_xp))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_user_league error: {e}")
            return None
    
    async def get_league_users(self, league_name: str, limit: int = 10) -> List[Dict]:
        """Ligadagi top foydalanuvchilarni olish"""
        try:
            async with self.connect() as db:
                league = await db.execute('SELECT min_xp, max_xp FROM leagues WHERE league_name = ?', (league_name,))
                league_row = await league.fetchone()
                if not league_row:
                    return []
                
                min_xp = league_row['min_xp']
                max_xp = league_row['max_xp']
                
                cursor = await db.execute('''
                    SELECT user_id, full_name, username, xp 
                    FROM users 
                    WHERE xp >= ? AND xp <= ?
                    ORDER BY xp DESC
                    LIMIT ?
                ''', (min_xp, max_xp, limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_league_users error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # BOOK SEARCH INDEX METHODS
    # -------------------------------------------------------------------------
    
    async def update_book_search_index(self, book_code: str, search_text: str) -> bool:
        """Kitob qidiruv indeksini yangilash"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT OR REPLACE INTO book_search_index (book_code, search_text)
                    VALUES (?, ?)
                ''', (book_code, search_text.lower()))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"update_book_search_index error: {e}")
            return False
    
    async def search_books_by_index(self, query: str, limit: int = 20) -> List[Dict]:
        """Book search index orqali qidirish (tezkor)"""
        try:
            async with self.connect() as db:
                query_lower = query.lower()
                cursor = await db.execute('''
                    SELECT b.* 
                    FROM books b
                    INNER JOIN book_search_index bsi ON b.code = bsi.book_code
                    WHERE bsi.search_text LIKE ? 
                    AND b.is_active = 1 
                    AND (b.status = "approved" OR b.status IS NULL)
                    ORDER BY b.downloads DESC, b.rating DESC
                    LIMIT ?
                ''', (f'%{query_lower}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"search_books_by_index error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # EXCEL EXPORT METHODS
    # -------------------------------------------------------------------------
    
    async def export_users_to_excel(self) -> Optional[str]:
        """Foydalanuvchilarni Excel'ga export qilish"""
        if not OPENPYXL_AVAILABLE:
            logger.error("openpyxl paketi o'rnatilmagan!")
            return None
        
        try:
            excel_dir = os.path.join(Config.DATA_DIR, "excel")
            os.makedirs(excel_dir, exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"users_export_{timestamp}.xlsx"
            filepath = os.path.join(excel_dir, filename)
            
            wb = Workbook()
            ws_users = wb.active
            ws_users.title = "Foydalanuvchilar"
            
            headers = ['ID', 'Ism', 'Username', 'Qo\'shilgan sana', 'Status', 'XP', 'Yuklamalar', 'Referallar']
            
            for col, header in enumerate(headers, 1):
                cell = ws_users.cell(row=1, column=col, value=header)
                cell.font = Font(bold=True)
            
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT user_id, full_name, username, joined_date, subscription_type, xp, total_downloads, referral_count
                    FROM users ORDER BY user_id
                ''')
                users_rows = await cursor.fetchall()
                users = [dict(user) for user in users_rows]
                
                for row_idx, user in enumerate(users, 2):
                    ws_users.cell(row=row_idx, column=1, value=user.get('user_id', 0))
                    ws_users.cell(row=row_idx, column=2, value=user.get('full_name', '') or '')
                    ws_users.cell(row=row_idx, column=3, value=user.get('username', '') or '')
                    ws_users.cell(row=row_idx, column=4, value=user.get('joined_date', ''))
                    ws_users.cell(row=row_idx, column=5, value=DatabaseManager.get_subscription_name(user.get('subscription_type', 0)))
                    ws_users.cell(row=row_idx, column=6, value=user.get('xp', 0))
                    ws_users.cell(row=row_idx, column=7, value=user.get('total_downloads', 0))
                    ws_users.cell(row=row_idx, column=8, value=user.get('referral_count', 0))
            
            wb.save(filepath)
            
            # Database'ga yozish
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO excel_exports (user_id, export_type, file_path)
                    VALUES (?, ?, ?)
                ''', (0, 'users', filepath))
                await db.commit()
            
            logger.info(f"Excel export yaratildi: {filepath}")
            return filepath
        except Exception as e:
            logger.error(f"export_users_to_excel error: {e}")
            return None
    
    # -------------------------------------------------------------------------
    # BACKUP METHODS
    # -------------------------------------------------------------------------
    
    async def create_backup(self, backup_type: str = "full", created_by: int = None) -> Optional[str]:
        """Database backup yaratish"""
        try:
            backup_dir = os.path.join(Config.DATA_DIR, "backups")
            os.makedirs(backup_dir, exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"backup_{backup_type}_{timestamp}.db"
            backup_path = os.path.join(backup_dir, backup_filename)
            
            # Database ni nusxalash
            shutil.copy2(self.db_path, backup_path)
            
            # Backup ma'lumotini database'ga yozish
            file_size = os.path.getsize(backup_path)
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO backups (backup_type, file_path, file_size, created_by)
                    VALUES (?, ?, ?, ?)
                ''', (backup_type, backup_path, file_size, created_by))
                await db.commit()
            
            logger.info(f"Backup yaratildi: {backup_path}")
            return backup_path
        except Exception as e:
            logger.error(f"create_backup error: {e}")
            return None
    
    # -------------------------------------------------------------------------
    # STATISTICS METHODS
    # -------------------------------------------------------------------------
    
    async def get_system_stats(self) -> Dict:
        """Tizim statistikasini olish"""
        try:
            async with self.connect() as db:
                stats = {}
                
                cursor = await db.execute('SELECT COUNT(*) FROM users')
                stats['total_users'] = (await cursor.fetchone())[0]
                
                cursor = await db.execute('SELECT COUNT(*) FROM users WHERE subscription_type > 0')
                stats['premium_users'] = (await cursor.fetchone())[0]
                
                cursor = await db.execute('SELECT COUNT(*) FROM users WHERE date(joined_date) = date("now")')
                stats['new_users_today'] = (await cursor.fetchone())[0]
                
                # Kitoblar
                cursor = await db.execute('SELECT COUNT(*) FROM books WHERE is_active = 1 AND (status = "approved" OR status IS NULL)')
                stats['total_books'] = (await cursor.fetchone())[0]
                
                # Filmlar
                cursor = await db.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1 AND (status = "approved" OR status IS NULL)')
                stats['total_movies'] = (await cursor.fetchone())[0]
                
                # Kurslar
                cursor = await db.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1 AND (status = "approved" OR status IS NULL)')
                stats['total_courses'] = (await cursor.fetchone())[0]
                
                # Download history (agar jadval mavjud bo'lsa)
                try:
                    cursor = await db.execute('SELECT COUNT(*) FROM download_history WHERE date(download_date) = date("now") AND item_type = "book"')
                    stats['book_downloads'] = (await cursor.fetchone())[0] or 0
                except Exception:
                    stats['book_downloads'] = 0
                
                try:
                    cursor = await db.execute('SELECT COUNT(*) FROM download_history WHERE date(download_date) = date("now") AND item_type = "movie"')
                    stats['movie_views'] = (await cursor.fetchone())[0] or 0
                except Exception:
                    stats['movie_views'] = 0
                
                # To'lovlar
                try:
                    cursor = await db.execute('SELECT SUM(amount) FROM payments WHERE status = "completed"')
                    result = await cursor.fetchone()
                    stats['total_revenue'] = result[0] if result and result[0] else 0
                except Exception:
                    stats['total_revenue'] = 0
                
                # DAU va MAU (download_history yoki users orqali)
                try:
                    cursor = await db.execute('SELECT COUNT(DISTINCT user_id) FROM download_history WHERE date(download_date) = date("now")')
                    stats['dau'] = (await cursor.fetchone())[0] or 0
                except Exception:
                    # Agar download_history yo'q bo'lsa, faol foydalanuvchilar orqali
                    cursor = await db.execute('SELECT COUNT(DISTINCT user_id) FROM users WHERE date(last_active_date) = date("now")')
                    stats['dau'] = (await cursor.fetchone())[0] or 0
                
                try:
                    cursor = await db.execute('SELECT COUNT(DISTINCT user_id) FROM download_history WHERE date(download_date) >= date("now", "-30 days")')
                    stats['mau'] = (await cursor.fetchone())[0] or 0
                except Exception:
                    # Agar download_history yo'q bo'lsa, faol foydalanuvchilar orqali
                    cursor = await db.execute('SELECT COUNT(DISTINCT user_id) FROM users WHERE date(last_active_date) >= date("now", "-30 days")')
                    stats['mau'] = (await cursor.fetchone())[0] or 0
                
                if stats['mau'] > 0:
                    stats['dau_percentage'] = (stats['dau'] / stats['mau']) * 100
                else:
                    stats['dau_percentage'] = 0
                
                return stats
        except Exception as e:
            logger.error(f"get_system_stats error: {e}")
            return {}
    
    async def update_all_course_prices(self, price: int) -> int:
        """Barcha kurslar narxini yangilash"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('UPDATE courses SET price = ? WHERE is_active = 1', (price,))
                await db.commit()
                return cursor.rowcount
        except Exception as e:
            logger.error(f"update_all_course_prices error: {e}")
            return 0
    
    async def get_pending_uploads(self, limit: int = 50) -> List[Dict]:
        """Kutilayotgan yuklamalarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM pending_uploads 
                    WHERE status = "pending"
                    ORDER BY uploaded_at DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_pending_uploads error: {e}")
            return []
    
    async def update_pending_upload_status(self, upload_id: int, status: str, approved_by: int = None) -> bool:
        """Kutilayotgan yuklama holatini yangilash"""
        try:
            async with self.connect() as db:
                if approved_by:
                    await db.execute('''
                        UPDATE pending_uploads 
                        SET status = ?, approved_by = ?, approved_at = datetime('now')
                        WHERE id = ?
                    ''', (status, approved_by, upload_id))
                else:
                    await db.execute('''
                        UPDATE pending_uploads 
                        SET status = ?
                        WHERE id = ?
                    ''', (status, upload_id))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"update_pending_upload_status error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # PREMIUM & SUBSCRIPTION METHODS
    # -------------------------------------------------------------------------
    
    async def activate_premium(self, user_id: int, days: int, subscription_type: int = 3) -> bool:
        """Premium obunani faollashtirish (TO'G'RI VAQT HISOBLASH - 30 kundan keyin aniq tugashi)"""
        try:
            async with self.connect() as db:
                current_time = datetime.now()
                
                # Foydalanuvchi ma'lumotlarini olish
                cursor = await db.execute('SELECT subscription_end, subscription_type FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return False
                
                current_end = row[0]
                current_sub_type = row[1] if len(row) > 1 else 0
                
                # Agar hozirgi obuna hali tugamagan bo'lsa, qolgan vaqtga qo'shamiz
                if current_end:
                    try:
                        # Turli formatlarni qo'llab-quvvatlash
                        if 'T' in str(current_end):
                            # ISO format: 2025-12-19T12:47:44
                            current_end_date = datetime.fromisoformat(str(current_end).replace('Z', '').split('.')[0])
                        elif ' ' in str(current_end):
                            # Oddiy format: 2025-12-19 12:47:44
                            current_end_date = datetime.strptime(str(current_end), '%Y-%m-%d %H:%M:%S')
                        else:
                            # Faqat sana: 2025-12-19
                            current_end_date = datetime.strptime(str(current_end), '%Y-%m-%d')
                        
                        # Agar hozirgi obuna hali tugamagan bo'lsa
                        if current_end_date > current_time:
                            # Qolgan vaqtga yangi kunlarni qo'shamiz (aniq)
                            expiry = current_end_date + timedelta(days=days)
                            logger.info(f"Premium qo'shildi: user_id={user_id}, qolgan_vaqt={current_end_date}, yangi_kun={days}, yangi_tugash={expiry}")
                        else:
                            # Obuna tugagan, yangi obuna (30 kun aniq)
                            expiry = current_time + timedelta(days=days)
                            logger.info(f"Yangi Premium: user_id={user_id}, {days} kun, tugash={expiry}")
                    except Exception as e:
                        # Xatolik bo'lsa, yangi obuna
                        logger.error(f"Premium vaqt hisoblashda xatolik: {e}, current_end={current_end}")
                        expiry = current_time + timedelta(days=days)
                else:
                    # Obuna yo'q, yangi obuna (30 kun aniq)
                    expiry = current_time + timedelta(days=days)
                    logger.info(f"Birinchi Premium: user_id={user_id}, {days} kun, tugash={expiry}")
                
                # Subscription type ni yangilash (yuqori darajadagi obunani saqlash)
                new_sub_type = max(subscription_type, current_sub_type) if current_sub_type > 0 else subscription_type
                
                # Aniq vaqt formatida saqlash
                expiry_str = expiry.strftime('%Y-%m-%d %H:%M:%S')
                
                await db.execute('''
                    UPDATE users 
                    SET subscription_type = ?,
                        subscription_end = ?
                    WHERE user_id = ?
                ''', (new_sub_type, expiry_str, user_id))
                
                logger.info(f"Premium faollashtirildi: user_id={user_id}, type={new_sub_type}, tugash={expiry_str}, kun={days}")
                return True
        except Exception as e:
            logger.error(f"activate_premium error: {e}", exc_info=True)
            return False
    
    # -------------------------------------------------------------------------
    # PAYMENT METHODS
    # -------------------------------------------------------------------------
    
    async def create_payment(self, user_id: int, amount: int, description: str, payment_method: str) -> Tuple[bool, str, Dict]:
        """Yangi to'lov yaratish"""
        try:
            async with self.connect() as db:
                payment_id = f"pay_{int(time.time())}_{random.randint(1000, 9999)}"
                invoice_id = Config.generate_invoice_id()
                
                await db.execute('''
                    INSERT INTO payments (payment_id, user_id, amount, payment_method, 
                                        description, invoice_id, status)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ''', (payment_id, user_id, amount, payment_method, description, invoice_id, 'pending'))
                
                return True, payment_id, {
                    'payment_id': payment_id,
                    'invoice_id': invoice_id,
                    'amount': amount,
                    'description': description,
                    'cards': Config.PAYMENT_CARDS
                }
        except Exception as e:
            logger.error(f"create_payment error: {e}")
            return False, f"Xatolik: {e}", {}
    
    async def confirm_payment(self, payment_id: str, transaction_id: str = None, confirmed_by: int = None) -> bool:
        """To'lovni tasdiqlash"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('SELECT * FROM payments WHERE payment_id = ?', (payment_id,))
                payment = await cursor.fetchone()
                
                if not payment:
                    return False
                
                await db.execute('''
                    UPDATE payments 
                    SET status = 'completed', 
                        transaction_id = ?,
                        confirmed_by = ?,
                        confirmed_date = datetime('now'),
                        payment_date = datetime('now')
                    WHERE payment_id = ?
                ''', (transaction_id, confirmed_by, payment_id))
                
                return True
        except Exception as e:
            logger.error(f"confirm_payment error: {e}")
            return False
    
    async def reject_payment(self, payment_id: str, rejected_by: int = None, reason: str = None) -> bool:
        """To'lovni rad etish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE payments 
                    SET status = 'rejected', 
                        confirmed_by = ?,
                        confirmed_date = datetime('now')
                    WHERE payment_id = ?
                ''', (rejected_by, payment_id))
                
                return True
        except Exception as e:
            logger.error(f"reject_payment error: {e}")
            return False
    
    async def record_download(self, user_id: int, item_type: str, item_id: int):
        """Download history ga yozish (statistika uchun)"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO download_history (user_id, item_type, item_id, download_date)
                    VALUES (?, ?, ?, datetime('now'))
                ''', (user_id, item_type, item_id))
        except Exception as e:
            logger.error(f"record_download error: {e}")
            # Jadval yo'q bo'lsa ham xatolik bermaslik
            pass
    
    async def get_pending_payments(self, limit: int = 20) -> List[Dict]:
        """Kutilayotgan to'lovlarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT p.*, u.full_name, u.username 
                    FROM payments p
                    LEFT JOIN users u ON p.user_id = u.user_id
                    WHERE p.status = 'pending'
                    ORDER BY p.payment_date DESC
                    LIMIT ?
                ''', (limit,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_pending_payments error: {e}")
            return []
    
    async def get_payment(self, payment_id: str) -> Optional[Dict]:
        """To'lov ma'lumotlarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT p.*, u.full_name, u.username 
                    FROM payments p
                    LEFT JOIN users u ON p.user_id = u.user_id
                    WHERE p.payment_id = ?
                ''', (payment_id,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_payment error: {e}")
            return None
    
    async def update_user(self, user_id: int, **kwargs) -> bool:
        """Foydalanuvchi ma'lumotlarini yangilash"""
        try:
            async with self.connect() as db:
                if not kwargs:
                    return False
                
                set_clause = ', '.join([f"{k} = ?" for k in kwargs.keys()])
                values = list(kwargs.values()) + [user_id]
                await db.execute(f'UPDATE users SET {set_clause} WHERE user_id = ?', values)
                return True
        except Exception as e:
            logger.error(f"update_user error: {e}")
            return False
    
    async def update_user_activity(self, user_id: int):
        """Foydalanuvchi faolligini yangilash"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE users 
                    SET last_active_date = datetime('now')
                    WHERE user_id = ?
                ''', (user_id,))
        except Exception as e:
            logger.error(f"update_user_activity error: {e}")
    
    @staticmethod
    def get_subscription_name(subscription_type: int) -> str:
        """Subscription nomini olish"""
        names = {
            0: "Standard",
            1: "Trial",
            2: "Exclusive",
            3: "Exclusive Pro+",
            4: "PRO",
            5: "Premium"
        }
        return names.get(subscription_type, "Standard")
    
    async def check_daily_bonus(self, user_id: int) -> Tuple[bool, int]:
        """Kunlik bonus olish mumkinmi tekshirish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT last_bonus_date, streak_count FROM users WHERE user_id = ?
                ''', (user_id,))
                row = await cursor.fetchone()
                if not row:
                    return True, Config.XP_GAINS['daily_bonus']
                
                last_bonus = row[0]
                streak = row[1] or 0
                
                if not last_bonus:
                    return True, Config.XP_GAINS['daily_bonus']
                
                today = date.today().isoformat()
                if last_bonus == today:
                    return False, 0
                
                # Streak bo'yicha bonus ko'paytirish
                bonus_multiplier = 1 + (streak // 7)  # Har 7 kunda 2 baravar
                bonus_amount = Config.XP_GAINS['daily_bonus'] * bonus_multiplier
                return True, bonus_amount
        except Exception as e:
            logger.error(f"check_daily_bonus error: {e}")
            return True, Config.XP_GAINS['daily_bonus']
    
    async def give_daily_bonus(self, user_id: int) -> bool:
        """Kunlik bonus berish"""
        try:
            async with self.connect() as db:
                bonus_available, bonus_amount = await self.check_daily_bonus(user_id)
                if not bonus_available:
                    return False
                
                today = date.today().isoformat()
                await db.execute('''
                    UPDATE users 
                    SET xp = xp + ?, last_bonus_date = ?
                    WHERE user_id = ?
                ''', (bonus_amount, today, user_id))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"give_daily_bonus error: {e}")
            return False
    
    async def get_user_language(self, user_id: int) -> str:
        """Foydalanuvchi tilini olish"""
        try:
            user = await self.get_user(user_id)
            return user.get('language', 'uz') if user else 'uz'
        except Exception as e:
            logger.error(f"get_user_language error: {e}")
            return 'uz'
    
    async def update_user_language(self, user_id: int, language: str) -> bool:
        """Foydalanuvchi tilini yangilash"""
        try:
            async with self.connect() as db:
                await db.execute('UPDATE users SET language = ? WHERE user_id = ?', (language, user_id))
                return True
        except Exception as e:
            logger.error(f"update_user_language error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # PREMIUM AUTO-COLLECT XP METHODS
    # -------------------------------------------------------------------------
    
    async def get_premium_users_for_autocollect(self) -> List[Dict]:
        """Premium foydalanuvchilarni auto-collect uchun olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT user_id, full_name, subscription_type, xp
                    FROM users
                    WHERE subscription_type >= 2
                    AND (subscription_end IS NULL OR datetime(subscription_end) > datetime('now'))
                    ORDER BY user_id
                ''')
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_premium_users_for_autocollect error: {e}")
            return []
    
    async def premium_auto_collect_xp(self, user_id: int, xp_amount: int) -> bool:
        """Premium foydalanuvchiga avtomatik XP berish"""
        try:
            async with self.connect() as db:
                await db.execute('UPDATE users SET xp = xp + ? WHERE user_id = ?', (xp_amount, user_id))
                
                await db.execute('''
                    INSERT INTO xp_transactions (user_id, amount, type, description)
                    VALUES (?, ?, ?, ?)
                ''', (user_id, xp_amount, 'premium_auto_collect', 'Premium auto-collect XP'))
                
                await db.commit()
                logger.info(f"Premium auto-collect: user_id={user_id}, xp={xp_amount}")
                return True
        except Exception as e:
            logger.error(f"premium_auto_collect_xp error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # TRIAL SYSTEM METHODS
    # -------------------------------------------------------------------------
    
    async def start_trial(self, user_id: int) -> bool:
        """1 soatlik trial boshlash"""
        try:
            async with self.connect() as db:
                # Trial allaqachon ishlatilganmi tekshirish
                cursor = await db.execute('SELECT trial_used FROM users WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                
                if not row:
                    return False
                
                trial_used = row[0] if row[0] is not None else 0
                
                if trial_used:
                    logger.info(f"Trial allaqachon ishlatilgan: user_id={user_id}")
                    return False
                
                # Trial boshlash - 1 soat
                trial_start = datetime.now()
                trial_end = trial_start + timedelta(hours=1)
                
                await db.execute('''
                    UPDATE users 
                    SET subscription_type = 1,
                        trial_used = 1,
                        trial_started_at = ?,
                        trial_ends_at = ?,
                        subscription_end = ?
                    WHERE user_id = ?
                ''', (trial_start.isoformat(), trial_end.isoformat(), trial_end.strftime('%Y-%m-%d %H:%M:%S'), user_id))
                
                await db.commit()
                logger.info(f"Trial boshlandi: user_id={user_id}, 1 soat, tugash={trial_end}")
                return True
        except Exception as e:
            logger.error(f"start_trial error: {e}")
            return False
    
    async def check_trial_expiry(self) -> List[Dict]:
        """Tugagan trial'larni tekshirish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT user_id, full_name, trial_ends_at
                    FROM users
                    WHERE subscription_type = 1
                    AND trial_ends_at IS NOT NULL
                    AND datetime(trial_ends_at) <= datetime('now')
                ''')
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"check_trial_expiry error: {e}")
            return []
    
    async def expire_trial(self, user_id: int) -> bool:
        """Trial'ni tugat va Standard ga qaytarish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE users 
                    SET subscription_type = 0,
                        subscription_end = NULL
                    WHERE user_id = ?
                ''', (user_id,))
                await db.commit()
                logger.info(f"Trial tugadi: user_id={user_id}")
                return True
        except Exception as e:
            logger.error(f"expire_trial error: {e}")
            return False
    
    async def get_trial_ending_soon(self, minutes: int = 15) -> List[Dict]:
        """Yaqinda tugaydigan trial'larni olish (notification uchun)"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT user_id, full_name, trial_ends_at
                    FROM users
                    WHERE subscription_type = 1
                    AND trial_ends_at IS NOT NULL
                    AND datetime(trial_ends_at) > datetime('now')
                    AND datetime(trial_ends_at) <= datetime('now', '+' || ? || ' minutes')
                ''', (minutes,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_trial_ending_soon error: {e}")
            return []
    
    # -------------------------------------------------------------------------
    # ACHIEVEMENT SYSTEM METHODS
    # -------------------------------------------------------------------------
    
    async def check_and_award_achievements(self, user_id: int) -> List[str]:
        """Foydalanuvchi yutuqlarini tekshirish va berish"""
        awarded = []
        try:
            user = await self.get_user(user_id)
            if not user:
                return awarded
            
            # Hozirgi yutuqlar
            current_achievements = json.loads(user.get('achievements', '[]'))
            
            # Yutuqlar ro'yxati
            achievements = {
                'first_book': {'name': 'ðŸ“š Birinchi kitob', 'condition': lambda u: u.get('total_downloads', 0) >= 1, 'xp': 50},
                'book_lover': {'name': 'ðŸ“š Kitobxon', 'condition': lambda u: u.get('total_downloads', 0) >= 10, 'xp': 100},
                'book_master': {'name': 'ðŸ“š Kitob ustasi', 'condition': lambda u: u.get('total_downloads', 0) >= 50, 'xp': 500},
                'first_referral': {'name': 'ðŸ‘¥ Birinchi referal', 'condition': lambda u: u.get('referral_count', 0) >= 1, 'xp': 75},
                'referral_pro': {'name': 'ðŸ‘¥ Referal pro', 'condition': lambda u: u.get('referral_count', 0) >= 10, 'xp': 500},
                'xp_1000': {'name': 'â­ 1000 XP', 'condition': lambda u: u.get('xp', 0) >= 1000, 'xp': 100},
                'xp_5000': {'name': 'â­ 5000 XP', 'condition': lambda u: u.get('xp', 0) >= 5000, 'xp': 500},
                'xp_10000': {'name': 'â­ 10000 XP', 'condition': lambda u: u.get('xp', 0) >= 10000, 'xp': 1000},
                'streak_7': {'name': 'ðŸ”¥ 7 kunlik streak', 'condition': lambda u: u.get('streak_count', 0) >= 7, 'xp': 200},
                'streak_30': {'name': 'ðŸ”¥ 30 kunlik streak', 'condition': lambda u: u.get('streak_count', 0) >= 30, 'xp': 1000},
            }
            
            # Har bir yutuqni tekshirish
            for ach_id, ach_data in achievements.items():
                if ach_id not in current_achievements and ach_data['condition'](user):
                    current_achievements.append(ach_id)
                    awarded.append(ach_data['name'])
                    
                    # XP berish
                    await self.add_xp(user_id, ach_data['xp'], 'achievement', 0)
                    logger.info(f"Achievement awarded: user_id={user_id}, achievement={ach_id}, xp={ach_data['xp']}")
            
            # Yangilangan yutuqlarni saqlash
            if awarded:
                async with self.connect() as db:
                    await db.execute('''
                        UPDATE users 
                        SET achievements = ?
                        WHERE user_id = ?
                    ''', (json.dumps(current_achievements), user_id))
                    await db.commit()
            
            return awarded
        except Exception as e:
            logger.error(f"check_and_award_achievements error: {e}")
            return awarded
    
    async def get_user_achievements(self, user_id: int) -> Dict:
        """Foydalanuvchi yutuqlarini olish"""
        try:
            user = await self.get_user(user_id)
            if not user:
                return {'unlocked': [], 'locked': []}
            
            current_achievements = json.loads(user.get('achievements', '[]'))
            
            # Barcha yutuqlar
            all_achievements = {
                'first_book': {'name': 'ðŸ“š Birinchi kitob', 'desc': 'Birinchi kitobni yuklab oling', 'xp': 50},
                'book_lover': {'name': 'ðŸ“š Kitobxon', 'desc': '10 ta kitob yuklab oling', 'xp': 100},
                'book_master': {'name': 'ðŸ“š Kitob ustasi', 'desc': '50 ta kitob yuklab oling', 'xp': 500},
                'first_referral': {'name': 'ðŸ‘¥ Birinchi referal', 'desc': 'Birinchi do\'stingizni taklif qiling', 'xp': 75},
                'referral_pro': {'name': 'ðŸ‘¥ Referal pro', 'desc': '10 ta do\'stingizni taklif qiling', 'xp': 500},
                'xp_1000': {'name': 'â­ 1000 XP', 'desc': '1000 XP to\'plang', 'xp': 100},
                'xp_5000': {'name': 'â­ 5000 XP', 'desc': '5000 XP to\'plang', 'xp': 500},
                'xp_10000': {'name': 'â­ 10000 XP', 'desc': '10000 XP to\'plang', 'xp': 1000},
                'streak_7': {'name': 'ðŸ”¥ 7 kunlik streak', 'desc': '7 kun ketma-ket botga kiring', 'xp': 200},
                'streak_30': {'name': 'ðŸ”¥ 30 kunlik streak', 'desc': '30 kun ketma-ket botga kiring', 'xp': 1000},
            }
            
            unlocked = []
            locked = []
            
            for ach_id, ach_data in all_achievements.items():
                if ach_id in current_achievements:
                    unlocked.append({
                        'id': ach_id,
                        'name': ach_data['name'],
                        'desc': ach_data['desc'],
                        'xp': ach_data['xp']
                    })
                else:
                    locked.append({
                        'id': ach_id,
                        'name': ach_data['name'],
                        'desc': ach_data['desc'],
                        'xp': ach_data['xp']
                    })
            
            return {'unlocked': unlocked, 'locked': locked}
        except Exception as e:
            logger.error(f"get_user_achievements error: {e}")
            return {'unlocked': [], 'locked': []}
    
    # -------------------------------------------------------------------------
    # PROMO CODE METHODS
    # -------------------------------------------------------------------------
    
    async def create_promo_code(self, code: str, promo_type: str, value: int, max_uses: int = 1, expires_at: str = None) -> bool:
        """Promo kod yaratish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    INSERT INTO promo_codes (code, type, value, max_uses, expires_at, is_active)
                    VALUES (?, ?, ?, ?, ?, 1)
                ''', (code.upper(), promo_type, value, max_uses, expires_at))
                await db.commit()
                logger.info(f"Promo kod yaratildi: code={code}, type={promo_type}, value={value}")
                return True
        except Exception as e:
            logger.error(f"create_promo_code error: {e}")
            return False
    
    async def use_promo_code(self, user_id: int, code: str) -> Tuple[bool, str, Dict]:
        """Promo kodni ishlatish"""
        try:
            async with self.connect() as db:
                # Promo kodni tekshirish
                cursor = await db.execute('''
                    SELECT id, type, value, max_uses, used_count, expires_at, is_active
                    FROM promo_codes
                    WHERE code = ? AND is_active = 1
                ''', (code.upper(),))
                promo = await cursor.fetchone()
                
                if not promo:
                    return False, "âŒ Promo kod topilmadi yoki faol emas!", {}
                
                promo_id, promo_type, value, max_uses, used_count, expires_at, is_active = promo
                
                # Muddatni tekshirish
                if expires_at:
                    from datetime import datetime
                    if datetime.now() > datetime.fromisoformat(expires_at):
                        return False, "âŒ Promo kod muddati tugagan!", {}
                
                # Foydalanish limitini tekshirish
                if used_count >= max_uses:
                    return False, "âŒ Promo kod limiti tugagan!", {}
                
                # Foydalanuvchi allaqachon ishlatganmi
                cursor = await db.execute('''
                    SELECT 1 FROM promo_code_usage
                    WHERE user_id = ? AND promo_code_id = ?
                ''', (user_id, promo_id))
                if await cursor.fetchone():
                    return False, "âŒ Siz bu promo kodni allaqachon ishlatgansiz!", {}
                
                # Promo kodni ishlatish
                if promo_type == 'xp':
                    await self.add_xp(user_id, value, 'promo_code', 0)
                    message = f"âœ… {value:,} XP qo'shildi!"
                elif promo_type == 'premium':
                    await self.activate_premium(user_id, value, 2)  # value = kunlar soni
                    message = f"âœ… {value} kunlik Premium aktivlashtirildi!"
                elif promo_type == 'ai_limit':
                    await db.execute('UPDATE users SET ai_limit = ai_limit + ? WHERE user_id = ?', (value, user_id))
                    message = f"âœ… {value} ta AI limit qo'shildi!"
                else:
                    return False, "âŒ Noto'g'ri promo kod turi!", {}
                
                # Foydalanishni qayd etish
                await db.execute('''
                    INSERT INTO promo_code_usage (user_id, promo_code_id)
                    VALUES (?, ?)
                ''', (user_id, promo_id))
                
                # Foydalanish sonini oshirish
                await db.execute('''
                    UPDATE promo_codes
                    SET used_count = used_count + 1
                    WHERE id = ?
                ''', (promo_id,))
                
                await db.commit()
                logger.info(f"Promo kod ishlatildi: user_id={user_id}, code={code}, type={promo_type}, value={value}")
                
                return True, message, {'type': promo_type, 'value': value}
        except Exception as e:
            logger.error(f"use_promo_code error: {e}")
            return False, f"âŒ Xatolik: {str(e)}", {}
    
    # -------------------------------------------------------------------------
    # SUPPORT TICKET METHODS
    # -------------------------------------------------------------------------
    
    async def create_support_ticket(self, user_id: int, subject: str, message: str, attachment_type: str = None, attachment_id: str = None) -> Tuple[bool, int]:
        """Support ticket yaratish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    INSERT INTO support_tickets (user_id, subject, message, attachment_type, attachment_id, status)
                    VALUES (?, ?, ?, ?, ?, 'open')
                ''', (user_id, subject, message, attachment_type, attachment_id))
                ticket_id = cursor.lastrowid
                await db.commit()
                logger.info(f"Support ticket yaratildi: user_id={user_id}, ticket_id={ticket_id}")
                return True, ticket_id
        except Exception as e:
            logger.error(f"create_support_ticket error: {e}")
            return False, 0
    
    async def get_user_tickets(self, user_id: int) -> List[Dict]:
        """Foydalanuvchi ticketlarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT id, subject, message, status, created_date, admin_response
                    FROM support_tickets
                    WHERE user_id = ?
                    ORDER BY created_date DESC
                    LIMIT 20
                ''', (user_id,))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_user_tickets error: {e}")
            return []
    
    async def get_ticket(self, ticket_id: int) -> Optional[Dict]:
        """Ticket ma'lumotlarini olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT * FROM support_tickets WHERE id = ?
                ''', (ticket_id,))
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"get_ticket error: {e}")
            return None
    
    async def respond_to_ticket(self, ticket_id: int, admin_response: str) -> bool:
        """Ticketga javob berish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE support_tickets
                    SET admin_response = ?, status = 'answered', responded_date = datetime('now')
                    WHERE id = ?
                ''', (admin_response, ticket_id))
                await db.commit()
                logger.info(f"Ticket javob berildi: ticket_id={ticket_id}")
                return True
        except Exception as e:
            logger.error(f"respond_to_ticket error: {e}")
            return False
    
    async def close_ticket(self, ticket_id: int) -> bool:
        """Ticketni yopish"""
        try:
            async with self.connect() as db:
                await db.execute('''
                    UPDATE support_tickets
                    SET status = 'closed'
                    WHERE id = ?
                ''', (ticket_id,))
                await db.commit()
                logger.info(f"Ticket yopildi: ticket_id={ticket_id}")
                return True
        except Exception as e:
            logger.error(f"close_ticket error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # DATABASE OPTIMIZATION METHODS
    # -------------------------------------------------------------------------
    
    async def cleanup_old_data(self, days: int = 90) -> Dict[str, int]:
        """Eski ma'lumotlarni tozalash (90 kundan eski)"""
        try:
            async with self.connect() as db:
                deleted = {}
                
                # Eski XP transaksiyalarni o'chirish
                cursor = await db.execute('''
                    DELETE FROM xp_transactions
                    WHERE created_date < datetime('now', '-' || ? || ' days')
                ''', (days,))
                deleted['xp_transactions'] = cursor.rowcount
                
                # Eski push notificationlarni o'chirish
                cursor = await db.execute('''
                    DELETE FROM push_notifications
                    WHERE sent_date < datetime('now', '-' || ? || ' days')
                ''', (days,))
                deleted['push_notifications'] = cursor.rowcount
                
                # Eski user activity loglarni o'chirish
                cursor = await db.execute('''
                    DELETE FROM user_activity_log
                    WHERE activity_date < datetime('now', '-' || ? || ' days')
                ''', (days,))
                deleted['user_activity_log'] = cursor.rowcount
                
                # Yopilgan ticketlarni o'chirish (30 kundan eski)
                cursor = await db.execute('''
                    DELETE FROM support_tickets
                    WHERE status = 'closed' AND created_date < datetime('now', '-30 days')
                ''')
                deleted['support_tickets'] = cursor.rowcount
                
                await db.commit()
                logger.info(f"Database cleanup: {deleted}")
                return deleted
        except Exception as e:
            logger.error(f"cleanup_old_data error: {e}")
            return {}
    
    async def optimize_database(self) -> bool:
        """Database optimizatsiya - VACUUM va ANALYZE"""
        try:
            async with self.connect() as db:
                await db.execute('VACUUM')
                await db.execute('ANALYZE')
                logger.info("Database optimized: VACUUM and ANALYZE completed")
                return True
        except Exception as e:
            logger.error(f"optimize_database error: {e}")
            return False
    
    async def update_statistics(self) -> Dict[str, int]:
        """Statistikani yangilash"""
        try:
            async with self.connect() as db:
                stats = {}
                
                # Jami foydalanuvchilar
                cursor = await db.execute('SELECT COUNT(*) FROM users')
                stats['total_users'] = (await cursor.fetchone())[0]
                
                # Premium foydalanuvchilar
                cursor = await db.execute('SELECT COUNT(*) FROM users WHERE subscription_type > 0')
                stats['premium_users'] = (await cursor.fetchone())[0]
                
                # Jami kitoblar
                cursor = await db.execute('SELECT COUNT(*) FROM books WHERE is_active = 1')
                stats['total_books'] = (await cursor.fetchone())[0]
                
                # Jami filmlar
                cursor = await db.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1')
                stats['total_movies'] = (await cursor.fetchone())[0]
                
                # Jami kurslar
                cursor = await db.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1')
                stats['total_courses'] = (await cursor.fetchone())[0]
                
                # Bugungi yuklamalar
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM download_history
                    WHERE DATE(download_date) = DATE('now')
                ''')
                stats['today_downloads'] = (await cursor.fetchone())[0]
                
                # System stats jadvaliga saqlash
                await db.execute('''
                    INSERT INTO system_stats (stat_date, total_users, premium_users, total_books, total_movies, total_courses, today_downloads)
                    VALUES (datetime('now'), ?, ?, ?, ?, ?, ?)
                ''', (stats['total_users'], stats['premium_users'], stats['total_books'], stats['total_movies'], stats['total_courses'], stats['today_downloads']))
                
                await db.commit()
                logger.info(f"Statistics updated: {stats}")
                return stats
        except Exception as e:
            logger.error(f"update_statistics error: {e}")
            return {}
    
    async def recalculate_user_stats(self, user_id: int) -> bool:
        """Foydalanuvchi statistikasini qayta hisoblash"""
        try:
            async with self.connect() as db:
                # Total downloads
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM download_history WHERE user_id = ?
                ''', (user_id,))
                total_downloads = (await cursor.fetchone())[0]
                
                # Referral count
                cursor = await db.execute('''
                    SELECT COUNT(*) FROM referrals WHERE referrer_id = ?
                ''', (user_id,))
                referral_count = (await cursor.fetchone())[0]
                
                # Total spent (XP)
                cursor = await db.execute('''
                    SELECT SUM(ABS(amount)) FROM xp_transactions 
                    WHERE user_id = ? AND amount < 0
                ''', (user_id,))
                result = await cursor.fetchone()
                total_spent = result[0] if result[0] else 0
                
                # Yangilash
                await db.execute('''
                    UPDATE users
                    SET total_downloads = ?, referral_count = ?, total_spent = ?
                    WHERE user_id = ?
                ''', (total_downloads, referral_count, total_spent, user_id))
                
                await db.commit()
                logger.info(f"User stats recalculated: user_id={user_id}")
                return True
        except Exception as e:
            logger.error(f"recalculate_user_stats error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # MINING FARM METHODS
    # -------------------------------------------------------------------------
    
    async def get_mining_farms_ready_to_collect(self) -> List[Dict]:
        """Yig'ish uchun tayyor mining farmlarni olish"""
        try:
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT mf.user_id, mf.level, mf.last_collected, u.full_name, u.subscription_type
                    FROM mining_farms mf
                    JOIN users u ON mf.user_id = u.user_id
                    WHERE datetime(mf.last_collected) < datetime('now', '-1 hour')
                    AND u.is_banned = 0
                ''')
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_mining_farms_ready_to_collect error: {e}")
            return []
    
    async def auto_collect_mining_rewards(self, user_id: int) -> Tuple[bool, int]:
        """Mining farm mukofotlarini avtomatik yig'ish"""
        try:
            farm = await self.get_mining_farm(user_id)
            if not farm:
                return False, 0
            
            # Oxirgi yig'ilgan vaqtdan beri o'tgan soatlar
            last_collected = farm.get('last_collected')
            if not last_collected:
                return False, 0
            
            from datetime import datetime
            last_time = datetime.fromisoformat(last_collected)
            now = datetime.now()
            hours_passed = (now - last_time).total_seconds() / 3600
            
            if hours_passed < 1:
                return False, 0
            
            # XP hisoblash
            level = farm.get('level', 1)
            base_xp = 10 * level
            total_xp = int(base_xp * hours_passed)
            
            # XP qo'shish
            await self.add_xp(user_id, total_xp, 'mining_auto_collect', 0)
            
            # Last collected yangilash
            async with self.connect() as db:
                await db.execute('''
                    UPDATE mining_farms
                    SET last_collected = datetime('now')
                    WHERE user_id = ?
                ''', (user_id,))
                await db.commit()
            
            logger.info(f"Mining auto-collected: user_id={user_id}, xp={total_xp}, hours={hours_passed:.1f}")
            return True, total_xp
        except Exception as e:
            logger.error(f"auto_collect_mining_rewards error: {e}")
            return False, 0
    
    # -------------------------------------------------------------------------
    # LEAGUE SYSTEM METHODS
    # -------------------------------------------------------------------------
    
    def get_league_by_level(self, level: int) -> Dict[str, str]:
        """Level bo'yicha liga aniqlash"""
        if level < 5:
            return {'name': 'Bronza', 'emoji': 'ðŸ¥‰', 'color': '#CD7F32'}
        elif level < 10:
            return {'name': 'Kumush', 'emoji': 'ðŸ¥ˆ', 'color': '#C0C0C0'}
        elif level < 20:
            return {'name': 'Oltin', 'emoji': 'ðŸ¥‡', 'color': '#FFD700'}
        elif level < 30:
            return {'name': 'Platina', 'emoji': 'ðŸ’Ž', 'color': '#E5E4E2'}
        elif level < 50:
            return {'name': 'Brilliant', 'emoji': 'ðŸ’ ', 'color': '#B9F2FF'}
        else:
            return {'name': 'Legend', 'emoji': 'ðŸ‘‘', 'color': '#FF0000'}
    
    async def get_league_leaderboard(self, league_name: str, limit: int = 50) -> List[Dict]:
        """Liga bo'yicha reyting jadvali"""
        try:
            async with self.connect() as db:
                # Liga uchun level oralig'ini aniqlash
                level_ranges = {
                    'Bronza': (0, 4),
                    'Kumush': (5, 9),
                    'Oltin': (10, 19),
                    'Platina': (20, 29),
                    'Brilliant': (30, 49),
                    'Legend': (50, 999)
                }
                
                min_level, max_level = level_ranges.get(league_name, (0, 4))
                
                cursor = await db.execute('''
                    SELECT user_id, full_name, username, xp, subscription_type,
                           CAST((xp / 1000) AS INTEGER) as level
                    FROM users
                    WHERE CAST((xp / 1000) AS INTEGER) BETWEEN ? AND ?
                    AND is_banned = 0
                    ORDER BY xp DESC
                    LIMIT ?
                ''', (min_level, max_level, limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"get_league_leaderboard error: {e}")
            return []
    
    async def get_user_league_rank(self, user_id: int) -> Dict:
        """Foydalanuvchining ligadagi o'rni"""
        try:
            user = await self.get_user(user_id)
            if not user:
                return {}
            
            level = calculate_level(user.get('xp', 0))
            league = self.get_league_by_level(level)
            
            # Ligadagi o'rni
            leaderboard = await self.get_league_leaderboard(league['name'], 1000)
            rank = next((i + 1 for i, u in enumerate(leaderboard) if u['user_id'] == user_id), 0)
            
            return {
                'league': league,
                'rank': rank,
                'total_players': len(leaderboard),
                'level': level,
                'xp': user.get('xp', 0)
            }
        except Exception as e:
            logger.error(f"get_user_league_rank error: {e}")
            return {}
    
    async def get_league_rewards(self, league_name: str) -> Dict[str, int]:
        """Liga mukofotlari"""
        rewards = {
            'Bronza': {'xp': 100, 'ai_limit': 5},
            'Kumush': {'xp': 250, 'ai_limit': 10},
            'Oltin': {'xp': 500, 'ai_limit': 20},
            'Platina': {'xp': 1000, 'ai_limit': 50},
            'Brilliant': {'xp': 2500, 'ai_limit': 100},
            'Legend': {'xp': 5000, 'ai_limit': 200}
        }
        return rewards.get(league_name, {'xp': 0, 'ai_limit': 0})
    
    # -------------------------------------------------------------------------
    # BOOK SEARCH INDEX METHODS
    # -------------------------------------------------------------------------
    
    async def rebuild_book_search_index(self) -> bool:
        """Kitoblar qidiruv indeksini qayta qurish"""
        try:
            async with self.connect() as db:
                # Search index jadvalini yaratish
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS book_search_index (
                        book_id INTEGER PRIMARY KEY,
                        search_text TEXT,
                        last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (book_id) REFERENCES books(id)
                    )
                ''')
                
                # Barcha kitoblarni indekslash
                cursor = await db.execute('''
                    SELECT id, caption, author, genre, description
                    FROM books
                    WHERE is_active = 1
                ''')
                books = await cursor.fetchall()
                
                for book in books:
                    book_id, caption, author, genre, description = book
                    
                    # Qidiruv matni yaratish (barcha ma'lumotlarni birlashtirish)
                    search_text = f"{caption or ''} {author or ''} {genre or ''} {description or ''}".lower()
                    
                    # Indeksga qo'shish
                    await db.execute('''
                        INSERT OR REPLACE INTO book_search_index (book_id, search_text, last_updated)
                        VALUES (?, ?, datetime('now'))
                    ''', (book_id, search_text))
                
                await db.commit()
                logger.info(f"Book search index rebuilt: {len(books)} books indexed")
                return True
        except Exception as e:
            logger.error(f"rebuild_book_search_index error: {e}")
            return False
    
    async def update_book_search_index(self, book_id: int) -> bool:
        """Bitta kitobni indeksga qo'shish/yangilash"""
        try:
            async with self.connect() as db:
                # Kitob ma'lumotlarini olish
                cursor = await db.execute('''
                    SELECT caption, author, genre, description
                    FROM books
                    WHERE id = ? AND is_active = 1
                ''', (book_id,))
                book = await cursor.fetchone()
                
                if not book:
                    return False
                
                caption, author, genre, description = book
                
                # Qidiruv matni yaratish
                search_text = f"{caption or ''} {author or ''} {genre or ''} {description or ''}".lower()
                
                # Indeksga qo'shish
                await db.execute('''
                    INSERT OR REPLACE INTO book_search_index (book_id, search_text, last_updated)
                    VALUES (?, ?, datetime('now'))
                ''', (book_id, search_text))
                
                await db.commit()
                logger.info(f"Book search index updated: book_id={book_id}")
                return True
        except Exception as e:
            logger.error(f"update_book_search_index error: {e}")
            return False
    
    async def search_books_indexed(self, query: str, limit: int = 20) -> List[Dict]:
        """Indeks orqali kitoblarni qidirish (tezroq)"""
        try:
            query_lower = query.lower()
            
            async with self.connect() as db:
                cursor = await db.execute('''
                    SELECT b.id, b.code, b.caption, b.author, b.genre, b.downloads
                    FROM books b
                    JOIN book_search_index bsi ON b.id = bsi.book_id
                    WHERE bsi.search_text LIKE ?
                    AND b.is_active = 1
                    ORDER BY b.downloads DESC
                    LIMIT ?
                ''', (f'%{query_lower}%', limit))
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"search_books_indexed error: {e}")
            return []
    
    async def is_banned(self, user_id: int) -> bool:
        """Foydalanuvchi ban qilinganmi tekshirish"""
        try:
            async with self.connect() as db:
                # banned_users jadvalini yaratish (agar yo'q bo'lsa)
                try:
                    await db.execute('''
                        CREATE TABLE IF NOT EXISTS banned_users (
                            user_id INTEGER PRIMARY KEY,
                            reason TEXT,
                            banned_by INTEGER,
                            banned_at TEXT DEFAULT CURRENT_TIMESTAMP
                        )
                    ''')
                except Exception:
                    pass
                
                cursor = await db.execute('SELECT user_id FROM banned_users WHERE user_id = ?', (user_id,))
                return await cursor.fetchone() is not None
        except Exception as e:
            logger.error(f"is_banned error: {e}")
            return False
    
    # -------------------------------------------------------------------------
    # AI CONVERSATION METHODS
    # -------------------------------------------------------------------------
    
    async def save_ai_conversation(self, user_id: int, message: str, response: str, tokens_used: int = 0, conversation_id: str = None) -> bool:
        """AI suhbatini saqlash"""
        try:
            async with self.connect() as db:
                # ai_conversations jadvalini yaratish
                try:
                    await db.execute('''
                        CREATE TABLE IF NOT EXISTS ai_conversations (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            user_id INTEGER,
                            conversation_id TEXT,
                            message TEXT,
                            response TEXT,
                            tokens_used INTEGER DEFAULT 0,
                            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (user_id) REFERENCES users(user_id)
                        )
                    ''')
                except Exception:
                    pass
                
                if not conversation_id:
                    conversation_id = f"conv_{user_id}_{int(time.time())}"
                
                await db.execute('''
                    INSERT INTO ai_conversations (user_id, conversation_id, message, response, tokens_used)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, conversation_id, message, response, tokens_used))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"save_ai_conversation error: {e}")
            return False
    
    async def get_ai_conversations(self, user_id: int, limit: int = 10) -> List[Dict]:
        """AI suhbatlarini olish"""
        try:
            async with self.connect() as db:
                try:
                    cursor = await db.execute('''
                        SELECT * FROM ai_conversations 
                        WHERE user_id = ? 
                        ORDER BY timestamp DESC 
                        LIMIT ?
                    ''', (user_id, limit))
                    rows = await cursor.fetchall()
                    return [dict(row) for row in rows]
                except Exception:
                    return []  # Jadval mavjud emas
        except Exception as e:
            logger.error(f"get_ai_conversations error: {e}")
            return []
    
    async def get_user_chat_state(self, user_id: int) -> Optional[str]:
        """Foydalanuvchi chat holatini olish"""
        try:
            async with self.connect() as db:
                try:
                    cursor = await db.execute('SELECT chat_state FROM users WHERE user_id = ?', (user_id,))
                    row = await cursor.fetchone()
                    return row[0] if row and row[0] else None
                except Exception:
                    return None
        except Exception as e:
            logger.error(f"get_user_chat_state error: {e}")
            return None
    
    async def set_user_chat_state(self, user_id: int, state: str) -> bool:
        """Foydalanuvchi chat holatini o'rnatish"""
        try:
            async with self.connect() as db:
                # chat_state ustunini qo'shish (agar yo'q bo'lsa)
                try:
                    await db.execute('ALTER TABLE users ADD COLUMN chat_state TEXT')
                except Exception:
                    pass
                
                await db.execute('UPDATE users SET chat_state = ? WHERE user_id = ?', (state, user_id))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"set_user_chat_state error: {e}")
            return False
    
    async def clear_user_chat_state(self, user_id: int) -> bool:
        """Foydalanuvchi chat holatini tozalash"""
        try:
            async with self.connect() as db:
                await db.execute('UPDATE users SET chat_state = NULL WHERE user_id = ?', (user_id,))
                await db.commit()
                return True
        except Exception as e:
            logger.error(f"clear_user_chat_state error: {e}")
            return False

# =============================================================================
#                              RATE LIMITING
# =============================================================================
# Spam himoyasi - Token bucket algoritmi asosida rate limiting.
# Har bir user uchun so'rovlar sonini cheklash.
# =============================================================================

class RateLimiter:
    """Rate limiting tizimi - spam himoyasi"""
    
    def __init__(self, max_requests: int = 10, window: int = 60):
        self.max_requests = max_requests
        self.window = window
        self.requests = {}  # {user_id: [timestamps]}
    
    def is_allowed(self, user_id: int) -> bool:
        """Foydalanuvchi so'rov yubora oladimi tekshirish"""
        now = time.time()
        
        # Eski so'rovlarni tozalash
        if user_id in self.requests:
            self.requests[user_id] = [
                ts for ts in self.requests[user_id]
                if now - ts < self.window
            ]
        else:
            self.requests[user_id] = []
        
        # So'rovlar sonini tekshirish
        if len(self.requests[user_id]) >= self.max_requests:
            return False
        
        # Yangi so'rov qo'shish
        self.requests[user_id].append(now)
        return True
    
    def get_remaining(self, user_id: int) -> int:
        """Qolgan so'rovlar soni"""
        now = time.time()
        if user_id in self.requests:
            self.requests[user_id] = [
                ts for ts in self.requests[user_id]
                if now - ts < self.window
            ]
            return max(0, self.max_requests - len(self.requests[user_id]))
        return self.max_requests

# =============================================================================
# COMMAND ANALYTICS
# =============================================================================

class CommandAnalytics:
    """Komanda analytics tizimi"""
    
    def __init__(self):
        self.commands = {}  # {command: count}
        self.user_commands = {}  # {user_id: {command: count}}
        self.start_time = time.time()
    
    def track_command(self, user_id: int, command: str):
        """Komandani kuzatish"""
        # Global statistika
        self.commands[command] = self.commands.get(command, 0) + 1
        
        # Foydalanuvchi statistika
        if user_id not in self.user_commands:
            self.user_commands[user_id] = {}
        self.user_commands[user_id][command] = self.user_commands[user_id].get(command, 0) + 1
    
    def get_stats(self) -> Dict:
        """Umumiy statistika"""
        uptime = time.time() - self.start_time
        return {
            'total_commands': sum(self.commands.values()),
            'unique_commands': len(self.commands),
            'top_commands': sorted(self.commands.items(), key=lambda x: x[1], reverse=True)[:10],
            'active_users': len(self.user_commands),
            'uptime_seconds': int(uptime)
        }
    
    def get_user_stats(self, user_id: int) -> Dict:
        """Foydalanuvchi statistika"""
        if user_id not in self.user_commands:
            return {'total': 0, 'commands': {}}
        return {
            'total': sum(self.user_commands[user_id].values()),
            'commands': self.user_commands[user_id]
        }

# =============================================================================
# PREMIUM AUTO-COLLECT XP BACKGROUND WORKER
# =============================================================================

async def premium_auto_collect_worker(bot: Bot, db_manager: DatabaseManager):
    """Premium foydalanuvchilarga har soatda avtomatik XP berish"""
    logger.info("Premium auto-collect worker ishga tushirildi")
    
    while True:
        try:
            # Har soatda ishga tushadi
            await asyncio.sleep(3600)  # 1 soat = 3600 sekund
            
            # Premium foydalanuvchilarni olish
            premium_users = await db_manager.get_premium_users_for_autocollect()
            
            if not premium_users:
                logger.info("Premium auto-collect: Premium foydalanuvchilar yo'q")
                continue
            
            # Har bir Premium foydalanuvchiga XP berish
            for user in premium_users:
                user_id = user['user_id']
                subscription_type = user.get('subscription_type', 0)
                
                # Subscription type bo'yicha XP miqdori (narxga moslashtirilgan)
                # Premium narxi: 24,990 so'm (30 kun) = 720 soat
                # Har soatda 15 XP: 720 * 15 = 10,800 XP (mantiqiy - Premium narxiga mos)
                # Exclusive narxi: 34,990 so'm (30 kun) = 720 soat  
                # Har soatda 20 XP: 720 * 20 = 14,400 XP (mantiqiy - Exclusive narxiga mos)
                # Hisob-kitob: Premium narxi 24,990 so'm, 30 kunda 10,800 XP = har XP ~2.3 so'm
                # Exclusive narxi 34,990 so'm, 30 kunda 14,400 XP = har XP ~2.4 so'm
                xp_amounts = {
                    2: 20,   # Exclusive (34,990 so'm) - 20 XP/soat = 14,400 XP/30 kun
                    3: 25,   # Exclusive Pro+ - 25 XP/soat
                    4: 18,   # PRO - 18 XP/soat
                    5: 15    # Premium (24,990 so'm) - 15 XP/soat = 10,800 XP/30 kun
                }
                
                xp_amount = xp_amounts.get(subscription_type, 15)
                
                # XP berish
                success = await db_manager.premium_auto_collect_xp(user_id, xp_amount)
                
                if success:
                    logger.info(f"Premium auto-collect: user_id={user_id}, xp={xp_amount}, type={subscription_type}")
                    
                    # Notification yuborish (ixtiyoriy)
                    try:
                        await bot.send_message(
                            user_id,
                            f"ðŸ’Ž <b>Premium Auto-Collect</b>\n\n"
                            f"Sizga avtomatik <b>{xp_amount} XP</b> berildi!\n\n"
                            f"ðŸ’° Jami XP: {user.get('xp', 0) + xp_amount:,}",
                            parse_mode=ParseMode.HTML
                        )
                    except Exception as e:
                        logger.debug(f"Premium auto-collect notification error: {e}")
            
            logger.info(f"Premium auto-collect: {len(premium_users)} ta foydalanuvchiga XP berildi")
        
        except Exception as e:
            logger.error(f"Premium auto-collect worker error: {e}", exc_info=True)
            await asyncio.sleep(60)  # Xatolik bo'lsa, 1 daqiqa kutib qayta urinish

# =============================================================================
# TRIAL EXPIRY CHECKER BACKGROUND WORKER
# =============================================================================

async def trial_expiry_checker_worker(bot: Bot, db_manager: DatabaseManager):
    """Har bir necha daqiqada 1 soatlik trial tugashlarini tekshirish"""
    logger.info("Trial expiry checker worker ishga tushirildi (1 soatlik trial uchun)")
    
    while True:
        try:
            # Tugagan trial'larni tekshirish
            expired_trials = await db_manager.check_trial_expiry()
            
            for user in expired_trials:
                user_id = user['user_id']
                
                # Trial'ni tugat
                success = await db_manager.expire_trial(user_id)
                
                if success:
                    logger.info(f"Trial tugadi: user_id={user_id}")
                    
                    # Notification yuborish
                    try:
                        await bot.send_message(
                            user_id,
                            f"â° <b>Trial muddati tugadi</b>\n\n"
                            f"Sizning 1 soatlik trial muddatingiz tugadi.\n\n"
                            f"ðŸ’Ž Premium obuna olish uchun /premium buyrug'ini yuboring yoki 'Premium' tugmasini bosing.\n\n"
                            f"ðŸ“Š Premium afzalliklari:\n"
                            f"  â€¢ Cheksiz yuklab olish\n"
                            f"  â€¢ Premium kitoblar va filmlar\n"
                            f"  â€¢ Audio kitoblar\n"
                            f"  â€¢ Har soatda avtomatik XP\n"
                            f"  â€¢ AI Mentor cheksiz",
                            parse_mode=ParseMode.HTML
                        )
                    except Exception as e:
                        logger.debug(f"Trial expiry notification error: {e}")
            
            if expired_trials:
                logger.info(f"Trial expiry: {len(expired_trials)} ta trial tugadi")
            
            # Yaqin 15 daqiqada tugaydigan trial'lar uchun ogohlantirish
            ending_soon = await db_manager.get_trial_ending_soon(minutes=15)
            
            for user in ending_soon:
                user_id = user['user_id']
                trial_ends_at = user.get('trial_ends_at', '')
                
                try:
                    await bot.send_message(
                        user_id,
                        f"â° <b>Trial muddati tugayapti!</b>\n\n"
                        f"Sizning trial muddatingiz 15 daqiqa ichida tugaydi.\n"
                        f"ðŸ“… Tugash vaqti: {trial_ends_at[:16] if trial_ends_at else 'N/A'}\n\n"
                        f"ðŸ’Ž Premium obuna olish uchun /premium buyrug'ini yuboring.",
                        parse_mode=ParseMode.HTML
                    )
                    logger.info(f"Trial ending soon notification: user_id={user_id}")
                except Exception as e:
                    logger.debug(f"Trial ending soon notification error: {e}")
            
            if ending_soon:
                logger.info(f"Trial ending soon: {len(ending_soon)} ta foydalanuvchiga ogohlantirish yuborildi")
            
            await asyncio.sleep(300)  # Har 5 daqiqada tekshirish
        
        except Exception as e:
            logger.error(f"Trial expiry checker worker error: {e}", exc_info=True)
            await asyncio.sleep(60)  # Xatolik bo'lsa, 1 daqiqa kutib qayta urinish

# =============================================================================
#                    MINING FARM REMINDER WORKER (LAZY)
# =============================================================================
# Mining XP lazy calculation - har safar user so'raganda hisoblanadi.
# Bu worker faqat 24+ soat yig'magan Premium userlarga reminder yuboradi.
# Mass UPDATE operatsiyalari yo'q - database load minimal.
# =============================================================================

async def mining_farm_auto_collect_worker(bot: Bot, db_manager: DatabaseManager):
    """Mining farm reminder worker - faqat uzoq vaqt yig'magan userlarga eslatma yuboradi
    
    LAZY CALCULATION: XP hisoblash get_mining_farm() da on-demand qilinadi.
    Bu worker FAQAT 24+ soat yig'magan Premium userlarga reminder yuboradi.
    Har soatda barcha farmlarni process qilish o'rniga, faqat notification yuboriladi.
    """
    logger.info("Mining farm reminder worker ishga tushirildi (lazy calculation)")
    
    while True:
        try:
            # Har 6 soatda ishga tushadi (har soat emas!)
            await asyncio.sleep(21600)  # 6 soat = 21600 sekund
            
            # Faqat 24+ soat yig'magan Premium foydalanuvchilarni olish
            async with db_manager.connect() as conn:
                cursor = await conn.execute('''
                    SELECT mf.user_id, mf.level, mf.xp_per_hour, u.full_name, u.subscription_type
                    FROM mining_farms mf
                    JOIN users u ON mf.user_id = u.user_id
                    WHERE datetime(mf.last_collected) < datetime('now', '-24 hours')
                    AND u.subscription_type > 0
                    AND u.is_banned = 0
                    LIMIT 50
                ''')
                inactive_farms = await cursor.fetchall()
            
            if not inactive_farms:
                logger.debug("Mining reminder: Reminder yuborish kerak bo'lgan farm yo'q")
                continue
            
            reminder_count = 0
            for farm_row in inactive_farms:
                farm = dict(farm_row)
                user_id = farm['user_id']
                
                # Kutilayotgan XP ni hisoblash (lazy - DB ga yozmasdan)
                pending_xp = farm.get('xp_per_hour', 10) * 24  # Minimum 24 soat
                
                try:
                    await bot.send_message(
                        user_id,
                        f"â›ï¸ <b>Mining Farm Eslatmasi</b>\n\n"
                        f"Sizning mining farmingizda <b>{pending_xp:,}+ XP</b> kutmoqda!\n\n"
                        f"ðŸ­ Farm level: {farm.get('level', 1)}\n"
                        f"âš¡ XP/soat: {farm.get('xp_per_hour', 10)}\n\n"
                        f"ðŸ’¡ XP ni yig'ish uchun Mining menyusiga o'ting!",
                        parse_mode=ParseMode.HTML
                    )
                    reminder_count += 1
                except Exception as e:
                    logger.debug(f"Mining reminder notification error: {e}")
            
            if reminder_count > 0:
                logger.info(f"Mining reminder: {reminder_count} ta Premium foydalanuvchiga eslatma yuborildi")
        
        except Exception as e:
            logger.error(f"Mining farm reminder worker error: {e}", exc_info=True)
            await asyncio.sleep(300)  # Xatolik bo'lsa, 5 daqiqa kutib qayta urinish

# =============================================================================
#                    LEADERBOARD RESET WORKER
# =============================================================================
# Haftalik va oylik XP reset qilish va top foydalanuvchilarga mukofot berish.
# Dushanba kuni 00:00 da haftalik, Oyning 1-kuni 00:00 da oylik reset.
# =============================================================================

async def leaderboard_reset_worker(bot: Bot, db_manager: DatabaseManager):
    """Leaderboard reset worker - haftalik/oylik XP reset va mukofotlar"""
    logger.info("Leaderboard reset worker ishga tushirildi")
    
    last_weekly_reset = None
    last_monthly_reset = None
    
    while True:
        try:
            await asyncio.sleep(3600)  # Har soatda tekshirish
            
            now = datetime.now()
            
            # Haftalik reset - Dushanba kuni (weekday=0)
            if now.weekday() == 0 and now.hour == 0:
                today_str = now.strftime("%Y-%m-%d")
                if last_weekly_reset != today_str:
                    logger.info("Haftalik leaderboard reset boshlanmoqda...")
                    
                    # Top 10 foydalanuvchilarni olish va mukofot berish
                    top_users = await db_manager.get_leaderboard("weekly", 10)
                    
                    rewards = {
                        1: {'xp': 500, 'gold': 50},
                        2: {'xp': 300, 'gold': 30},
                        3: {'xp': 200, 'gold': 20},
                        4: {'xp': 100, 'gold': 10},
                        5: {'xp': 80, 'gold': 8},
                        6: {'xp': 60, 'gold': 6},
                        7: {'xp': 50, 'gold': 5},
                        8: {'xp': 40, 'gold': 4},
                        9: {'xp': 30, 'gold': 3},
                        10: {'xp': 20, 'gold': 2}
                    }
                    
                    for i, user in enumerate(top_users, 1):
                        user_id = user['user_id']
                        reward = rewards.get(i, {'xp': 10, 'gold': 1})
                        
                        # Mukofot berish
                        await db_manager.add_xp_with_leaderboard(user_id, reward['xp'])
                        await db_manager.add_gold(user_id, reward['gold'], f"Haftalik leaderboard #{i}")
                        
                        # Notification yuborish
                        try:
                            medals = {1: "ðŸ¥‡", 2: "ðŸ¥ˆ", 3: "ðŸ¥‰"}
                            medal = medals.get(i, f"#{i}")
                            await bot.send_message(
                                user_id,
                                f"ðŸ† <b>HAFTALIK LEADERBOARD NATIJASI!</b>\n\n"
                                f"{medal} Siz <b>{i}-o'rin</b>ni egallangiz!\n\n"
                                f"ðŸŽ <b>Mukofotlar:</b>\n"
                                f"â­ +{reward['xp']} XP\n"
                                f"ðŸª™ +{reward['gold']} Gold\n\n"
                                f"Tabriklaymiz! ðŸŽ‰",
                                parse_mode=ParseMode.HTML
                            )
                        except Exception as e:
                            logger.debug(f"Weekly leaderboard notification error: {e}")
                    
                    # Haftalik XP reset
                    await db_manager.reset_weekly_xp()
                    last_weekly_reset = today_str
                    logger.info(f"Haftalik leaderboard reset tugadi. {len(top_users)} ta foydalanuvchiga mukofot berildi.")
            
            # Oylik reset - Oyning 1-kuni
            if now.day == 1 and now.hour == 0:
                month_str = now.strftime("%Y-%m")
                if last_monthly_reset != month_str:
                    logger.info("Oylik leaderboard reset boshlanmoqda...")
                    
                    # Top 10 foydalanuvchilarni olish va mukofot berish
                    top_users = await db_manager.get_leaderboard("monthly", 10)
                    
                    rewards = {
                        1: {'xp': 2000, 'gold': 200},
                        2: {'xp': 1200, 'gold': 120},
                        3: {'xp': 800, 'gold': 80},
                        4: {'xp': 400, 'gold': 40},
                        5: {'xp': 320, 'gold': 32},
                        6: {'xp': 240, 'gold': 24},
                        7: {'xp': 200, 'gold': 20},
                        8: {'xp': 160, 'gold': 16},
                        9: {'xp': 120, 'gold': 12},
                        10: {'xp': 80, 'gold': 8}
                    }
                    
                    for i, user in enumerate(top_users, 1):
                        user_id = user['user_id']
                        reward = rewards.get(i, {'xp': 50, 'gold': 5})
                        
                        # Mukofot berish
                        await db_manager.add_xp_with_leaderboard(user_id, reward['xp'])
                        await db_manager.add_gold(user_id, reward['gold'], f"Oylik leaderboard #{i}")
                        
                        # Notification yuborish
                        try:
                            medals = {1: "ðŸ¥‡", 2: "ðŸ¥ˆ", 3: "ðŸ¥‰"}
                            medal = medals.get(i, f"#{i}")
                            await bot.send_message(
                                user_id,
                                f"ðŸ† <b>OYLIK LEADERBOARD NATIJASI!</b>\n\n"
                                f"{medal} Siz <b>{i}-o'rin</b>ni egallangiz!\n\n"
                                f"ðŸŽ <b>Mukofotlar:</b>\n"
                                f"â­ +{reward['xp']} XP\n"
                                f"ðŸª™ +{reward['gold']} Gold\n\n"
                                f"Ajoyib natija! ðŸŽ‰",
                                parse_mode=ParseMode.HTML
                            )
                        except Exception as e:
                            logger.debug(f"Monthly leaderboard notification error: {e}")
                    
                    # Oylik XP reset
                    await db_manager.reset_monthly_xp()
                    last_monthly_reset = month_str
                    logger.info(f"Oylik leaderboard reset tugadi. {len(top_users)} ta foydalanuvchiga mukofot berildi.")
        
        except Exception as e:
            logger.error(f"Leaderboard reset worker error: {e}", exc_info=True)
            await asyncio.sleep(300)

# =============================================================================
#                    SUPABASE PAYMENT SYNC WORKER
# =============================================================================
# Web App dan (Supabase) kelgan to'lovlarni SQLite ga sinxronizatsiya qilish
# =============================================================================

async def supabase_payment_sync_worker(bot: Bot, db_manager: DatabaseManager):
    """Supabase to'lovlarini sinxronizatsiya qilish"""
    if not db_manager.supabase:
        logger.warning("Supabase client not initialized. Sync worker skipped.")
        return

    logger.info("Supabase payment sync worker ishga tushirildi")
    
    while True:
        try:
            await asyncio.sleep(60)  # Har 1 daqiqada tekshirish
            
            # Pending payments ni olish
            response = db_manager.supabase.table('payment_requests')\
                .select('*')\
                .eq('status', 'pending')\
                .execute()
            
            pending_payments = response.data
            
            if not pending_payments:
                continue
                
            for payment in pending_payments:
                payment_id = str(payment.get('id'))
                user_id = payment.get('user_id')
                plan = payment.get('plan')
                amount = payment.get('amount')
                receipt_url = payment.get('receipt_url')
                created_at = payment.get('created_at')
                
                local_payment_id = f"supa_{payment_id}"
                
                # Check if already exists in local DB
                async with db_manager.connect() as db:
                    cursor = await db.execute('SELECT 1 FROM payment_requests WHERE payment_id = ?', (local_payment_id,))
                    if await cursor.fetchone():
                        continue
                
                    # Check if user exists locally
                    user = await db_manager.get_user(user_id)
                    if not user:
                        # Insert minimal user info
                        await db.execute('''
                            INSERT OR IGNORE INTO users (user_id, full_name, username, joined_date)
                            VALUES (?, ?, ?, datetime('now'))
                        ''', (user_id, f"User {user_id}", "unknown"))
                    
                    # Insert payment request
                    await db.execute('''
                        INSERT INTO payment_requests (payment_id, user_id, plan, amount, receipt_file_id, status, created_at)
                        VALUES (?, ?, ?, ?, ?, 'pending', ?)
                    ''', (local_payment_id, user_id, plan, amount, receipt_url, created_at))
                    await db.commit()
                
                # Notify admins
                user_name = f"User {user_id}"
                user = await db_manager.get_user(user_id)
                if user:
                    user_name = user.get('full_name', user_name)
                
                await notify_admin_receipt(user_id, user_name, plan, amount, receipt_url)
                logger.info(f"Synced payment from Supabase: {local_payment_id}")

        except Exception as e:
            logger.error(f"Supabase payment sync error: {e}")
            await asyncio.sleep(60)

# =============================================================================
#                        OPENAI GPT-4 INTEGRATSIYA
# =============================================================================
# AI Mentor funksiyasi uchun OpenAI API integratsiyasi.
# GPT-4 model, ko'p tillilik, rate limiting.
# =============================================================================

async def get_openai_response(prompt: str, user_language: str = 'uz') -> str:
    """OpenAI (NexusAgent) orqali javob olish"""
    if not Config.OPENAI_API_KEY:
        return "âš ï¸ AI tizimi sozlanmagan (API Key yetishmayapti)."
    
    try:
        # Global nexus_agent dan foydalanamiz
        global nexus_agent
        if 'nexus_agent' not in globals() or nexus_agent is None:
             nexus_agent = NexusAgent(
                openai_api_key=Config.OPENAI_API_KEY,
                bing_api_key=Config.BING_SEARCH_API_KEY,
                model=Config.OPENAI_MODEL
            )
            
        # Agent orqali javob olish (Copilot integratsiyasi bilan)
        response = await nexus_agent.process_message(
            user_id=0, # Context uchun user_id kerak bo'lishi mumkin, hozircha 0
            message=prompt
        )
        return response

    except Exception as e:
        logger.error(f"AI Error: {e}")
        return "âš ï¸ Kechirasiz, xatolik yuz berdi. Keyinroq urinib ko'ring."

# =============================================================================
#                           FSM STATES
# =============================================================================
# Finite State Machine state'lari - foydalanuvchi va admin holatlari.
# Kitob/film qo'shish, qidiruv, to'lov va boshqa jarayonlar uchun.
# =============================================================================

class UserStates(StatesGroup):
    waiting_book_upload = State()
    waiting_book_genre = State()
    waiting_movie_upload = State()
    waiting_movie_file = State()
    waiting_movie_search = State()  # Kino qidiruv uchun
    waiting_course_upload = State()
    waiting_ai_question = State()
    waiting_payment_receipt = State()  # To'lov cheki yuborish
    waiting_review_rating = State()  # Sharh reytingi
    waiting_review_comment = State()  # Sharh matni
    waiting_review_text = State()  # Sharh matni (kitoblar uchun)
    waiting_podcast_search = State()  # Podcast qidiruv
    waiting_promo_code = State()  # Promo kod kiritish
    waiting_support_message = State()  # Support ticket xabari
    
    # ========== AI QUIZ MAKER STATES ==========
    waiting_quiz_topic = State()  # Quiz mavzusini kiritish
    waiting_quiz_difficulty = State()  # Qiyinlik darajasi
    waiting_quiz_count = State()  # Savollar soni
    waiting_quiz_answer = State()  # Javob kutish
    waiting_quiz_file = State()  # Fayl yuklash (PDF/DOCX)
    waiting_quiz_youtube = State()  # YouTube link
    waiting_quiz_voice_answer = State()  # Ovozli javob
    waiting_duel_opponent = State()  # Duel raqibi
    waiting_duel_answer = State()  # Duel javob
    waiting_flashcard_answer = State()  # Flashcard javob
    waiting_podcast_topic = State()  # Podcast mavzusi
    waiting_adaptive_topic = State()  # Adaptive test mavzusi
    waiting_adaptive_answer = State()  # Adaptive test javob
    waiting_mindmap_topic = State()  # Mind Map mavzusi
    waiting_course_receipt = State()  # Kurs uchun to'lov cheki

class AdminStates(StatesGroup):
    """Admin FSM state'lari"""
    waiting_add_book_file = State()
    waiting_add_movie_file = State()
    waiting_movie_quality = State()
    waiting_movie_caption = State()
    waiting_movie_name = State()  # Kino nomini so'rash
    waiting_premium_movie_name = State()  # Premium kino nomini so'rash
    waiting_movie_parts = State()  # Kino qismlarini qabul qilish (cheksiz)
    waiting_episode_movie_name = State()  # Serial nomini kiritish
    waiting_episode_file = State()  # Qism faylini yuklash
    # Admin funksiyalar uchun
    waiting_book_code_search = State()
    waiting_book_code_delete = State()
    waiting_movie_id_search = State()
    waiting_movie_id_delete = State()
    waiting_course_id_search = State()
    waiting_course_id_delete = State()
    waiting_user_id_search = State()
    waiting_user_id_xp = State()
    waiting_user_id_message = State()
    waiting_add_course_file = State()
    waiting_course_title = State()
    # Qidiruv va o'chirish
    waiting_book_code_for_delete = State()
    waiting_book_search = State()
    waiting_course_search = State()
    waiting_course_id_for_delete = State()
    waiting_user_search = State()
    waiting_movie_id_search = State()
    waiting_movie_id_delete = State()
    # User ID kutish state'lari
    waiting_user_id_for_ban = State()
    waiting_ban_reason = State()  # Bloklash sababi uchun
    waiting_user_id_for_unban = State()
    waiting_user_id_for_premium = State()
    waiting_user_id_for_remove_premium = State()  # Premium olish uchun
    waiting_user_id_for_xp = State()
    waiting_user_id_for_message = State()
    waiting_message_text = State()  # Xabar matni uchun
    waiting_user_id_for_reply = State()  # Javob yuborish uchun
    waiting_reply_text = State()  # Javob matni uchun
    waiting_user_id_for_stats = State()
    # Broadcast va xabar yuborish
    waiting_broadcast_message = State()
    waiting_broadcast_confirm = State()
    waiting_reply_user_id = State()
    waiting_reply_message = State()
    # Admin qo'shish/olib tashlash
    waiting_add_admin = State()
    waiting_remove_admin = State()
    # Karta qo'shish
    waiting_add_card = State()
    # Yangi funksiyalar
    waiting_movie_code = State()  # Kino tartib kodini so'rash
    waiting_course_for_price = State()  # Kurs narxini o'zgartirish uchun kurs qidirish (bepul qilish uchun)
    waiting_course_new_price = State()  # Kurs yangi narxini so'rash
    waiting_course_for_price_change = State()  # Kurs narxini o'zgartirish uchun kurs qidirish
    # Promo kodlar
    waiting_promo_code = State()
    waiting_promo_discount = State()
    waiting_promo_max_uses = State()
    waiting_promo_expiry = State()
    waiting_promo_valid_until = State()
    # Podcast bo'limlari
    waiting_podcast_section_name = State()
    waiting_podcast_section_description = State()
    # Qo'shimcha
    waiting_delete_movie_confirm = State()
    waiting_course_id_for_top = State()
    waiting_free_course_user = State()
    waiting_promo_data = State()
    waiting_course_id = State()
    # Audio kitoblar
    waiting_add_audio_book = State()
    waiting_add_audio_book_file = State()
    # Podcastlar
    waiting_podcast_title = State()
    waiting_podcast_description = State()
    waiting_podcast_category = State()
    waiting_podcast_language = State()
    waiting_podcast_host = State()
    waiting_podcast_file = State()
    waiting_podcast_video = State()
    waiting_podcast_video_optional = State()  # Audio podcastga video qo'shish (ixtiyoriy)
    waiting_podcast_content_type = State()
    waiting_podcast_search = State()  # Podcast qidirish
    editing_podcast_title = State()
    editing_podcast_description = State()
    editing_podcast_category = State()
    # Janr bo'yicha qo'shish
    waiting_book_genre_select = State()
    waiting_book_genre_file = State()
    waiting_movie_genre_select = State()
    waiting_movie_genre_file = State()
    waiting_course_category_select = State()
    waiting_course_category_file = State()
    waiting_movie_language = State()  # Kino tilini tanlash
    waiting_movie_genre_select = State()  # Kino janrini tanlash
    # Qismsiz kino qo'shish
    waiting_single_movie_name = State()
    waiting_single_movie_file = State()
    # Avtomatik yuborish
    waiting_auto_send_user = State()
    # Support ticket
    waiting_support_message = State()
    # Welcome video
    waiting_welcome_video = State()
    # Premium video
    waiting_premium_video = State()

# =============================================================================
#                              KEYBOARDS
# =============================================================================
# Barcha inline va reply keyboard'lar.
# Main menu, admin panel, content menus, va boshqalar.
# =============================================================================

class Keyboards:
    @staticmethod
    def main_menu(user_id: int = None) -> ReplyKeyboardMarkup:
        """Asosiy menyu (rangli va vizual) - 12 ta bo'lim (WebApp + Til)"""
        builder = ReplyKeyboardBuilder()
        # WebApp tugmasi - birinchi qatorda
        builder.button(text="ðŸš€ SuperApp", web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?user_id={user_id or 0}"))
        builder.button(text="ðŸ“š Kutubxona")
        builder.button(text="ðŸŽ¬ Kinoteatr")
        builder.button(text="ðŸŽ“ Kurslar")
        builder.button(text="ðŸŽ§ Podcastlar")
        builder.button(text="ðŸ§  AI Quiz")
        builder.button(text="ðŸ¤– AI Mentor")
        builder.button(text="ðŸŽ® Gamification")
        builder.button(text="ðŸ‘¤ Profil")
        builder.button(text="ðŸ’Ž Premium")
        builder.button(text="ðŸŒ Til / Lang")
        builder.button(text="ðŸ†• Yangi funksiyalar")
        if user_id and Config.is_admin(user_id):
            builder.button(text="âš™ï¸ Admin Panel")
        builder.adjust(1, 2, 2, 2, 2, 2, 1)  # SuperApp birinchi, keyin juftliklar
        return builder.as_markup(resize_keyboard=True)
    
    @staticmethod
    def library_menu(user_subscription: int = 0) -> InlineKeyboardMarkup:
        """Kutubxona menyusi (Premium funksiyalar bilan) - 3 QATOR!"""
        builder = InlineKeyboardBuilder()
        builder.button(text="Qidirish", callback_data="search_books")
        builder.button(text="Janrlar", callback_data="book_genres")
        builder.button(text="Top kitoblar", callback_data="top_books")
        builder.button(text="Tasodifiy kitob", callback_data="random_book")
        builder.button(text="Sevimlilarim", callback_data="my_favorites")
        builder.button(text="Mening kitoblarim", callback_data="my_books")
        
        if user_subscription >= 2:
            builder.button(text="Audio kitoblar", callback_data="audio_books")
        
        builder.button(text="Asosiy menyu", callback_data="main_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        if user_subscription >= 2:
            builder.adjust(3, 3, 1)  # 3 qator, har birida 3 ta tugma
        else:
            builder.adjust(3, 3, 1)  # 3 qator, har birida 3 ta tugma
        
        return builder.as_markup()
    
    @staticmethod
    def cinema_menu(subscription_type: int = 0) -> InlineKeyboardMarkup:
        """Kinoteatr menyusi (optimallashtirilgan, Premium funksiyalar bilan) - 3 QATOR!"""
        builder = InlineKeyboardBuilder()
        builder.button(text="Qidirish", callback_data="search_movies")
        builder.button(text="Janrlar", callback_data="movie_genres")
        builder.button(text="Top filmlar", callback_data="top_movies")
        builder.button(text="Tasodifiy film", callback_data="random_movie")
        builder.button(text="HD/4K Kinolar", callback_data="premium_movies")
        builder.button(text="Ingliz tilidagi", callback_data="english_movies")
        builder.button(text="Multfilmlar", callback_data="animation_movies")
        builder.button(text="Sevimlilarim", callback_data="my_favorites")
        builder.button(text="Film qo'shish", callback_data="user_add_movie")
        builder.button(text="Asosiy menyu", callback_data="main_menu")
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 3, 1)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def book_actions(book_code: str, is_favorite: bool = False, can_download: bool = True) -> InlineKeyboardMarkup:
        """Kitob uchun amallar (Favoritelar va Rating bilan)"""
        builder = InlineKeyboardBuilder()
        if can_download:
            builder.button(text="Yuklash", callback_data=f"download_book_{book_code}")
        if is_favorite:
            builder.button(text="Favoritelardan olib tashlash", callback_data=f"remove_favorite_book_{book_code}")
        else:
            builder.button(text="Favoritelarga qo'shish", callback_data=f"add_favorite_book_{book_code}")
        builder.button(text="Baholash", callback_data=f"rate_book_{book_code}")
        builder.button(text="Sharh qoldirish", callback_data=f"review_book_{book_code}")
        builder.button(text="Kutubxona", callback_data="library_menu")
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        if can_download:
            builder.adjust(3, 3, 1)  # 3 qator, har birida 3 ta tugma
        else:
            builder.adjust(3, 1)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def admin_menu() -> InlineKeyboardMarkup:
        """Admin panel menyusi (professional va tizimli - barcha funksiyalar)"""
        builder = InlineKeyboardBuilder()
        
        # 1. KONTENT QO'SHISH
        builder.button(text="Kitob qo'shish", callback_data="admin_add_book")
        builder.button(text="Janr bo'yicha kitoblar", callback_data="admin_add_books_by_genre")
        builder.button(text="Audio kitob qo'shish", callback_data="admin_add_audio_book")
        builder.button(text="Qismli film qo'shish", callback_data="admin_add_movie")
        builder.button(text="Qismsiz film qo'shish", callback_data="admin_add_single_movie")
        builder.button(text="Janr bo'yicha filmlar", callback_data="admin_add_movies_by_genre")
        builder.button(text="Premium film qo'shish", callback_data="admin_add_premium_movie")
        builder.button(text="Kurs qo'shish", callback_data="admin_add_course")
        builder.button(text="Kategoriya bo'yicha kurslar", callback_data="admin_add_courses_by_category")
        builder.button(text="Podcast qo'shish", callback_data="admin_add_podcast")
        
        # 2. STATISTIKA VA MONITORING
        builder.button(text="Tizim statistikasi", callback_data="admin_stats")
        builder.button(text="Analytics Dashboard", callback_data="admin_analytics_dashboard")
        builder.button(text="Foydalanuvchilar", callback_data="admin_users")
        builder.button(text="User Segmentation", callback_data="admin_user_segmentation")
        builder.button(text="Real-time stats", callback_data="admin_realtime_stats")
        builder.button(text="Revenue Analytics", callback_data="admin_revenue_analytics")
        
        # 3. KONTENT BOSHQARISH
        builder.button(text="Kitoblar", callback_data="admin_books")
        builder.button(text="Filmlar", callback_data="admin_movies")
        builder.button(text="Kurslar", callback_data="admin_courses")
        builder.button(text="Podcastlar", callback_data="admin_podcasts")
        builder.button(text="Kutilayotgan yuklamalar", callback_data="admin_pending")
        builder.button(text="Advanced Search", callback_data="admin_advanced_search")
        builder.button(text="Bulk Operations", callback_data="admin_bulk_operations")
        
        # 4. TO'LOVLAR VA MOLIYA
        builder.button(text="To'lovlar", callback_data="admin_payments")
        
        # 5. BROADCAST VA XABARLAR
        builder.button(text="Broadcast", callback_data="admin_broadcast")
        
        # 6. ADMINLAR BOSHQARUVI
        builder.button(text="Adminlar", callback_data="admin_admins")
        
        # 7. AVTOMATIK YUBORISH
        builder.button(text="Avtomatik yuborish", callback_data="admin_auto_send")
        builder.button(text="Yuborishni to'xtatish", callback_data="admin_stop_auto_send")
        
        # 8. EXPORT VA BACKUP
        builder.button(text="Excel export", callback_data="admin_export")
        builder.button(text="Backup", callback_data="admin_backup")
        
        # 9. VIDEO SOZLAMALARI
        builder.button(text="Video sozlamalari", callback_data="admin_settings")
        
        builder.button(text="Asosiy menyu", callback_data="main_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 3, 1, 3, 3, 3, 1, 1, 1, 2, 1, 2, 1, 1)  # Video sozlamalari alohida qator
        return builder.as_markup()
    
    @staticmethod
    def admin_users_menu() -> InlineKeyboardMarkup:
        """Admin foydalanuvchilarni boshqarish menyusi"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸ” Foydalanuvchi qidirish", callback_data="admin_search_user")
        builder.button(text="ðŸ“Š Foydalanuvchi statistikasi", callback_data="admin_user_stats")
        builder.button(text="ðŸŽ XP berish", callback_data="admin_give_xp")
        builder.button(text="ðŸ‘‘ Premium berish", callback_data="admin_give_premium")
        builder.button(text="âŒ Premium olish", callback_data="admin_remove_premium")
        builder.button(text="â›” Bloklash", callback_data="admin_ban_user")
        builder.button(text="âœ… Blokdan chiqarish", callback_data="admin_unban_user")
        builder.button(text="ðŸ“ Xabar yuborish", callback_data="admin_send_message")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 3)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def admin_content_menu(content_type: str) -> InlineKeyboardMarkup:
        """Admin kontent boshqarish menyusi"""
        builder = InlineKeyboardBuilder()
        
        if content_type == "books":
            builder.button(text="ðŸ“š Kitob qo'shish", callback_data="admin_add_book")
            builder.button(text="ðŸŽµ Audio kitob qo'shish", callback_data="admin_add_audio_book")
            builder.button(text="ðŸ” Kitob qidirish", callback_data="admin_search_book")
            builder.button(text="ðŸ“Š Kitob statistikasi", callback_data="admin_book_stats")
            builder.button(text="âœï¸ Kitobni tahrirlash", callback_data="admin_edit_book")
            builder.button(text="ðŸ—‘ï¸ Kitobni o'chirish", callback_data="admin_delete_book")
        
        elif content_type == "movies":
            builder.button(text="ðŸŽ¬ Standart film qo'shish", callback_data="admin_add_movie")
            builder.button(text="ðŸ’Ž Premium film qo'shish", callback_data="admin_add_premium_movie")
            builder.button(text="ðŸ“º Serial qism qo'shish", callback_data="admin_add_episode")
            builder.button(text="ðŸ” Film qidirish", callback_data="admin_search_movie")
            builder.button(text="ðŸ”¢ Tartib kod orqali yuborish", callback_data="admin_send_movie_by_code")
            builder.button(text="ðŸ“Š Film statistikasi", callback_data="admin_movie_stats")
            builder.button(text="ðŸš€ Barcha kinolarni yuklash", callback_data="admin_preload_all_movies")
            builder.button(text="ðŸ—‘ï¸ Barcha kinolarni o'chirish", callback_data="admin_delete_all_movies")
            builder.button(text="âœï¸ Filmini tahrirlash", callback_data="admin_edit_movie")
            builder.button(text="ðŸ—‘ï¸ Filmini o'chirish", callback_data="admin_delete_movie")
        
        elif content_type == "courses":
            builder.button(text="ðŸŽ“ Kurs qo'shish", callback_data="admin_add_course")
            builder.button(text="ðŸ” Kurs qidirish", callback_data="admin_search_course")
            builder.button(text="ðŸ’° Kurs narxini o'zgartirish", callback_data="admin_change_course_price")
            builder.button(text="ðŸ“Š Kurs statistikasi", callback_data="admin_course_stats")
            builder.button(text="âœï¸ Kursni tahrirlash", callback_data="admin_edit_course")
            builder.button(text="ðŸ—‘ï¸ Kursni o'chirish", callback_data="admin_delete_course")
            builder.button(text="ðŸ’° Barcha kurslar narxini 19990 ga yangilash", callback_data="admin_update_all_course_prices")
        
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        if content_type == "books":
            builder.adjust(3, 3, 1)  # 3 qator, har birida 3 ta tugma
        else:
            builder.adjust(3, 3, 1)  # 3 qator, har birida 3 ta tugma
        
        return builder.as_markup()
    
    @staticmethod
    def back_button(callback_data: str = "admin_menu") -> InlineKeyboardMarkup:
        """Orqaga tugmasi"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Orqaga", callback_data=callback_data)
        return builder.as_markup()
    
    @staticmethod
    def cancel_button() -> InlineKeyboardMarkup:
        """Bekor qilish tugmasi"""
        builder = InlineKeyboardBuilder()
        builder.button(text="âŒ Bekor qilish", callback_data="admin_menu")
        return builder.as_markup()
    
    @staticmethod
    def pending_upload_actions(upload_id: int) -> InlineKeyboardMarkup:
        """Kutilayotgan yuklama uchun amallar"""
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Tasdiqlash", callback_data=f"approve_upload_{upload_id}")
        builder.button(text="âŒ Rad etish", callback_data=f"reject_upload_{upload_id}")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 1)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def courses_menu(user_subscription: int = 0) -> InlineKeyboardMarkup:
        """Kurslar menyusi (OPTIMALLASHTIRILGAN - Marketing strategiya) - 3 QATOR!"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸ” Qidirish", callback_data="search_courses")
        builder.button(text="ðŸ“‚ Janrlar", callback_data="course_genres")
        builder.button(text="ðŸ”¥ Top kurslar", callback_data="top_courses")
        
        categories = [
            ("ðŸ’» Dasturlash", "category_programming"),
            ("ðŸ’¼ Biznes", "category_business"),
            ("ðŸŽ¨ Dizayn", "category_design"),
            ("ðŸ“ˆ Marketing", "category_marketing"),
            ("ðŸ§® Matematika", "category_math"),
            ("ðŸ”¬ Fan", "category_science"),
            ("ðŸ‘” Menejment", "category_management"),
            ("ðŸ‡ºðŸ‡¸ Ingliz tili", "category_english"),
            ("ðŸ’° Moliya", "category_finance"),
            ("ðŸ¤– Sun'iy intellekt", "category_ai")
        ]
        
        for name, callback in categories:
            builder.button(text=name, callback_data=callback)
        
        builder.button(text="ðŸ“š Mening kurslarim", callback_data="my_courses")
        builder.button(text="ðŸ¤– AI Mentor", callback_data="ai_mentor_courses")
        builder.button(text="âž• Kurs qo'shish", callback_data="user_add_course")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 3, 3, 3, 1, 1, 1)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def podcasts_menu(user_subscription: int = 0) -> InlineKeyboardMarkup:
        """Podcastlar menyusi - 3 QATOR!"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ” Qidirish", callback_data="search_podcasts")
        builder.button(text="ðŸ“‚ Kategoriyalar", callback_data="podcast_categories")
        builder.button(text="ðŸ”¥ Top podcastlar", callback_data="top_podcasts")
        builder.button(text="ðŸŽ² O'zbek podcastlar", callback_data="random_podcast_uz")
        builder.button(text="ðŸŽ² English podcasts", callback_data="random_podcast_en")
        builder.button(text="ðŸŽ¬ Video majmua", callback_data="video_podcasts")
        builder.button(text="ðŸ’ª Motivatsion", callback_data="motivational_podcasts")
        builder.button(text="â­ Sevimlilarim", callback_data="my_favorites")
        
        # Premium foydalanuvchilar uchun
        if user_subscription >= 2:
            builder.button(text="â­ Premium podcastlar", callback_data="premium_podcasts")
        
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        if user_subscription >= 2:
            builder.adjust(3, 3, 3, 1)  # 3 qator, har birida 3 ta tugma
        else:
            builder.adjust(3, 3, 2, 1)  # 3 qator, har birida 3 ta tugma
        
        return builder.as_markup()
    
    @staticmethod
    def quiz_menu(user_id: int = None, streak: int = 0) -> InlineKeyboardMarkup:
        """AI Quiz Maker menyusi - Barcha funksiyalar (Killer Features bilan)"""
        builder = InlineKeyboardBuilder()
        
        # Asosiy funksiyalar - 1 TA TUGMAGA JAMLANGAN
        builder.button(text="ðŸŽ¯ AI Test Yaratish", callback_data="quiz_ai_test")
        
        # KILLER FEATURES
        builder.button(text="ðŸ§›â€â™‚ï¸ RPG Tizimi", callback_data="quiz_rpg")
        builder.button(text="âš¡ Live Battle", callback_data="quiz_live_battle")
        builder.button(text="ðŸ§  Mind Map", callback_data="quiz_mindmap")
        
        # Geymifikatsiya
        builder.button(text=f"ðŸ”¥ Streak: {streak} kun", callback_data="quiz_streak")
        builder.button(text="âš”ï¸ Duel rejimi", callback_data="quiz_duel")
        builder.button(text="ðŸ† Reyting", callback_data="quiz_leaderboard")
        
        # O'rganish
        builder.button(text="ðŸ” Takrorlash (SRS)", callback_data="quiz_srs_review")
        builder.button(text="âŒ Xatolarim", callback_data="quiz_mistakes")
        builder.button(text="ðŸ“‡ Flashcards", callback_data="quiz_flashcards")
        
        # Statistika
        builder.button(text="ðŸ“Š Statistika", callback_data="quiz_stats")
        builder.button(text="ðŸŽ“ Sertifikatlarim", callback_data="quiz_certificates")
        builder.button(text="ðŸ“š Mening testlarim", callback_data="quiz_my_quizzes")
        
        # Do'koni
        builder.button(text="ðŸ›’ Oltin do'koni", callback_data="gold_shop")
        
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        
        builder.adjust(1, 3, 3, 3, 3, 1, 1)
        return builder.as_markup()
    
    @staticmethod
    def quiz_difficulty_menu() -> InlineKeyboardMarkup:
        """Test qiyinlik darajasi tanlash"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŸ¢ Oson", callback_data="quiz_diff_easy")
        builder.button(text="ðŸŸ¡ O'rta", callback_data="quiz_diff_medium")
        builder.button(text="ðŸ”´ Qiyin", callback_data="quiz_diff_hard")
        builder.button(text="ðŸ”™ Orqaga", callback_data="quiz_menu")
        builder.adjust(3, 1)
        return builder.as_markup()
    
    @staticmethod
    def quiz_count_menu() -> InlineKeyboardMarkup:
        """Savollar sonini tanlash"""
        builder = InlineKeyboardBuilder()
        builder.button(text="5ï¸âƒ£ 5 ta", callback_data="quiz_count_5")
        builder.button(text="ðŸ”Ÿ 10 ta", callback_data="quiz_count_10")
        builder.button(text="1ï¸âƒ£5ï¸âƒ£ 15 ta", callback_data="quiz_count_15")
        builder.button(text="2ï¸âƒ£0ï¸âƒ£ 20 ta", callback_data="quiz_count_20")
        builder.button(text="ðŸ”™ Orqaga", callback_data="quiz_menu")
        builder.adjust(2, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def quiz_answer_keyboard(options: list, question_index: int, adaptive: bool = False, show_hints: bool = True) -> InlineKeyboardMarkup:
        """Test javob variantlari (RPG hint/50-50 bilan)"""
        builder = InlineKeyboardBuilder()
        labels = ['A', 'B', 'C', 'D']
        for i, option in enumerate(options[:4]):
            callback = f"adaptive_ans_{question_index}_{i}" if adaptive else f"quiz_ans_{question_index}_{i}"
            builder.button(text=f"{labels[i]}. {option[:50]}", callback_data=callback)
        
        if show_hints and not adaptive:
            builder.button(text="ðŸ’¡ Hint", callback_data=f"use_hint_{question_index}")
            builder.button(text="ðŸŽ¯ 50/50", callback_data=f"use_fifty_{question_index}")
        
        builder.button(text="â­ï¸ O'tkazib yuborish", callback_data=f"quiz_skip_{question_index}")
        builder.button(text="âŒ Testni tugatish", callback_data="quiz_end")
        
        if show_hints and not adaptive:
            builder.adjust(1, 1, 1, 1, 2, 2)
        else:
            builder.adjust(1, 1, 1, 1, 2)
        return builder.as_markup()
    
    @staticmethod
    def quiz_result_keyboard(quiz_id: int, score: int) -> InlineKeyboardMarkup:
        """Test natijasi tugmalari"""
        builder = InlineKeyboardBuilder()
        if score >= 90:
            builder.button(text="ðŸŽ“ Sertifikat olish", callback_data=f"quiz_certificate_{quiz_id}")
        builder.button(text="ðŸ’¡ Xatolarni ko'rish", callback_data=f"quiz_review_{quiz_id}")
        builder.button(text="ðŸ” Qayta ishlash", callback_data=f"quiz_retry_{quiz_id}")
        builder.button(text="ðŸ“¤ Baham ko'rish", callback_data=f"quiz_share_{quiz_id}")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1, 2, 2)
        return builder.as_markup()
    
    @staticmethod
    def quiz_categories_menu() -> InlineKeyboardMarkup:
        """Quiz kategoriyalari"""
        builder = InlineKeyboardBuilder()
        categories = [
            ("ðŸ“š Adabiyot", "qcat_adabiyot"),
            ("ðŸ”¬ Fan", "qcat_fan"),
            ("ðŸŒ Tarix", "qcat_tarix"),
            ("ðŸ’¼ Biznes", "qcat_biznes"),
            ("ðŸ§  Psixologiya", "qcat_psixologiya"),
            ("ðŸ’» Dasturlash", "qcat_dasturlash"),
            ("ðŸ‡¬ðŸ‡§ Ingliz tili", "qcat_english"),
            ("ðŸŽ“ Umumiy bilim", "qcat_umumiy"),
            ("ðŸŽ¬ Kino", "qcat_kino"),
            ("âš½ Sport", "qcat_sport")
        ]
        for name, callback in categories:
            builder.button(text=name, callback_data=callback)
        builder.button(text="ðŸ”™ Orqaga", callback_data="quiz_menu")
        builder.adjust(2, 2, 2, 2, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def duel_menu() -> InlineKeyboardMarkup:
        """Duel menyusi"""
        builder = InlineKeyboardBuilder()
        builder.button(text="âš”ï¸ Tasodifiy raqib", callback_data="duel_random")
        builder.button(text="ðŸ‘¥ Do'stni taklif qilish", callback_data="duel_invite")
        builder.button(text="ðŸ“‹ Faol duellar", callback_data="duel_active")
        builder.button(text="ðŸ† Duel tarixi", callback_data="duel_history")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(2, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def market_menu(user_xp: int = 0) -> InlineKeyboardMarkup:
        """Market menyusi (MARKETING STRATEGIYA) - 3 QATOR!"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸŽ ðŸ’Ž Premium tariflar", callback_data="market_premium")
        builder.button(text="â›ï¸ âš¡ Mining uskunalari", callback_data="market_mining")
        builder.button(text="ðŸŽ° ðŸŽ² Fortune Wheel", callback_data="fortune_wheel")
        builder.button(text="ðŸŽ ðŸŽ« Promo kodlar", callback_data="use_promo_code")
        builder.button(text="ðŸ’° ðŸ“Š XP tarixi", callback_data="my_xp")
        builder.button(text="ðŸ† ðŸ¥‡ Leaderboard", callback_data="leaderboard")
        builder.button(text=f"ðŸ’Ž ðŸ’° XP: {user_xp:,}", callback_data="my_xp")
        builder.button(text="ðŸ”™ â¬…ï¸ Asosiy menyu", callback_data="main_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 2)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def market_premium_menu(user_xp: int = 0) -> InlineKeyboardMarkup:
        """Marketdagi premium tariflar (MARKETING)"""
        builder = InlineKeyboardBuilder()
        
        items = [
            (f"1ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[1]:,} XP", "buy_premium_1"),
            (f"3ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[3]:,} XP", "buy_premium_3"),
            (f"7ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[7]:,} XP", "buy_premium_7"),
            (f"1ï¸âƒ£5ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[15]:,} XP", "buy_premium_15"),
            (f"3ï¸âƒ£0ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[30]:,} XP", "buy_premium_30"),
            (f"ðŸ”¥ PRO (30 kun) - {Config.MARKET_PRICES[31]:,} XP", "buy_premium_31")
        ]
        
        for name, callback in items:
            builder.button(text=name, callback_data=callback)
        
        builder.button(text="ðŸ’³ To'lov orqali Premium", callback_data="premium_menu")
        builder.button(text="ðŸ”™ Market", callback_data="market_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 2)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def premium_menu() -> InlineKeyboardMarkup:
        """Premium obuna menyusi (rangli va vizual)"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸ’Ž â­ Premium - 29,990 so'm", callback_data="premium_premium")
        builder.button(text="ðŸ† ðŸ‘‘ Exclusive - 47,990 so'm", callback_data="premium_exclusive")
        builder.button(text="ðŸ’³ ðŸ’° To'lov usullari", callback_data="payment_methods")
        builder.button(text="ðŸ›’ ðŸŽ XP evaziga Premium", callback_data="market_premium")
        builder.button(text="ðŸ”™ â¬…ï¸ Orqaga", callback_data="main_menu")
        
        builder.adjust(1, 1, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def help_menu() -> InlineKeyboardMarkup:
        """Yordam va support menyusi"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸ“š ðŸ“– Qo'llanma", callback_data="user_guide")
        builder.button(text="ðŸ”§ ðŸ› ï¸ Troubleshooter", callback_data="troubleshooter")
        builder.button(text="ðŸŽ« ðŸ’¬ Support ticket", callback_data="support_ticket")
        builder.button(text="ðŸ‘¨â€ðŸ’¼ ðŸ“ž Admin bilan bog'lanish", url=f"https://t.me/{Config.SUPPORT_USERNAME.replace('@', '')}")
        builder.button(text="ðŸ”™ â¬…ï¸ Asosiy menyu", callback_data="main_menu")
        
        builder.adjust(1, 2, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def ai_menu(user_ai_limit: int = 0, user_subscription: int = 0) -> InlineKeyboardMarkup:
        """AI Mentor menyusi (OPTIMALLASHTIRILGAN)"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text=f"ðŸ’¬ Savol berish (Qoldiq: {user_ai_limit})", callback_data="ask_ai")
        builder.button(text="ðŸ“œ Avvalgi suhbatlar", callback_data="ai_history")
        builder.button(text="â„¹ï¸ AI haqida ma'lumot", callback_data="ai_info")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        
        builder.adjust(1, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def course_actions(course_id: int) -> InlineKeyboardMarkup:
        """Kurs uchun amallar"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¥ Yuklash", callback_data=f"download_course_{course_id}")
        builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 1)  # 3 qator, har birida 3 ta tugma
        return builder.as_markup()
    
    @staticmethod
    def profile_menu(user_data: Dict) -> InlineKeyboardMarkup:
        """Shaxsiy kabinet menyusi (10 ta bo'lim) - 3 QATOR!"""
        builder = InlineKeyboardBuilder()
        
        subscription_name = DatabaseManager.get_subscription_name(user_data.get('subscription_type', 0))
        xp = user_data.get('xp', 0)
        streak = user_data.get('streak_count', 0)
        
        # 1-3: XP, Streak, Subscription
        builder.button(text=f"ðŸ’° XP: {xp:,}", callback_data="profile_xp")
        builder.button(text=f"ðŸ”¥ Streak: {streak} kun", callback_data="profile_streak")
        builder.button(text=f"ðŸ‘‘ {subscription_name}", callback_data="profile_subscription")
        
        # 4-6: Bonus, Dashboard, Yutuqlar
        builder.button(text="ðŸŽ Kunlik bonus", callback_data="daily_bonus")
        builder.button(text="ðŸ“Š Dashboard", callback_data="my_dashboard")
        builder.button(text="ðŸ† Yutuqlar", callback_data="my_achievements")
        
        # 7: Statistika
        builder.button(text="ðŸ“ˆ Statistika", callback_data="my_stats")
        
        # 8-9: AI takliflar, Yordam
        builder.button(text="ðŸ’¡ AI takliflar", callback_data="smart_recommendations")
        builder.button(text="ðŸ†˜ Yordam & Support", callback_data="help_menu")
        
        # 3 QATOR - MAKSIMAL QIZIQARLI!
        builder.adjust(3, 3, 1, 2)  # 3 qator, har birida 3 ta tugma, keyin 1 ta va 2 ta qator
        return builder.as_markup()
    
    @staticmethod
    def help_menu() -> InlineKeyboardMarkup:
        """Yordam va support menyusi"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸ“š Qo'llanma", callback_data="user_guide")
        builder.button(text="ðŸ”§ Troubleshooter", callback_data="troubleshooter")
        builder.button(text="ðŸŽ« Support ticket", callback_data="support_ticket")
        builder.button(text="ðŸ‘¨â€ðŸ’¼ Admin bilan bog'lanish", url="https://t.me/iultimatium")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        
        builder.adjust(1, 2, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def mining_menu() -> InlineKeyboardMarkup:
        """Mining fermasi menyusi"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ’° Reward yig'ish", callback_data="collect_mining")
        builder.button(text="â¬†ï¸ Upgrade qilish", callback_data="upgrade_mining")
        builder.button(text="ðŸ“Š Statistika", callback_data="mining_stats")
        builder.button(text="ðŸ”™ Orqaga", callback_data="stats_menu")
        builder.adjust(1, 1, 1, 1)
        return builder.as_markup()
    
    @staticmethod
    def stats_menu() -> InlineKeyboardMarkup:
        """Statistika menyusi"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“Š Mening statistikam", callback_data="my_stats")
        builder.button(text="ðŸ† Reyting jadvali", callback_data="rating_table")
        builder.button(text="â›ï¸ Mining", callback_data="mining_menu")
        builder.button(text="âš”ï¸ Duel", callback_data="duel")
        builder.button(text="ðŸ… Ligalar", callback_data="leagues")
        builder.button(text="ðŸ”™ Orqaga", callback_data="profile_back")
        builder.adjust(1, 1, 2, 1, 1)
        return builder.as_markup()
    
    @staticmethod
    def bonus_menu() -> InlineKeyboardMarkup:
        """Bonus menyusi"""
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ Kunlik bonus", callback_data="daily_bonus")
        builder.button(text="â›ï¸ Mining", callback_data="mining_menu")
        builder.button(text="ðŸ”™ Orqaga", callback_data="profile_back")
        builder.adjust(1, 1, 1)
        return builder.as_markup()
    
    @staticmethod
    def premium_menu() -> InlineKeyboardMarkup:
        """Premium obuna menyusi (3 ta tarif)"""
        builder = InlineKeyboardBuilder()
        
        builder.button(text="ðŸ’Ž Premium - 29,990 so'm", callback_data="premium_premium")
        builder.button(text="ðŸ† Exclusive - 47,990 so'm", callback_data="premium_exclusive")
        builder.button(text="ðŸ”¥ Excl. Pro+ (1 kun) - 9,990 so'm", callback_data="premium_exclusive_pro_plus_1")
        
        builder.button(text="ðŸ’³ To'lov usullari", callback_data="payment_methods")
        builder.button(text="ðŸ›’ XP evaziga Premium", callback_data="market_premium")
        builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
        
        builder.adjust(1, 1, 1, 2, 1)
        return builder.as_markup()
    
    @staticmethod
    def payment_methods_menu() -> InlineKeyboardMarkup:
        """To'lov usullari menyusi (faqat Humo va Uzcard)"""
        builder = InlineKeyboardBuilder()
        
        # Faqat Humo va Uzcard
        methods = [
            ("ðŸ’³ HUMO", "payment_humo"),
            ("ðŸ’³ Uzcard", "payment_uzcard")
        ]
        
        for name, callback in methods:
            builder.button(text=name, callback_data=callback)
        
        builder.button(text="ðŸ”™ Orqaga", callback_data="premium_menu")
        
        builder.adjust(2, 1)
        return builder.as_markup()
    
    @staticmethod
    def market_premium_menu(user_xp: int = 0) -> InlineKeyboardMarkup:
        """Marketdagi premium tariflar"""
        builder = InlineKeyboardBuilder()
        
        items = [
            (f"1ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[1]} XP", "buy_premium_1"),
            (f"3ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[3]} XP", "buy_premium_3"),
            (f"7ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[7]} XP", "buy_premium_7"),
            (f"1ï¸âƒ£5ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[15]} XP", "buy_premium_15"),
            (f"3ï¸âƒ£0ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[30]} XP", "buy_premium_30"),
            (f"ðŸ”¥ PRO (30 kun) - {Config.MARKET_PRICES[31]} XP", "buy_premium_31")
        ]
        
        for name, callback in items:
            builder.button(text=name, callback_data=callback)
        
        builder.button(text="ðŸ’³ To'lov orqali Premium", callback_data="premium_menu")
        builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
        
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1)
        return builder.as_markup()

# =============================================================================
# GLOBAL O'ZGARUVCHILAR
# =============================================================================

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

async def check_is_admin(user_id: int, db_manager: DatabaseManager) -> bool:
    """Admin tekshiruvi (Config va Database)"""
    # Avval Config'dan tekshirish (tezkor)
    if Config.is_admin(user_id):
        return True
    # Keyin Database'dan tekshirish (qo'shilgan adminlar uchun)
    try:
        async with db_manager.connect() as conn:
            cursor = await conn.execute('SELECT 1 FROM admin_users WHERE user_id = ?', (user_id,))
            return await cursor.fetchone() is not None
    except Exception as e:
        logger.error(f"check_is_admin error: {e}")
        return False

# =============================================================================
# ROUTER
# =============================================================================

router = Router()
# =============================================================================
# AUTO-GENERATED HANDLER STUBS (DO NOT REMOVE)
# These stubs make sure every Telegram update type is captured and logged.
# =============================================================================

@router.chat_member()
async def handle_chat_member(update: ChatMemberUpdated):
    logger.info("chat_member event: %s", update.model_dump())


@router.my_chat_member()
async def handle_my_chat_member(update: ChatMemberUpdated):
    logger.info("my_chat_member event: %s", update.model_dump())


@router.chat_join_request()
async def handle_chat_join_request(update: ChatJoinRequest):
    logger.info("chat_join_request: %s", update.model_dump())
    try:
        await bot.approve_chat_join_request(update.chat.id, update.from_user.id)
    except Exception as exc:
        logger.warning("Failed to auto-approve join request: %s", exc)


@router.channel_post()
async def handle_channel_post(message: Message):
    logger.info("channel_post from %s: %s", message.chat.id, message.message_id)


@router.edited_message()
async def handle_edited_message(message: Message):
    logger.info("edited_message from %s: %s", message.chat.id, message.message_id)


@router.edited_channel_post()
async def handle_edited_channel_post(message: Message):
    logger.info("edited_channel_post from %s: %s", message.chat.id, message.message_id)


@router.inline_query()
async def handle_inline_query(query: InlineQuery):
    logger.info("inline_query from %s", query.from_user.id)


@router.chosen_inline_result()
async def handle_chosen_inline_result(result: ChosenInlineResult):
    logger.info("chosen_inline_result from %s", result.from_user.id)


@router.shipping_query()
async def handle_shipping_query(query: ShippingQuery):
    logger.info("shipping_query from %s", query.from_user.id)
    await bot.answer_shipping_query(query.id, ok=False, error_message="Shipping is not supported yet.")


@router.pre_checkout_query()
async def handle_pre_checkout_query(query: PreCheckoutQuery):
    logger.info("pre_checkout_query from %s", query.from_user.id)
    await bot.answer_pre_checkout_query(query.id, ok=False, error_message="Payments are temporarily disabled.")


@router.poll()
async def handle_poll(poll: Poll):
    logger.info("poll update received: %s", poll.id)


@router.poll_answer()
async def handle_poll_answer(answer: PollAnswer):
    logger.info("poll_answer from %s", answer.user.id)

bot: Bot = None
dp: Dispatcher = None
db: DatabaseManager = None
rate_limiter = RateLimiter(max_requests=Config.RATE_LIMIT_REQUESTS, window=Config.RATE_LIMIT_WINDOW)
analytics = CommandAnalytics()

# Avtomatik yuborish o'zgaruvchilari
auto_send_running = False  # Avtomatik yuborish ishlamoqdamimi?
auto_send_task = None  # Background task
auto_send_target_user_id = None  # Qaysi foydalanuvchiga yuborilmoqda

# =============================================================================
#                         MESSAGE HANDLERS
# =============================================================================
# Foydalanuvchi xabarlari va komandalarini qayta ishlash.
# /start, /language, main menu, va boshqa handlerlar.
# =============================================================================

@router.message(Command("language"))
@router.message(Command("lang"))
async def handle_language_command(message: Message):
    """Tilni o'zgartirish komandasi"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    current_lang = await db.get_user_language(user_id) if user else 'uz'
    
    # Til tanlash menyusini yuborish
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="lang_uz")
    builder.button(text="ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹", callback_data="lang_ru")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="lang_en")
    builder.adjust(1, 1, 1)
    
    if current_lang == 'uz':
        text = "ðŸŒ <b>TILNI TANLANG</b>\n\nHozirgi til: ðŸ‡ºðŸ‡¿ O'zbek tili\n\nQuyidagilardan birini tanlang:"
    elif current_lang == 'ru':
        text = "ðŸŒ <b>Ð’Ð«Ð‘Ð•Ð Ð˜Ð¢Ð• Ð¯Ð—Ð«Ðš</b>\n\nÐ¢ÐµÐºÑƒÑ‰Ð¸Ð¹ ÑÐ·Ñ‹Ðº: ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹\n\nÐ’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð²:"
    else:  # en
        text = "ðŸŒ <b>SELECT LANGUAGE</b>\n\nCurrent language: ðŸ‡¬ðŸ‡§ English\n\nSelect one of the options:"
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(CommandStart())
async def handle_start(message: Message):
    """Start komandasi (ko'p tillilik bilan)"""
    user_id = message.from_user.id
    full_name = message.from_user.full_name
    username = message.from_user.username
    
    if message.chat.type in ["group", "supergroup"]:
        logger.info(f"Group message received in {message.chat.id}")
        bot_info = await message.bot.get_me()
        
        await message.answer(
            f"ðŸ‘‹ <b>Salom, {full_name}!</b>\n\n"
            f"ðŸ¤– <b>Nexus Media Bot</b> guruhda ham ishlaydi!\n\n"
            f"ðŸŽ¯ /quiz - Test menyu\n"
            f"ðŸ“š /book [nom] - Kitob qidirish\n"
            f"ðŸŽ¬ /movie [nom] - Kino qidirish\n"
            f"ðŸ“¤ /share - Testni ulashish\n"
            f"âš¡ /live_battle - Guruhda o'yin\n\n"
            f"ðŸ“± To'liq WebApp funksiyalari uchun shaxsiy chatga o'ting: @{bot_info.username}",
            parse_mode=ParseMode.HTML
        )
        return
    
    # Deep link parametrlarini tekshirish
    args = message.text.split(maxsplit=1)
    if len(args) > 1:
        param = args[1]
        
        # Foydalanuvchi mavjudligini tekshirish (referral uchun)
        existing_user = await db.get_user(user_id)
        is_new_user = existing_user is None
        
        # Foydalanuvchini ro'yxatdan o'tkazish
        await db.add_user(user_id, full_name, username)
        await db.update_user_activity(user_id)
        
        # Referral link orqali kelgan
        if param.startswith("ref_") and is_new_user:
            try:
                referrer_id = int(param.replace("ref_", ""))
                if referrer_id != user_id:  # O'ziga o'zi referral bo'lmasin
                    bonus = await db.add_referral_bonus(referrer_id, user_id)
                    if bonus > 0:
                        # Referrer ga xabar yuborish
                        try:
                            await bot.send_message(
                                referrer_id,
                                f"ðŸŽ‰ <b>Yangi referral!</b>\n\n"
                                f"ðŸ‘¤ {full_name or username} sizning havolangiz orqali qo'shildi!\n"
                                f"ðŸ’Ž <b>Bonus:</b> +{bonus} XP\n\n"
                                f"ðŸ“Š Jami referrallar: {(await db.get_user(referrer_id)).get('referral_count', 0)}",
                                parse_mode=ParseMode.HTML
                            )
                        except Exception:
                            pass
                        
                        # Yangi foydalanuvchiga xabar
                        await message.answer(
                            f"ðŸŽ‰ <b>Xush kelibsiz!</b>\n\n"
                            f"Siz do'stingiz taklifi orqali qo'shildingiz!\n"
                            f"ðŸ’Ž <b>Bonus:</b> +25 XP\n\n"
                            f"ðŸ† Quyidagi bo'limlardan birini tanlang:",
                            reply_markup=Keyboards.main_menu(user_id),
                            parse_mode=ParseMode.HTML
                        )
                        return
            except ValueError:
                pass
        
        # Quiz link orqali kelgan
        if param.startswith("quiz_"):
            quiz_id = param.replace("quiz_", "")
            
            async with db.connect() as conn:
                cursor = await conn.execute(
                    'SELECT title, category, total_questions FROM quizzes WHERE id = ?',
                    (quiz_id,)
                )
                quiz = await cursor.fetchone()
            
            if quiz:
                title, category, total = quiz
                text = f"""
ðŸŽ¯ <b>TESTGA XUSH KELIBSIZ!</b>

ðŸ“ <b>Test:</b> {title}
ðŸ“‚ <b>Kategoriya:</b> {category or 'Umumiy'}
â“ <b>Savollar:</b> {total} ta

Testni boshlash uchun tugmani bosing:
                """
                builder = InlineKeyboardBuilder()
                builder.button(text="â–¶ï¸ Testni boshlash", callback_data=f"play_quiz_{quiz_id}")
                builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
                builder.adjust(1)
                
                await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            else:
                await message.answer("âŒ Test topilmadi!", reply_markup=Keyboards.main_menu(user_id))
            return
        
        # Kino link orqali kelgan
        if param.startswith("movie_"):
            movie_id = param.replace("movie_", "")
            
            async with db.connect() as conn:
                cursor = await conn.execute(
                    'SELECT id, title, description, genre, year, rating, poster_file_id, video_file_id FROM movies WHERE id = ?',
                    (movie_id,)
                )
                movie = await cursor.fetchone()
            
            if movie:
                movie_id, title, description, genre, year, rating, poster_id, video_id = movie
                
                text = f"""
ðŸŽ¬ <b>{title}</b>

ðŸ“‚ <b>Janr:</b> {genre or 'Noma\'lum'}
ðŸ“… <b>Yil:</b> {year or 'Noma\'lum'}
â­ <b>Reyting:</b> {rating or 'N/A'}

ðŸ“ {description or 'Tavsif mavjud emas'}
                """
                
                builder = InlineKeyboardBuilder()
                if video_id:
                    builder.button(text="â–¶ï¸ Kinoni ko'rish", callback_data=f"watch_movie_{movie_id}")
                builder.button(text="ðŸ“¤ Ulashish", callback_data=f"share_movie_{movie_id}")
                builder.button(text="ðŸŽ¬ Kinoteatr", callback_data="cinema_menu")
                builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
                builder.adjust(1)
                
                if poster_id:
                    await message.answer_photo(
                        photo=poster_id,
                        caption=text,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            else:
                await message.answer("âŒ Kino topilmadi!", reply_markup=Keyboards.main_menu(user_id))
            return
        
        # Kitob link orqali kelgan
        if param.startswith("book_"):
            book_id = param.replace("book_", "")
            
            async with db.connect() as conn:
                cursor = await conn.execute(
                    'SELECT id, caption, author, description, genre, cover_file_id, file_id FROM books WHERE id = ?',
                    (book_id,)
                )
                book = await cursor.fetchone()
            
            if book:
                book_id, caption, author, description, genre, cover_id, file_id = book
                title = caption or 'Nomsiz kitob'
                
                text = f"""
ðŸ“š <b>{title}</b>

ðŸ‘¤ <b>Muallif:</b> {author or 'Noma\'lum'}
ðŸ“‚ <b>Janr:</b> {genre or 'Noma\'lum'}

ðŸ“ {description or 'Tavsif mavjud emas'}
                """
                
                builder = InlineKeyboardBuilder()
                if file_id:
                    builder.button(text="ðŸ“¥ Yuklab olish", callback_data=f"download_book_{book_id}")
                builder.button(text="ðŸ“¤ Ulashish", callback_data=f"share_book_{book_id}")
                builder.button(text="ðŸ“š Kutubxona", callback_data="library_menu")
                builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
                builder.adjust(1)
                
                if cover_id:
                    await message.answer_photo(
                        photo=cover_id,
                        caption=text,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            else:
                await message.answer("âŒ Kitob topilmadi!", reply_markup=Keyboards.main_menu(user_id))
            return
    
    # Rate limiting tekshirish
    if not rate_limiter.is_allowed(user_id):
        remaining = rate_limiter.get_remaining(user_id)
        await message.answer(f"Juda ko'p so'rov yuborildi. {remaining} soniyadan keyin urinib ko'ring.")
        return
    
    # Analytics
    analytics.track_command(user_id, "start")
    
    # Foydalanuvchi mavjudligini tekshirish
    existing_user = await db.get_user(user_id)
    is_new_user = existing_user is None
    
    await db.add_user(user_id, full_name, username)
    await db.update_user_activity(user_id)
    
    # Foydalanuvchi tilini olish
    user_lang = await db.get_user_language(user_id)
    
    # Til tanlash (agar birinchi marta bo'lsa)
    if user_lang == 'uz' and (not message.text or message.text == '/start'):
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="lang_uz")
        builder.button(text="ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹", callback_data="lang_ru")
        builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="lang_en")
        builder.adjust(3)
        
        await message.answer(
            Translations.get('select_language', user_lang),
            reply_markup=builder.as_markup()
        )
        return
    
    # Barcha foydalanuvchilar uchun asosiy menyu
    if not is_new_user:
        # Kunlik streak bonusini tekshirish
        streak_result = await db.check_and_update_streak(user_id)
        
        welcome_text = f"ðŸ‘‹ <b>Xush kelibsiz, {full_name or username}!</b>\n\n"
        
        # Streak bonus xabari
        if streak_result.get('new_streak') and streak_result.get('bonus', 0) > 0:
            streak = streak_result['streak']
            bonus = streak_result['bonus']
            
            if streak_result.get('milestone'):
                # Maxsus milestone
                welcome_text += f"ðŸŽ‰ <b>TABRIKLAYMIZ!</b> {streak} kunlik streak!\n"
                welcome_text += f"ðŸ”¥ <b>Streak:</b> {streak} kun ðŸ”¥\n"
                welcome_text += f"ðŸ’Ž <b>Bonus:</b> +{bonus} XP\n\n"
            else:
                welcome_text += f"ðŸ”¥ <b>Streak:</b> {streak} kun | +{bonus} XP\n\n"
        
        welcome_text += f"ðŸ† <b>Quyidagi bo'limlardan birini tanlang:</b>"
        
        await message.answer(
            welcome_text,
            reply_markup=Keyboards.main_menu(user_id),
            parse_mode=ParseMode.HTML
        )
        return
    
    # Welcome video til tanlagandan keyin ko'rsatiladi (handle_language_selection funksiyasida)
    # Bu yerda faqat qisqa xabar (agar til allaqachon tanlangan bo'lsa)
    
    # Trial taklif welcome videoda ko'rsatiladi (video caption'ida tugmalar bor)
    # Eski trial taklif funksiyasi olib tashlandi - endi faqat welcome videoda

@router.message(F.text.in_(["ðŸŒ Til / Lang", "Til", "Lang", "/lang"]))
async def handle_language_menu(message: Message):
    """Til o'zgartirish menyusi"""
    text = """
ðŸŒ <b>TIL SOZLAMALARI</b>

Quyidagi tillardan birini tanlang:
Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· ÑÐ·Ñ‹ÐºÐ¾Ð²:
Select one of the languages:
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="set_lang_uz")
    builder.button(text="ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹", callback_data="set_lang_ru")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="set_lang_en")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(F.text.in_(["ðŸŽ§ Podcastlar", "Podcastlar"]))
async def handle_podcasts(message: Message):
    """Podcastlar bo'limi"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "podcasts")
    
    subscription_type = user.get('subscription_type', 0)
    
    text = """<b>PODCASTLAR</b>

<b>Eng yaxshi podcastlar</b>
Turli mavzulardagi audio materiallar
Biznes, texnologiya, motivatsiya va boshqalar

<b>Maslahat:</b> Premium obuna bilan cheksiz podcastlar.

Bo'limlardan birini tanlang:"""
    
    await message.answer(text, reply_markup=Keyboards.podcasts_menu(subscription_type), parse_mode=ParseMode.HTML)

@router.message(F.text.in_(["ðŸ§  AI Quiz", "AI Quiz"]))
async def handle_ai_quiz_menu(message: Message):
    """AI Quiz bo'limi - Pastki menyu orqali"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "ai_quiz")
    
    # Streak olish
    streak = 0
    try:
        async with db.connect() as conn:
            cursor = await conn.execute(
                'SELECT current_streak FROM quiz_streaks WHERE user_id = ?',
                (user_id,)
            )
            row = await cursor.fetchone()
            if row:
                streak = row[0] or 0
    except:
        pass
    
    text = f"""
ðŸ§  <b>AI QUIZ MAKER</b>

<b>Shaxsiy AI Repetitor va Bilim Ekotizimi</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ”¥ <b>Streak:</b> {streak} kun
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>Asosiy funksiyalar:</b>
â€¢ ðŸŽ¯ Mavzudan test yaratish
â€¢ ðŸ“„ PDF/DOCX fayldan test
â€¢ ðŸŽ§ Podcast Mode (audio o'rganish)
â€¢ ðŸ“ˆ Adaptive Test (moslashuvchan)
â€¢ ðŸ§›â€â™‚ï¸ RPG Tizimi (level, oltin)
â€¢ âš¡ Live Battle (guruhda o'ynash)
â€¢ ðŸ§  Mind Map yaratish

<b>Qo'shimcha:</b>
â€¢ âš”ï¸ Duel rejimi
â€¢ ðŸ” SRS takrorlash
â€¢ ðŸŽ“ Sertifikatlar

Quyidagi tugmalardan birini tanlang:
    """
    
    await message.answer(text, reply_markup=Keyboards.quiz_menu(user_id, streak), parse_mode=ParseMode.HTML)

@router.message(F.text.in_(["ðŸ“š Kutubxona", "Kutubxona"]))
async def handle_library(message: Message):
    """Kutubxona bo'limi (Premium funksiyalar bilan)"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    subscription_type = user.get('subscription_type', 0) if user else 0
    
    text = "<b>Kutubxona</b>\n\nBo'limlardan birini tanlang:"
    await message.answer(text, reply_markup=Keyboards.library_menu(subscription_type), parse_mode=ParseMode.HTML)

@router.message(F.text.in_(["ðŸŽ¬ Kinoteatr", "Kinoteatr"]))
async def handle_cinema(message: Message):
    """Kinoteatr bo'limi (optimallashtirilgan)"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "cinema")
    
    menu_text = f"""
<b>KINOTEATR</b>

<b>Status:</b> {DatabaseManager.get_subscription_name(user.get('subscription_type', 0))}
<b>Filmlar:</b> 500+ turkum
<b>Sifatlar:</b> 480p â€¢ 720p â€¢ 1080p â€¢ 4K

<b>Cheklovlar:</b>
â€¢ Bepul: 5 ta kunlik (480p)
â€¢ Exclusive: cheksiz (720p+)
â€¢ Pro: premium sifat (1080p/4K)

<b>Qidirish:</b>
â€¢ 14+ janr
â€¢ Sifat, yil, reyting bo'yicha
â€¢ Top filmlar

<b>Maslahat:</b> Premium obuna bilan yuqori sifatli filmlarni tomosha qiling.

Tanlang:
    """
    
    await message.answer(menu_text, reply_markup=Keyboards.cinema_menu(user.get('subscription_type', 0)), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "cinema_menu")
async def handle_cinema_menu(callback: CallbackQuery):
    """Kinoteatr menyusi callback"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    menu_text = f"""
<b>KINOTEATR</b>

<b>Status:</b> {DatabaseManager.get_subscription_name(user.get('subscription_type', 0))}
<b>Filmlar:</b> 500+ turkum
<b>Sifatlar:</b> 480p â€¢ 720p â€¢ 1080p â€¢ 4K

<b>Cheklovlar:</b>
â€¢ Bepul: 5 ta kunlik (480p)
â€¢ Exclusive: cheksiz (720p+)
â€¢ Pro: premium sifat (1080p/4K)

<b>Qidirish:</b>
â€¢ 14+ janr
â€¢ Sifat, yil, reyting bo'yicha
â€¢ Top filmlar

<b>Maslahat:</b> Premium obuna bilan yuqori sifatli filmlarni tomosha qiling.

Tanlang:
    """
    
    await safe_edit_text(callback, menu_text, reply_markup=Keyboards.cinema_menu(user.get('subscription_type', 0)))
    await callback.answer()

@router.callback_query(F.data == "search_movies")
async def handle_search_movies(callback: CallbackQuery, state: FSMContext):
    """Kino qidiruv (optimallashtirilgan)"""
    user_id = callback.from_user.id
    analytics.track_command(user_id, "search_movies")
    
    await callback.message.edit_text(
        "<b>KINO QIDIRUV</b>\n\n"
        "Film nomi, rejissor yoki janr bo'yicha qidiring:\n\n"
        "<i>Masalan:</i>\n"
        "<code>Avatar</code>\n"
        "<code>Avengers</code>\n"
        "<code>Komediya</code>\n\n"
        "<b>Kino kodini yozish orqali ham topishingiz mumkin:</b>\n"
        "â€¢ <b>1-10 gacha raqamlar:</b> Kino kodini yozing (masalan: <code>1</code>, <code>5</code>)\n"
        "â€¢ <b>Tartib raqam:</b> 10 dan yuqori raqamlar tartib raqam bo'yicha qidiriladi\n\n"
        "Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()
    
    await state.set_state(UserStates.waiting_movie_search)
    await callback.answer()

@router.message(UserStates.waiting_movie_search)
async def handle_movie_search_query(message: Message, state: FSMContext):
    """Kino qidiruv so'rovini qabul qilish (KO'RISH/YUKLAB OLISH FUNKSIYASI BILAN)"""
    user_id = message.from_user.id
    query = message.text.strip()
    
    # Bot tugmalari uchun state'ni tozalash
    if query in ["Admin Panel", "Admin panel", "ADMIN PANEL", "Kutubxona", "Kinoteatr", "Kurslar", "Podkastlar", "Market", "Profil", "Premium", "Yangi funksiyalar", "AI Mentor", "Yordam", "Takliflar", "Referal", "Asosiy menyu"]:
        await state.clear()
        return  # Boshqa handlerlar ushlab oladi
    
    if query == "/cancel":
        await state.clear()
        await message.answer("Qidiruv bekor qilindi.", reply_markup=Keyboards.main_menu(user_id))
        return
    
    if len(query) < 2:
        await message.answer("Qidiruv so'zi juda qisqa! Kamida 2 belgi bo'lishi kerak.")
        await state.clear()
        return
    
    await message.answer(
        f"ðŸ” <b>Qidirilmoqda:</b> {query}\n\n"
        "â³ Iltimos, kuting...",
        reply_markup=ReplyKeyboardRemove()
    )
    
    # Avval kino kodini tekshirish (tartib raqam bo'yicha ham)
    movie = None
    movies = []
    
    try:
        # Agar raqam bo'lsa, avval kod bo'yicha qidirish (1-10 gacha)
        if query.isdigit():
            code_num = int(query)
            
            # 1. Avval movie_codes jadvalidan kod bo'yicha qidirish
            async with db.connect() as conn:
                try:
                    cursor = await conn.execute('''
                        SELECT m.* FROM movies m
                        JOIN movie_codes mc ON m.id = mc.movie_id
                        WHERE mc.code = ? AND m.is_active = 1 
                        AND (m.status = "approved" OR m.status IS NULL)
                        LIMIT 1
                    ''', (str(code_num),))
                    row = await cursor.fetchone()
                    if row:
                        movie = dict(row)
                        logger.info(f"Kino kod bo'yicha topildi: {code_num}")
                except Exception as e:
                    logger.debug(f"Movie codes qidiruv xatosi: {e}")
                    pass
            
            # 2. Agar kod bo'yicha topilmasa, tartib raqam bo'yicha qidirish
            if not movie:
                async with db.connect() as conn:
                    cursor = await conn.execute('''
                        SELECT * FROM movies 
                        WHERE order_number = ? AND is_active = 1 
                        AND (status = "approved" OR status IS NULL)
                        LIMIT 1
                    ''', (code_num,))
                    row = await cursor.fetchone()
                    if row:
                        movie = dict(row)
                        logger.info(f"Kino tartib raqam bo'yicha topildi: {code_num}")
        else:
            # 3. Agar raqam emas bo'lsa, kod bo'yicha qidirish (harfli kodlar)
            movie = await db.get_movie_by_code(query.upper())
            if movie:
                logger.info(f"Kino kod bo'yicha topildi: {query.upper()}")
    except Exception as e:
        logger.error(f"Kino qidiruv xatosi: {e}")
        pass
    
    # Agar kod bo'yicha ham topilmasa, oddiy qidiruv
    if not movie:
        movies = await db.search_movies(query, limit=100)  # Barcha natijalarni olish
    else:
        movies = [movie]
    
    # Pagination - 10 tadan ko'rsatish
    page = 0
    items_per_page = 10
    total_pages = (len(movies) + items_per_page - 1) // items_per_page if movies else 0
    
    if not movies:
        results_text = f"<b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
        results_text += "Ma'lumotlar bazasida natija topilmadi.\n\n"
        results_text += "<b>Maslahat:</b>\n"
        results_text += "â€¢ Film nomini to'liq yozing\n"
        results_text += "â€¢ Kino kodini yozib ko'ring\n"
        results_text += "â€¢ Tartib raqamini yozib ko'ring (1, 2, 3...)\n"
        results_text += "â€¢ Janr bo'yicha qidiring\n"
    else:
        results_text = f"<b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
        results_text += f"Topilgan: {len(movies)} ta\n"
        results_text += f"Sahifa: {page + 1}/{total_pages}\n\n"
        
        # Faqat joriy sahifadagi natijalarni ko'rsatish
        start_idx = page * items_per_page
        end_idx = start_idx + items_per_page
        current_movies = movies[start_idx:end_idx]
        
        for i, movie in enumerate(current_movies, start_idx + 1):
            results_text += f"{i}. <b>{movie.get('caption', 'Noma\'lum')}</b>\n"
            if movie.get('order_number'):
                results_text += f"   Tartib: {movie.get('order_number')}\n"
            if movie.get('year'):
                results_text += f"   {movie.get('year')} yil\n"
            if movie.get('rating'):
                results_text += f"   Reyting: {movie.get('rating', 0)}/10\n"
            if movie.get('quality'):
                results_text += f"   Sifat: {movie.get('quality', 'N/A')}\n"
            results_text += "\n"
        
        # State'ga saqlash (pagination uchun)
        await state.update_data(
            search_query=query,
            search_results=movies,
            search_type="movies",
            current_page=page,
            total_pages=total_pages
        )
    
    builder = InlineKeyboardBuilder()
    
    if movies and len(movies) > 0:
        # Faqat joriy sahifadagi filmlar uchun tugmalar
        for movie in current_movies:
            movie_title = movie.get('caption', 'Noma\'lum')[:30] + "..." if len(movie.get('caption', '')) > 30 else movie.get('caption', 'Noma\'lum')
            builder.button(text=movie_title, callback_data=f"watch_movie_{movie.get('id', '')}")
        
        # Pagination tugmalari
        if total_pages > 1:
            pagination_row = []
            if page > 0:
                pagination_row.append(InlineKeyboardButton(text="Orqaga", callback_data=f"search_page_movies_{page - 1}"))
            if page < total_pages - 1:
                pagination_row.append(InlineKeyboardButton(text="Keyingi", callback_data=f"search_page_movies_{page + 1}"))
            if pagination_row:
                builder.row(*pagination_row)
    
    builder.button(text="Qayta qidirish", callback_data="search_movies")
    builder.button(text="Kinoteatr", callback_data="cinema_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if movies:
        if len(current_movies) <= 5:
            builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
        else:
            builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(2, 1)
    
    await message.answer(results_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    # State ni saqlab qo'yish (pagination uchun)

# -------------------------------------------------------------------------
# PAGINATION HANDLERS
# -------------------------------------------------------------------------

@router.callback_query(F.data.startswith("search_page_movies_"))
async def handle_search_page_movies(callback: CallbackQuery, state: FSMContext):
    """Kino qidiruv natijalari pagination"""
    page = int(callback.data.replace("search_page_movies_", ""))
    user_id = callback.from_user.id
    
    # State'dan ma'lumotlarni olish
    data = await state.get_data()
    movies = data.get('search_results', [])
    query = data.get('search_query', '')
    
    if not movies:
        await callback.answer("Ma'lumotlar topilmadi!", show_alert=True)
        return
    
    items_per_page = 10
    total_pages = (len(movies) + items_per_page - 1) // items_per_page if movies else 0
    
    if page < 0 or page >= total_pages:
        await callback.answer("Noto'g'ri sahifa!", show_alert=True)
        return
    
    # Joriy sahifa ma'lumotlari
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_movies = movies[start_idx:end_idx]
    
    results_text = f"<b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    results_text += f"Topilgan: {len(movies)} ta\n"
    results_text += f"Sahifa: {page + 1}/{total_pages}\n\n"
    
    for i, movie in enumerate(current_movies, start_idx + 1):
        results_text += f"{i}. <b>{movie.get('caption', 'Noma\'lum')}</b>\n"
        if movie.get('order_number'):
            results_text += f"   Tartib: {movie.get('order_number')}\n"
        if movie.get('year'):
            results_text += f"   {movie.get('year')} yil\n"
        if movie.get('rating'):
            results_text += f"   Reyting: {movie.get('rating', 0)}/10\n"
        if movie.get('quality'):
            results_text += f"   Sifat: {movie.get('quality', 'N/A')}\n"
        results_text += "\n"
    
    # State'ni yangilash
    await state.update_data(current_page=page)
    
    builder = InlineKeyboardBuilder()
    
    # Filmlar uchun tugmalar
    for movie in current_movies:
        movie_title = movie.get('caption', 'Noma\'lum')[:30] + "..." if len(movie.get('caption', '')) > 30 else movie.get('caption', 'Noma\'lum')
        builder.button(text=movie_title, callback_data=f"watch_movie_{movie.get('id', '')}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton(text="Orqaga", callback_data=f"search_page_movies_{page - 1}"))
        
        # Sahifa raqamlari (faqat 5 ta ko'rsatish)
        if total_pages <= 5:
            for p in range(total_pages):
                if p != page:
                    pagination_row.append(InlineKeyboardButton(text=str(p + 1), callback_data=f"search_page_movies_{p}"))
        else:
            # Ko'p sahifalar bo'lsa, faqat yaqin sahifalarni ko'rsatish
            start_page = max(0, page - 2)
            end_page = min(total_pages, page + 3)
            for p in range(start_page, end_page):
                if p != page:
                    pagination_row.append(InlineKeyboardButton(text=str(p + 1), callback_data=f"search_page_movies_{p}"))
        
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton(text="Keyingi", callback_data=f"search_page_movies_{page + 1}"))
        
        if pagination_row:
            builder.row(*pagination_row[:5])  # Bir qatorda maksimal 5 ta tugma
    
    builder.button(text="Qayta qidirish", callback_data="search_movies")
    builder.button(text="Kinoteatr", callback_data="cinema_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    # Tugmalarni tartiblash
    if len(current_movies) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await callback.message.edit_text(results_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

# ========== JANRLAR HANDLER'LARI ==========

@router.callback_query(F.data == "book_genres")
async def handle_book_genres(callback: CallbackQuery):
    """Kitoblar janrlari (eng ko'p ko'riladigan va boshqalar)"""
    user_id = callback.from_user.id
    
    # Bazadan barcha mavjud janrlarni olish (eng ko'p ko'riladiganlar birinchi)
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT genre, COUNT(*) as count,
                   SUM(COALESCE(downloads, 0)) as total_downloads
            FROM books 
            WHERE is_active = 1 AND genre IS NOT NULL AND genre != ''
            GROUP BY genre
            ORDER BY total_downloads DESC, count DESC
            LIMIT 30
        ''')
        genres = await cursor.fetchall()
    
    if not genres:
        await safe_edit_text(callback,
            "<b>KITOBLAR JANRLARI</b>\n\n"
            "Hozircha janrlar mavjud emas.\n\n"
            "Adminlar kitoblar qo'shganda janrlar avtomatik aniqlanadi.",
            reply_markup=Keyboards.back_button("library_menu")
        )
        await callback.answer()
        return
    
    # Eng ko'p ko'riladigan 10 ta janr
    top_genres = genres[:10]
    other_genres = genres[10:]
    
    text = "<b>KITOBLAR JANRLARI</b>\n\n"
    text += "<b>Eng ko'p ko'riladigan janrlar:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for genre_row in top_genres:
        genre = genre_row[0] or "Boshqa"
        genre_clean = remove_emoji(genre)
        count = genre_row[1] or 0
        downloads = genre_row[2] or 0
        text += f"{genre_clean} ({count} ta, {downloads} yuklash)\n"  # Textdan emoji olib tashlandi
        builder.button(text=genre_clean, callback_data=f"genre_books_{genre}_0")  # Button textda emoji yo'q (page 0 bilan boshlaymiz)
    
    if other_genres:
        text += f"\n<b>Boshqa janrlar ({len(other_genres)} ta):</b>\n\n"
        for genre_row in other_genres[:10]:
            genre = genre_row[0] or "Boshqa"
            genre_clean = remove_emoji(genre)
            count = genre_row[1] or 0
            text += f"{genre_clean} ({count} ta)\n"  # Textdan emoji olib tashlandi
            builder.button(text=genre_clean, callback_data=f"genre_books_{genre}_0")  # Button textda emoji yo'q (page 0 bilan boshlaymiz)
    
    builder.button(text="Kutubxona", callback_data="library_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "movie_genres")
async def handle_movie_genres(callback: CallbackQuery):
    """Filmlar janrlari (eng ko'p ko'riladigan va boshqalar) - Multfilmlar va Ingliz tilidagi kinolar bilan"""
    user_id = callback.from_user.id
    
    # Bazadan barcha mavjud janrlarni olish (eng ko'p ko'riladiganlar birinchi)
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT genre, COUNT(*) as count,
                   SUM(COALESCE(downloads, 0)) as total_downloads
            FROM movies 
            WHERE is_active = 1 AND genre IS NOT NULL AND genre != ''
            GROUP BY genre
            ORDER BY total_downloads DESC, count DESC
            LIMIT 30
        ''')
        genres = await cursor.fetchall()
    
    # Multfilmlar va Ingliz tilidagi kinolar sonini olish
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT COUNT(*) FROM movies 
            WHERE is_active = 1 
            AND (genre LIKE '%Multfilm%' OR genre LIKE '%Animation%' OR genre LIKE '%Anime%' OR genre LIKE '%Cartoon%')
            AND (status = "approved" OR status IS NULL)
        ''')
        animation_count = (await cursor.fetchone())[0] or 0
        
        cursor = await conn.execute('''
            SELECT COUNT(*) FROM movies 
            WHERE is_active = 1 
            AND (caption LIKE '%English%' OR caption LIKE '%Ingliz%' OR caption LIKE '%EN%' OR caption LIKE '%en%')
            AND (status = "approved" OR status IS NULL)
        ''')
        english_count = (await cursor.fetchone())[0] or 0
    
    # Eng ko'p ko'riladigan 10 ta janr
    top_genres = genres[:10] if genres else []
    other_genres = genres[10:] if genres else []
    
    text = "<b>FILMLAR JANRLARI</b>\n\n"
    text += "<b>Maxsus bo'limlar:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    
    # Multfilmlar
    if animation_count > 0:
        text += f"<b>Multfilmlar</b> ({animation_count} ta)\n"
        builder.button(text="Multfilmlar", callback_data="animation_movies")
    
    # Ingliz tilidagi kinolar
    if english_count > 0:
        text += f"<b>Ingliz tilidagi kinolar</b> ({english_count} ta)\n"
        builder.button(text="Ingliz tilidagi kinolar", callback_data="english_movies")
    
    if top_genres:
        text += f"\n<b>Eng ko'p ko'riladigan janrlar:</b>\n\n"
        for genre_row in top_genres:
            genre = genre_row[0] or "Boshqa"
            genre_clean = remove_emoji(genre)
            count = genre_row[1] or 0
            downloads = genre_row[2] or 0
            text += f"{genre_clean} ({count} ta, {downloads} yuklash)\n"  # Textdan emoji olib tashlandi
            builder.button(text=genre_clean, callback_data=f"genre_movies_{genre}")  # Button textda emoji yo'q
    
    if other_genres:
        text += f"\n<b>Boshqa janrlar ({len(other_genres)} ta):</b>\n\n"
        for genre_row in other_genres[:10]:
            genre = genre_row[0] or "Boshqa"
            genre_clean = remove_emoji(genre)
            count = genre_row[1] or 0
            text += f"{genre_clean} ({count} ta)\n"  # Textdan emoji olib tashlandi
            builder.button(text=genre_clean, callback_data=f"genre_movies_{genre}")  # Button textda emoji yo'q
    
    if not genres and animation_count == 0 and english_count == 0:
        text += "Hozircha janrlar mavjud emas.\n\n"
        text += "Adminlar filmlar qo'shganda janrlar avtomatik aniqlanadi."
    
    builder.button(text="Kinoteatr", callback_data="cinema_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "animation_movies")
async def handle_animation_movies(callback: CallbackQuery):
    """Multfilmlar bo'limi"""
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM movies 
            WHERE is_active = 1 
            AND (genre LIKE '%Multfilm%' OR genre LIKE '%Animation%' OR genre LIKE '%Anime%' OR genre LIKE '%Cartoon%')
            AND (status = "approved" OR status IS NULL)
            ORDER BY COALESCE(downloads, 0) DESC, id DESC
            LIMIT 50
        ''')
        movies = await cursor.fetchall()
    
    if not movies:
        await callback.answer("Hozircha multfilmlar mavjud emas.", show_alert=True)
        return
    
    text = "<b>MULTFILMLAR</b>\n\n"
    text += f"Topilgan: {len(movies)} ta multfilm\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, movie in enumerate(movies[:20], 1):
        movie_title = movie[2] or "Nomsiz"[:40]
        movie_id = movie[0]
        text += f"{i}. <b>{movie_title}</b>\n"
        builder.button(text=movie_title[:30], callback_data=f"watch_movie_{movie_id}")
    
    builder.button(text="Janrlar", callback_data="movie_genres")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "english_movies")
async def handle_english_movies(callback: CallbackQuery):
    """Ingliz tilidagi kinolar bo'limi"""
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM movies 
            WHERE is_active = 1 
            AND (caption LIKE '%English%' OR caption LIKE '%Ingliz%' OR language = 'en' OR language = 'english')
            AND (status = "approved" OR status IS NULL)
            ORDER BY COALESCE(downloads, 0) DESC, id DESC
            LIMIT 50
        ''')
        movies = await cursor.fetchall()
    
    if not movies:
        await callback.answer("Hozircha ingliz tilidagi kinolar mavjud emas.", show_alert=True)
        return
    
    text = "<b>INGLIZ TILIDAGI KINOLAR</b>\n\n"
    text += f"Topilgan: {len(movies)} ta kino\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, movie in enumerate(movies[:20], 1):
        movie_title = movie[2] or "Nomsiz"[:40]
        movie_id = movie[0]
        text += f"{i}. <b>{movie_title}</b>\n"
        builder.button(text=movie_title[:30], callback_data=f"watch_movie_{movie_id}")
    
    builder.button(text="Janrlar", callback_data="movie_genres")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "course_genres")
async def handle_course_genres(callback: CallbackQuery):
    """Kurslar kategoriyalari (eng ko'p ko'riladigan va boshqalar)"""
    user_id = callback.from_user.id
    
    # Bazadan barcha mavjud kategoriyalarni olish (eng ko'p ko'riladiganlar birinchi)
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT category, COUNT(*) as count,
                   SUM(COALESCE(students_count, 0)) as total_students
            FROM courses 
            WHERE is_active = 1 AND category IS NOT NULL AND category != ''
            GROUP BY category
            ORDER BY total_students DESC, count DESC
            LIMIT 30
        ''')
        categories = await cursor.fetchall()
    
    if not categories:
        await safe_edit_text(callback,
            "ðŸ“‚ <b>KURSLAR KATEGORIYALARI</b>\n\n"
            "âŒ Hozircha kategoriyalar mavjud emas.\n\n"
            "ðŸ’¡ Adminlar kurslar qo'shganda kategoriyalar belgilanadi.",
            reply_markup=Keyboards.back_button("courses_menu")
        )
        await callback.answer()
        return
    
    # Eng ko'p ko'riladigan 10 ta kategoriya
    top_categories = categories[:10]
    other_categories = categories[10:]
    
    text = "<b>KURSLAR KATEGORIYALARI</b>\n\n"
    text += "<b>Eng ko'p ko'riladigan kategoriyalar:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for cat_row in top_categories:
        category = cat_row[0] or "Boshqa"
        category_clean = remove_emoji(category)
        count = cat_row[1] or 0
        students = cat_row[2] or 0
        text += f"{category_clean} ({count} ta, {students} talaba)\n"  # Textdan emoji olib tashlandi
        builder.button(text=category_clean, callback_data=f"genre_courses_{category}_0")  # Button textda emoji yo'q (page 0 bilan boshlaymiz)
    
    if other_categories:
        text += f"\n<b>Boshqa kategoriyalar ({len(other_categories)} ta):</b>\n\n"
        for cat_row in other_categories[:10]:
            category = cat_row[0] or "Boshqa"
            category_clean = remove_emoji(category)
            count = cat_row[1] or 0
            text += f"{category_clean} ({count} ta)\n"  # Textdan emoji olib tashlandi
            builder.button(text=category_clean, callback_data=f"genre_courses_{category}_0")  # Button textda emoji yo'q (page 0 bilan boshlaymiz)
    
    builder.button(text="Kurslar", callback_data="courses_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("genre_books_"))
async def handle_genre_books(callback: CallbackQuery, state: FSMContext):
    """Janr bo'yicha kitoblar (pagination bilan)"""
    data_parts = callback.data.replace("genre_books_", "").split("_")
    genre = data_parts[0]
    page = int(data_parts[1]) if len(data_parts) > 1 and data_parts[1].isdigit() else 0
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT code, caption, author, genre, downloads
            FROM books 
            WHERE is_active = 1 
            AND genre = ?
            AND (status = "approved" OR status IS NULL)
            ORDER BY COALESCE(downloads, 0) DESC
        ''', (genre,))
        all_books = await cursor.fetchall()
    
    if not all_books:
        await callback.answer(f"'{genre}' janrida kitoblar topilmadi.", show_alert=True)
        return
    
    # Pagination
    items_per_page = 10
    total_pages = (len(all_books) + items_per_page - 1) // items_per_page
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    books = all_books[start_idx:end_idx]
    
    # State'ga saqlash
    await state.update_data(
        genre_books=all_books,
        genre_books_genre=genre,
        genre_books_page=page
    )
    
    text = f"<b>{genre.upper()} JANRI KITOBLARI</b>\n\n"
    text += f"Topilgan: {len(all_books)} ta\n"
    text += f"Sahifa: {page + 1}/{total_pages}\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, book in enumerate(books, start_idx + 1):
        book_title = book[1] or "Nomsiz"[:40]
        book_code = book[0] or ""
        text += f"{i}. <b>{book_title}</b>\n"
        if book_code:
            builder.button(text=book_title[:30], callback_data=f"view_book_{book_code}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton(text="Orqaga", callback_data=f"genre_books_{genre}_{page - 1}"))
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton(text="Keyingi", callback_data=f"genre_books_{genre}_{page + 1}"))
        if pagination_row:
            builder.row(*pagination_row)
    
    builder.button(text="Janrlar", callback_data="book_genres")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(books) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("genre_movies_"))
async def handle_genre_movies(callback: CallbackQuery, state: FSMContext):
    """Janr bo'yicha filmlar (pagination bilan)"""
    data_parts = callback.data.replace("genre_movies_", "").split("_")
    genre = data_parts[0]
    page = int(data_parts[1]) if len(data_parts) > 1 and data_parts[1].isdigit() else 0
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT id, caption, genre, downloads, quality, year, rating
            FROM movies 
            WHERE is_active = 1 
            AND genre = ?
            AND (status = "approved" OR status IS NULL)
            ORDER BY COALESCE(downloads, 0) DESC, id DESC
        ''', (genre,))
        all_movies = await cursor.fetchall()
    
    if not all_movies:
        await callback.answer(f"'{genre}' janrida filmlar topilmadi.", show_alert=True)
        return
    
    # Pagination
    items_per_page = 10
    total_pages = (len(all_movies) + items_per_page - 1) // items_per_page
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    movies = all_movies[start_idx:end_idx]
    
    # State'ga saqlash
    movies_list = [{'id': m[0], 'caption': m[1], 'genre': m[2], 'downloads': m[3], 'quality': m[4], 'year': m[5], 'rating': m[6]} for m in all_movies]
    await state.update_data(
        genre_movies=movies_list,
        genre_movies_genre=genre,
        genre_movies_page=page
    )
    
    text = f"<b>{genre.upper()} JANRI FILMLARI</b>\n\n"
    text += f"Topilgan: {len(all_movies)} ta\n"
    text += f"Sahifa: {page + 1}/{total_pages}\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, movie in enumerate(movies, start_idx + 1):
        movie_title = movie[1] or "Nomsiz"[:40]
        movie_id = movie[0]
        text += f"{i}. <b>{movie_title}</b>\n"
        builder.button(text=movie_title[:30], callback_data=f"watch_movie_{movie_id}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton(text="Orqaga", callback_data=f"genre_movies_{genre}_{page - 1}"))
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton(text="Keyingi", callback_data=f"genre_movies_{genre}_{page + 1}"))
        if pagination_row:
            builder.row(*pagination_row)
    
    builder.button(text="Janrlar", callback_data="movie_genres")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(movies) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("genre_courses_"))
async def handle_genre_courses(callback: CallbackQuery, state: FSMContext):
    """Kategoriya bo'yicha kurslar (pagination bilan)"""
    data_parts = callback.data.replace("genre_courses_", "").split("_")
    category = data_parts[0]
    page = int(data_parts[1]) if len(data_parts) > 1 and data_parts[1].isdigit() else 0
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT id, title, category, price, students_count, rating
            FROM courses 
            WHERE is_active = 1 
            AND category = ?
            ORDER BY COALESCE(students_count, 0) DESC, id DESC
        ''', (category,))
        all_courses = await cursor.fetchall()
    
    if not all_courses:
        await callback.answer(f"'{category}' kategoriyasida kurslar topilmadi.", show_alert=True)
        return
    
    # Pagination
    items_per_page = 10
    total_pages = (len(all_courses) + items_per_page - 1) // items_per_page
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    courses = all_courses[start_idx:end_idx]
    
    # State'ga saqlash
    courses_list = [{'id': c[0], 'title': c[1], 'category': c[2], 'price': c[3], 'students_count': c[4], 'rating': c[5]} for c in all_courses]
    await state.update_data(
        genre_courses=courses_list,
        genre_courses_category=category,
        genre_courses_page=page
    )
    
    text = f"<b>{category.upper()} KATEGORIYASI KURSLARI</b>\n\n"
    text += f"Topilgan: {len(all_courses)} ta\n"
    text += f"Sahifa: {page + 1}/{total_pages}\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, course in enumerate(courses, start_idx + 1):
        course_title = course[1] or "Nomsiz"[:40]
        course_id = course[0]
        text += f"{i}. <b>{course_title}</b>\n"
        builder.button(text=course_title[:30], callback_data=f"view_course_{course_id}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton(text="Orqaga", callback_data=f"genre_courses_{category}_{page - 1}"))
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton(text="Keyingi", callback_data=f"genre_courses_{category}_{page + 1}"))
        if pagination_row:
            builder.row(*pagination_row)
    
    builder.button(text="Kategoriyalar", callback_data="course_genres")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(courses) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "top_books")
async def handle_top_books(callback: CallbackQuery):
    """Top kitoblar (eng ko'p yuklangan)"""
    user_id = callback.from_user.id
    analytics.track_command(user_id, "top_books")
    
    # Eng ko'p yuklangan kitoblar (faqat kerakli ustunlar)
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT code, caption, author, genre, COALESCE(downloads, 0) as downloads
            FROM books 
            WHERE is_active = 1 
            AND (status = "approved" OR status IS NULL)
            ORDER BY COALESCE(downloads, 0) DESC
            LIMIT 20
        ''')
        top_books = await cursor.fetchall()
    
    if not top_books:
        await callback.answer("Hozircha top kitoblar yo'q.", show_alert=True)
        return
    
    text = "<b>TOP KITOBLAR</b>\n\n"
    text += "<b>Eng ko'p yuklangan kitoblar:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, book in enumerate(top_books[:15], 1):
        book_code = book[0] or ""
        book_title = book[1] or "Nomsiz"
        book_author = book[2] or ""
        book_genre = book[3] or ""
        downloads = book[4] or 0
        
        # Faqat kitob nomi ko'rsatiladi, file_id ko'rsatilmaydi
        text += f"{i}. <b>{book_title[:50]}</b>\n"
        text += f"   ðŸ“¥ {downloads} yuklash\n"
        if book_author:
            text += f"   ðŸ‘¤ {book_author}\n"
        if book_genre:
            text += f"   ðŸ“‚ {book_genre}\n"
        text += "\n"
        
        if book_code:
            builder.button(text=f"ðŸ“š {book_title[:30]}", callback_data=f"view_book_{book_code}")
    
    builder.button(text="Kutubxona", callback_data="library_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "top_movies")
async def handle_top_movies(callback: CallbackQuery):
    """Top filmlar (eng ko'p yuklangan va eng ko'p izlangan) - OPTIMALLASHTIRILGAN"""
    user_id = callback.from_user.id
    analytics.track_command(user_id, "top_movies")
    
    # Eng ko'p izlangan kinolar
    top_viewed = await db.get_top_movies(limit=5, sort_by="views")
    # Eng ko'p yuklangan kinolar
    top_downloaded = await db.get_top_movies(limit=5, sort_by="downloads")
    
    results_text = "ðŸ† <b>TOP FILMLAR</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    
    results_text += "ðŸ‘ï¸ <b>Eng ko'p izlangan:</b>\n"
    if top_viewed:
        for i, movie in enumerate(top_viewed, 1):
            movie_id = movie.get('id', 0)
            movie_title = movie.get('caption', 'Noma\'lum')[:35]
            results_text += f"{i}. <b>{movie_title}</b> - ðŸ‘ï¸ {movie.get('views', 0)}\n"
            builder.button(text=f"ðŸŽ¬ {i}. {movie_title[:25]}", callback_data=f"watch_movie_{movie_id}")
    else:
        results_text += "Hozircha ma'lumotlar yo'q.\n"
    
    results_text += "\nðŸ“¥ <b>Eng ko'p yuklangan:</b>\n"
    if top_downloaded:
        for i, movie in enumerate(top_downloaded, 1):
            movie_id = movie.get('id', 0)
            movie_title = movie.get('caption', 'Noma\'lum')[:35]
            results_text += f"{i}. <b>{movie_title}</b> - ðŸ“¥ {movie.get('downloads', 0)}\n"
            builder.button(text=f"ðŸ“¥ {i}. {movie_title[:25]}", callback_data=f"watch_movie_{movie_id}")
    else:
        results_text += "Hozircha ma'lumotlar yo'q.\n"
    
    builder.button(text="ðŸ” Qidirish", callback_data="search_movies")
    builder.button(text="ðŸŽ² Tasodifiy film", callback_data="random_movie")
    builder.button(text="ðŸ”™ Kinoteatr", callback_data="cinema_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2)
    
    await callback.message.edit_text(results_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "random_movie")
async def handle_random_movie(callback: CallbackQuery):
    """Tasodifiy film (bazadan random) - OPTIMALLASHTIRILGAN - O'zbek va Ingliz tillari"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    analytics.track_command(user_id, "random_movie")
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    # Tasodifiy filmlarni olish (O'zbek va Ingliz tillari, 4-5 ta)
    random_movies = await db.get_random_movies(limit=5)
    
    if not random_movies:
        await callback.message.edit_text(
            "ðŸŽ² <b>TASODIFIY FILMLAR</b>\n\n"
            "âŒ Hozircha bazada filmlar yo'q.\n\n"
            "ðŸŽ¬ Keyinroq urinib ko'ring yoki admin panel orqali film qo'shing.",
            reply_markup=Keyboards.back_button("cinema_menu"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    # 4-5 ta tasodifiy film ko'rsatish
    text = "ðŸŽ² <b>TASODIFIY FILMLAR</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(random_movies)} ta tasodifiy film\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, movie in enumerate(random_movies, 1):
        movie_title = movie.get('caption', 'Nomsiz')[:40]
        movie_id = movie.get('id', 0)
        genre = movie.get('genre', 'Noma\'lum')
        quality = movie.get('quality', 'N/A')
        
        text += f"{i}. <b>{movie_title}</b>\n"
        text += f"   ðŸ“‚ {genre}\n"
        text += f"   ðŸ“º {quality}\n"
        if movie.get('views'):
            text += f"   ðŸ‘ï¸ {movie.get('views', 0)} ko'rish\n"
        text += "\n"
        
        builder.button(text=f"ðŸŽ¬ {i}. {movie_title[:30]}", callback_data=f"watch_movie_{movie_id}")
    
    builder.button(text="ðŸŽ² Yana tasodifiy", callback_data="random_movie")
    builder.button(text="ðŸ”™ Kinoteatr", callback_data="cinema_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer("ðŸŽ² Tasodifiy filmlar topildi!")

@router.callback_query(F.data.startswith("watch_movie_"))
async def handle_watch_movie(callback: CallbackQuery):
    """Filmini ko'rish (OPTIMALLASHTIRILGAN - 100% ishlaydigan)"""
    movie_id = callback.data.replace("watch_movie_", "")
    user_id = callback.from_user.id
    
    # Rate limiting
    if not rate_limiter.is_allowed(user_id):
        await callback.answer("âš ï¸ Juda ko'p so'rov! Iltimos, biroz kuting.", show_alert=True)
        return
    
    analytics.track_command(user_id, "watch_movie")
    
    user = await db.get_user(user_id)
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Bazadan kino ma'lumotlarini olish
    movie = None
    try:
        movie_id_int = int(movie_id) if movie_id.isdigit() else None
        if movie_id_int:
            movie = await db.get_movie(movie_id_int)
        else:
            movie = await db.get_movie_by_code(movie_id.upper())
    except Exception as e:
        logger.error(f"Error fetching movie: {e}")
    
    # Real bazadan video ID ni olish
    if not movie or not isinstance(movie, dict):
        await callback.answer("Video topilmadi!", show_alert=True)
        return
    
    # Serial tekshiruvi - agar is_series=1 bo'lsa, qismlar sahifasiga yo'naltirish
    if movie.get('is_series') == 1 and movie.get('total_episodes', 0) > 0:
        movie_id_int = movie.get('id')
        # Qismlar sahifasiga yo'naltirish
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“º Qismlarni ko'rish", callback_data=f"series_episodes_{movie_id_int}_0")
        builder.button(text="ðŸ”™ Kinoteatr", callback_data="cinema_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback,
            f"ðŸ“º <b>{movie.get('caption', 'Serial')}</b>\n\n"
            f"ðŸŽ­ <b>Janr:</b> {movie.get('genre', 'Noma\'lum')}\n"
            f"ðŸ“Š <b>Jami qismlar:</b> {movie.get('total_episodes', 0)} ta\n\n"
            f"Qismlarni ko'rish uchun tugmani bosing.",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    if not movie.get('file_id'):
        await callback.answer("Video topilmadi yoki fayl mavjud emas.", show_alert=True)
        return
    
    # Premium kino tekshiruvi (1080p, 4K, 2160p)
    movie_quality = movie.get('quality', '480p').lower()
    is_premium_quality = any(premium in movie_quality for premium in ['1080', '4k', '2160', '2160p'])
    
    if is_premium_quality and subscription_type < 2:
        await callback.answer(
            "âŒ Bu film faqat Premium foydalanuvchilar uchun!\n\n"
            "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    video_id = movie['file_id']
    movie_title = movie.get('caption', f'Film: {movie_id}')
    
    # File_id formatini tekshirish
    if not video_id:
        logger.error(f"Video file_id topilmadi: {video_id}")
        await callback.answer("Film fayli topilmadi.", show_alert=True)
        return
    
    # OPTIMIZATSIYA: Agar file_id bot formatida bo'lsa, darhol yuborish (sekundda)
    is_parser_format = ':' in str(video_id) and len(str(video_id).split(':')) == 3
    
    if is_parser_format:
        # Parser.py dan kelgan format - oddiy file_id ga o'zgartirish kerak
        logger.info(f"Parser.py format video file_id: {video_id}")
        await callback.answer("â³ Film yuklanmoqda...", show_alert=False)
        
        # Views ni oshirish
        if movie_id_int:
            await db.increment_movie_views(movie_id_int)
        
        await callback.message.answer(
            f"â³ <b>Film yuklanmoqda...</b>\n\n"
            f"ðŸ“½ï¸ <b>{movie_title}</b>\n\n"
            f"ðŸ’¡ Video tayyorlanmoqda. Iltimos, biroz kuting...\n"
            f"â° Maksimal vaqt: 5 daqiqa\n"
            f"âœ… Tayyor bo'lganda sizga yuboriladi.",
            reply_markup=Keyboards.back_button("cinema_menu"),
            parse_mode=ParseMode.HTML
        )
        return
    
    # Nomlari bir xil bo'lgan barcha qismlarni topish
    movie_parts = await db.get_movies_by_name(movie_title, limit=50)
    
    # Agar bir nechta qism bo'lsa, tugmalar orqali ko'rsatish
    if len(movie_parts) > 1:
        # Qismlarni tartib bo'yicha saralash (order_number bo'yicha)
        try:
            movie_parts.sort(key=lambda x: int(x.get('order_number', 0)) if str(x.get('order_number', 0)).isdigit() else 999)
        except:
            pass
        
        # Film ma'lumotlarini ko'rsatish
        parts_text = f"<b>{movie_title}</b>\n\n"
        parts_text += f"<b>Ma'lumotlar:</b>\n"
        
        if movie.get('country'):
            parts_text += f"Davlati: {movie.get('country')}\n"
        if movie.get('quality'):
            parts_text += f"Sifat: {movie.get('quality')}\n"
        if movie.get('imdb_rating'):
            parts_text += f"IMDb: {movie.get('imdb_rating')}/10\n"
        if movie.get('language'):
            parts_text += f"Tili: {movie.get('language')}\n"
        if movie.get('year'):
            parts_text += f"Yili: {movie.get('year')}\n"
        if movie.get('genre'):
            parts_text += f"Janri: {movie.get('genre')}\n"
        if movie.get('order_number'):
            parts_text += f"Film kodi: {movie.get('order_number')}\n"
        if movie.get('downloads', 0) > 0:
            parts_text += f"Yuklashlar soni: {movie.get('downloads', 0)}\n"
        
        parts_text += f"\n<b>Jami {len(movie_parts)} ta qism mavjud.</b>\n\n"
        parts_text += "Kerakli qismni tanlang:"
        
        # Qismlarni tugmalar orqali ko'rsatish (3x3 format)
        builder = InlineKeyboardBuilder()
        
        for part in movie_parts:
            part_number = part.get('order_number', '')
            part_id = part.get('id', 0)
            part_quality = part.get('quality', '720p')
            
            # Premium qism tekshiruvi
            is_premium_part = any(premium in str(part_quality).lower() for premium in ['1080', '4k', '2160'])
            
            if is_premium_part and subscription_type < 2:
                button_text = f"{part_number}-qism (Premium)"
                builder.button(text=button_text, callback_data=f"episode_premium_{part_id}")
            else:
                button_text = f"{part_number}-qism"
                builder.button(text=button_text, callback_data=f"watch_episode_{part_id}")
        
        # Tugmalarni 3x3 formatda tartiblash
        builder.adjust(3, 3, 3, 3, 3, 3, 3, 3, 3)  # Har bir qatorda 3 ta tugma
        
        builder.button(text="Kinoteatr", callback_data="cinema_menu")
        builder.button(text="Asosiy menyu", callback_data="main_menu")
        builder.adjust(2)  # Oxirgi 2 ta tugma bir qatorda
        
        await callback.message.answer(
            parts_text,
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    # Oddiy file_id formatida bo'lsa, darhol yuborish (faqat 1 ta qism bo'lsa)
    try:
        # File ID ni to'g'ri formatda tekshirish
        if len(video_id) < 10 or not video_id.replace('-', '').replace('_', '').isalnum():
            raise ValueError(f"Noto'g'ri video file_id formati: {video_id}")
        
        # Video yuborish (faqat 1 marta)
        await bot.send_video(
            chat_id=callback.message.chat.id,
            video=video_id,
            caption=f"ðŸŽ¬ <b>Film ochildi!</b>\n\n"
                   f"ðŸ“½ï¸ <b>{movie_title}</b>\n"
                   f"ðŸ“Š Janr: {movie.get('genre', 'Noma\'lum')}\n"
                   f"ðŸ“º Sifat: {movie.get('quality', '720p')}\n\n"
                   f"âœ… Film muvaffaqiyatli ochildi!",
            reply_markup=Keyboards.back_button("cinema_menu"),
            protect_content=True  # Filmlar uchun protect_content yoqilgan
        )
        
        # Download history ga yozish (statistika uchun)
        await db.record_download(callback.from_user.id, "movie", movie_id_int)
        
        # Daily challenge progress tracking
        challenge_result = await db.track_daily_challenge_progress(user_id, 'watch_movie')
        if challenge_result.get('completed'):
            await bot.send_message(
                user_id,
                f"ðŸŽ¯ <b>KUNLIK CHALLENGE BAJARILDI!</b>\n\n"
                f"ðŸŽ <b>Mukofotlar:</b>\n"
                f"â­ +{challenge_result['xp_reward']} XP\n"
                f"ðŸª™ +{challenge_result['gold_reward']} Gold\n\n"
                f"Ertaga yangi challenge kutadi! ðŸŽ‰",
                parse_mode=ParseMode.HTML
            )
        
        await callback.answer("Film ochildi!")
        return  # Faqat 1 marta yuborish
    except ValueError as e:
        logger.error(f"Video file_id format xatosi: {e}")
        await callback.answer(
            "âŒ Film fayli hali botga yuklanmagan!\n\n"
            "ðŸ’¡ Iltimos, admin bilan bog'laning.",
            show_alert=True
        )
    except Exception as e:
        logger.error(f"Video yuborish xatosi: {e}")
        error_msg = str(e)
        
        # Xatolik turini aniqlash
        if "wrong remote file identifier" in error_msg.lower() or "bad request" in error_msg.lower():
            await callback.answer(
                "âŒ Film fayli hali botga yuklanmagan!\n\n"
                "ðŸ’¡ Iltimos, admin bilan bog'laning.",
                show_alert=True
            )
        else:
            await callback.message.edit_text(
                f"âŒ Filmni ochishda xatolik yuz berdi!\n\n"
                f"ðŸ“ Xatolik: {error_msg[:200]}\n\n"
                f"ðŸ’¡ Iltimos, keyinroq urinib ko'ring yoki admin bilan bog'laning.",
                reply_markup=Keyboards.back_button("cinema_menu"),
                parse_mode=ParseMode.HTML
            )

@router.callback_query(F.data.startswith("watch_episode_"))
async def handle_watch_episode(callback: CallbackQuery):
    """Qismli kinoning bitta qismini yuborish"""
    episode_id = callback.data.replace("watch_episode_", "")
    user_id = callback.from_user.id
    
    if not episode_id.isdigit():
        await callback.answer("Noto'g'ri qism ID!", show_alert=True)
        return
    
    user = await db.get_user(user_id)
    if not user:
        await callback.answer("Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Episode ma'lumotlarini olish
    movie = await db.get_movie(int(episode_id))
    
    if not movie or not movie.get('file_id'):
        await callback.answer("Qism topilmadi!", show_alert=True)
        return
    
    video_id = movie['file_id']
    movie_title = movie.get('caption', 'Film')
    part_number = movie.get('order_number', '')
    
    # Premium tekshiruvi
    movie_quality = movie.get('quality', '480p').lower()
    is_premium_quality = any(premium in movie_quality for premium in ['1080', '4k', '2160'])
    
    if is_premium_quality and subscription_type < 2:
        await callback.answer(
            "Bu qism faqat Premium foydalanuvchilar uchun!\n\n"
            "Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    # Video yuborish
    try:
        await bot.send_video(
            chat_id=callback.message.chat.id,
            video=video_id,
            caption=f"<b>{movie_title}</b>\n"
                   f"Qism: {part_number}\n"
                   f"Sifat: {movie.get('quality', '720p')}",
            protect_content=True
        )
        
        # Download history ga yozish
        await db.record_download(user_id, "movie", int(episode_id))
        await db.increment_movie_views(int(episode_id))
        
        await callback.answer("Qism yuborildi!")
    except Exception as e:
        logger.error(f"Episode yuborish xatosi: {e}")
        await callback.answer("Qismni yuborishda xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data.startswith("episode_premium_"))
async def handle_episode_premium(callback: CallbackQuery):
    """Premium qism uchun xabar"""
    await callback.answer(
        "Bu qism faqat Premium foydalanuvchilar uchun!\n\n"
        "Premium obuna olish uchun 'Premium' tugmasini bosing.",
        show_alert=True
    )

# ========== SERIAL QISMLARINI KO'RISH (PAGINATION) ==========
@router.callback_query(F.data.startswith("series_episodes_"))
async def handle_series_episodes(callback: CallbackQuery):
    """Serial qismlarini pagination bilan ko'rsatish"""
    parts = callback.data.replace("series_episodes_", "").split("_")
    movie_id = int(parts[0])
    page = int(parts[1]) if len(parts) > 1 else 0
    
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    subscription_type = user.get('subscription_type', 0) if user else 0
    
    EPISODES_PER_PAGE = 12  # Har bir sahifada 12 ta qism (4x3)
    
    # Serial ma'lumotlarini olish
    async with db.connect() as conn:
        cursor = await conn.execute(
            "SELECT caption, total_episodes, genre, year, description FROM movies WHERE id = ?",
            (movie_id,)
        )
        movie = await cursor.fetchone()
        
        if not movie:
            await callback.answer("âŒ Serial topilmadi!", show_alert=True)
            return
        
        caption, total_eps, genre, year, description = movie
        
        # Qismlarni olish (pagination)
        offset = page * EPISODES_PER_PAGE
        cursor = await conn.execute('''
            SELECT id, episode_number, file_id, title, downloads
            FROM movie_episodes 
            WHERE movie_id = ?
            ORDER BY episode_number ASC
            LIMIT ? OFFSET ?
        ''', (movie_id, EPISODES_PER_PAGE, offset))
        episodes = await cursor.fetchall()
    
    if not episodes:
        await callback.answer("âŒ Qismlar topilmadi!", show_alert=True)
        return
    
    total_pages = (total_eps + EPISODES_PER_PAGE - 1) // EPISODES_PER_PAGE if total_eps else 1
    
    # Matn tayyorlash
    text = f"ðŸ“º <b>{caption}</b>\n\n"
    if genre:
        text += f"ðŸŽ­ <b>Janr:</b> {genre}\n"
    if year:
        text += f"ðŸ“… <b>Yil:</b> {year}\n"
    text += f"ðŸ“Š <b>Jami qismlar:</b> {total_eps or len(episodes)} ta\n"
    text += f"ðŸ“„ <b>Sahifa:</b> {page + 1}/{total_pages}\n\n"
    
    if description:
        text += f"ðŸ“ {description[:200]}...\n\n"
    
    text += "ðŸŽ¬ <b>Qismni tanlang:</b>"
    
    # Qismlar tugmalari
    builder = InlineKeyboardBuilder()
    
    for ep in episodes:
        ep_id, ep_num, file_id, title, downloads = ep
        
        if file_id:
            builder.button(
                text=f"â–¶ï¸ {ep_num}-qism",
                callback_data=f"play_episode_{ep_id}"
            )
        else:
            builder.button(
                text=f"ðŸ”’ {ep_num}-qism",
                callback_data=f"episode_locked_{ep_id}"
            )
    
    # 3 ta tugma har qatorda
    builder.adjust(3)
    
    # Pagination tugmalari
    nav_buttons = []
    if page > 0:
        nav_buttons.append(("â¬…ï¸ Oldingi", f"series_episodes_{movie_id}_{page - 1}"))
    if page < total_pages - 1:
        nav_buttons.append(("Keyingi âž¡ï¸", f"series_episodes_{movie_id}_{page + 1}"))
    
    if nav_buttons:
        for text_btn, data in nav_buttons:
            builder.button(text=text_btn, callback_data=data)
        builder.adjust(3, 3, 3, 3, len(nav_buttons))
    
    builder.button(text="ðŸ”™ Kinoteatr", callback_data="cinema_menu")
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.startswith("play_episode_"))
async def handle_play_episode(callback: CallbackQuery):
    """Serial qismini ijro etish"""
    episode_id = int(callback.data.replace("play_episode_", ""))
    user_id = callback.from_user.id
    
    # Episode ma'lumotlarini olish
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT e.file_id, e.episode_number, e.title, m.caption, m.id as movie_id
            FROM movie_episodes e
            JOIN movies m ON e.movie_id = m.id
            WHERE e.id = ?
        ''', (episode_id,))
        episode = await cursor.fetchone()
    
    if not episode:
        await callback.answer("âŒ Qism topilmadi!", show_alert=True)
        return
    
    file_id, ep_num, title, series_name, movie_id = episode
    
    if not file_id:
        await callback.answer("âŒ Video fayl mavjud emas!", show_alert=True)
        return
    
    try:
        # Video yuborish
        await bot.send_video(
            chat_id=callback.message.chat.id,
            video=file_id,
            caption=f"ðŸ“º <b>{series_name}</b>\n"
                   f"ðŸŽ¬ <b>{ep_num}-qism</b>\n\n"
                   f"âœ… Yoqimli tomosha!",
            parse_mode=ParseMode.HTML,
            protect_content=True
        )
        
        # Statistika yangilash
        async with db.connect() as conn:
            await conn.execute(
                "UPDATE movie_episodes SET downloads = downloads + 1 WHERE id = ?",
                (episode_id,)
            )
            await conn.commit()
        
        await callback.answer(f"â–¶ï¸ {ep_num}-qism yuborildi!")
        
        logger.info(f"User {user_id} watched episode {ep_num} of {series_name}")
        
    except Exception as e:
        logger.error(f"Episode yuborishda xatolik: {e}")
        await callback.answer("âŒ Video yuborishda xatolik!", show_alert=True)

@router.callback_query(F.data.startswith("episode_locked_"))
async def handle_episode_locked(callback: CallbackQuery):
    """Qulflangan qism"""
    await callback.answer(
        "ðŸ”’ Bu qism hali yuklanmagan!\n"
        "Tez orada qo'shiladi.",
        show_alert=True
    )

@router.callback_query(F.data == "admin_add_movie")
async def handle_admin_add_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Film qo'shish menyusi (qismli yoki qismsiz)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ¬ Qismli film qo'shish", callback_data="admin_add_multi_part_movie")
    builder.button(text="ðŸŽžï¸ Qismsiz film qo'shish", callback_data="admin_add_single_movie")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1)
    
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>FILM QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday turdagi film qo'shmoqchisiz?</b>\n\n"
        "â€¢ <b>Qismli film:</b> Bir nechta video fayldan iborat filmlar (seriallar, ko'p qismli kinolar).\n"
        "â€¢ <b>Qismsiz film:</b> Bitta video fayldan iborat filmlar.",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "admin_add_multi_part_movie")
async def handle_admin_add_multi_part_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Qismli film qo'shish (nom so'rash)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>QISMLI FILM QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Film nomini yozing\n"
        "2. Keyin video qismlarini yuborish mumkin (cheksiz)\n"
        "3. Har bir qism avtomatik bazaga saqlanadi\n"
        "4. Jarayonni to'xtatish uchun /cancel\n\n"
        "ðŸ“ <b>Film nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.update_data(is_premium=0, is_single_part=0)  # Qismli film
    await state.set_state(AdminStates.waiting_movie_name)
    await callback.answer("Qismli film qo'shish rejimi yoqildi!")

@router.callback_query(F.data == "admin_add_single_movie")
async def handle_admin_add_single_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Qismsiz film qo'shish (nom so'rash)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽžï¸ <b>QISMSIZ FILM QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Film nomini yozing\n"
        "2. Keyin video faylini yuboring\n"
        "3. Avtomatik bazaga saqlanadi\n"
        "4. Jarayonni to'xtatish uchun /cancel\n\n"
        "ðŸ“ <b>Film nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.update_data(is_premium=0, is_single_part=1)  # Qismsiz film
    await state.set_state(AdminStates.waiting_single_movie_name)
    await callback.answer("Qismsiz film qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_single_movie_name)
async def handle_single_movie_name(message: Message, state: FSMContext):
    """Admin: Qismsiz film nomini qabul qilish va til/janr tanlash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("Film qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    movie_name = message.text.strip()
    
    if not movie_name:
        await message.answer("âŒ Film nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(movie_name=movie_name)
    
    # Til va janr tanlash
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="single_movie_lang_uz")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="single_movie_lang_en")
    builder.button(text="âŒ O'tkazib yuborish", callback_data="single_movie_lang_skip")
    builder.adjust(2, 1)
    
    await message.answer(
        f"âœ… <b>Film nomi qabul qilindi!</b>\n\n"
        f"ðŸŽ¬ <b>Nomi:</b> {movie_name}\n\n"
        f"ðŸŒ <b>Tilni tanlang (ixtiyoriy):</b>",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_movie_language)

@router.callback_query(F.data.startswith("single_movie_lang_"))
async def handle_single_movie_language(callback: CallbackQuery, state: FSMContext):
    """Admin: Qismsiz film tilini tanlash va janr so'rash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    lang_data = callback.data.replace("single_movie_lang_", "")
    language = "uz" if lang_data == "uz" else ("en" if lang_data == "en" else "")
    
    await state.update_data(movie_language=language)
    
    # Janr tanlash
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ¬ Multfilm", callback_data="single_movie_genre_Animation")
    builder.button(text="ðŸŽ¬ Action", callback_data="single_movie_genre_Action")
    builder.button(text="ðŸŽ¬ Comedy", callback_data="single_movie_genre_Comedy")
    builder.button(text="ðŸŽ¬ Drama", callback_data="single_movie_genre_Drama")
    builder.button(text="ðŸŽ¬ Horror", callback_data="single_movie_genre_Horror")
    builder.button(text="ðŸŽ¬ Romance", callback_data="single_movie_genre_Romance")
    builder.button(text="ðŸŽ¬ Sci-Fi", callback_data="single_movie_genre_Sci-Fi")
    builder.button(text="ðŸŽ¬ Thriller", callback_data="single_movie_genre_Thriller")
    builder.button(text="ðŸ“‚ Boshqa", callback_data="single_movie_genre_Boshqa")
    builder.button(text="âŒ O'tkazib yuborish", callback_data="single_movie_genre_skip")
    builder.adjust(2, 2, 2, 2, 1, 1)
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    lang_text = "ðŸ‡ºðŸ‡¿ O'zbek" if language == "uz" else ("ðŸ‡¬ðŸ‡§ English" if language == "en" else "âŒ Tanlanmadi")
    
    await safe_edit_text(callback,
        f"âœ… <b>Til:</b> {lang_text}\n\n"
        f"ðŸŽ¬ <b>Film:</b> {movie_name}\n\n"
        f"ðŸ“‚ <b>Janrni tanlang (ixtiyoriy):</b>",
        reply_markup=builder.as_markup()
    )
    await state.set_state(AdminStates.waiting_movie_genre_select)
    await callback.answer()

@router.callback_query(F.data.startswith("single_movie_genre_"))
async def handle_single_movie_genre_select(callback: CallbackQuery, state: FSMContext):
    """Admin: Qismsiz film janrini tanlash va video so'rash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    genre_data = callback.data.replace("single_movie_genre_", "")
    genre = genre_data if genre_data != "skip" else "Boshqa"
    
    # Janrda " belgisini olib tashlash
    genre = genre.replace('"', '').replace("'", "").strip()
    if not genre or genre == "":
        genre = "Boshqa"
    
    await state.update_data(movie_genre=genre)
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    language = data.get('movie_language', 'uz')
    lang_text = "ðŸ‡ºðŸ‡¿ O'zbek" if language == "uz" else ("ðŸ‡¬ðŸ‡§ English" if language == "en" else "")
    genre_text = genre if genre else "Boshqa"
    
    await safe_edit_text(callback,
        f"âœ… <b>Ma'lumotlar:</b>\n\n"
        f"ðŸŽ¬ <b>Film:</b> {movie_name}\n"
        f"ðŸŒ <b>Til:</b> {lang_text}\n"
        f"ðŸ“‚ <b>Janr:</b> {genre_text}\n\n"
        f"ðŸ“Ž <b>Endi video faylni yuboring:</b>\n"
        f"â€¢ Bitta video fayl yuboring\n"
        f"â€¢ Avtomatik bazaga saqlanadi\n"
        f"â€¢ To'xtatish uchun /cancel\n\n"
        f"ðŸ“¹ <b>Video faylni yuboring:</b>",
        reply_markup=Keyboards.cancel_button()
    )
    
    await state.set_state(AdminStates.waiting_single_movie_file)
    await callback.answer()

@router.message(AdminStates.waiting_single_movie_file, F.video)
async def handle_single_movie_file(message: Message, state: FSMContext):
    """Admin: Qismsiz film video faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if not message.video:
        await message.answer("âŒ Video topilmadi! Video fayl yuboring yoki /cancel tugmasini bosing.")
        return
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    language = data.get('movie_language', 'uz')
    genre = data.get('movie_genre', 'Boshqa')
    
    file_id = message.video.file_id
    
    try:
        # Filmni bazaga qo'shish
        success = await db.add_movie(
            file_id=file_id,
            caption=movie_name,
            genre=genre,
            quality="720p",
            language=language
        )
        
        if success:
            await message.answer(
                f"âœ… <b>Film muvaffaqiyatli qo'shildi!</b>\n\n"
                f"ðŸŽ¬ <b>Nomi:</b> {movie_name}\n"
                f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
                f"ðŸ“‚ <b>Janr:</b> {genre}\n\n"
                f"ðŸ’¡ <b>Yana film qo'shish uchun /admin_add_movie yoki /cancel tugmasini bosing.</b>",
                reply_markup=Keyboards.cancel_button(),
                parse_mode=ParseMode.HTML
            )
            logger.info(f"Admin {user_id} qismsiz film qo'shdi: {movie_name}")
        else:
            await message.answer("âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.")
    except Exception as e:
        logger.error(f"Add single movie error: {e}")
        await message.answer("âŒ Xatolik yuz berdi!")
    
    await state.clear()

# ========== SERIAL QISM QO'SHISH ==========
@router.callback_query(F.data == "admin_add_episode")
async def handle_admin_add_episode(callback: CallbackQuery, state: FSMContext):
    """Admin: Mavjud serialga yangi qism qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ“º <b>SERIAL QISM QO'SHISH</b>\n\n"
        "Bu funksiya orqali mavjud serialga yangi qism qo'shishingiz mumkin.\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Serial nomini yozing (aniq nom)\n"
        "2. Agar serial topilsa, yangi qism qo'shiladi\n"
        "3. Agar topilmasa, yangi serial yaratiladi\n\n"
        "ðŸ“ <b>Serial nomini yozing:</b>\n"
        "<i>Masalan: Squid Game, Money Heist, Breaking Bad</i>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_episode_movie_name)
    await callback.answer("ðŸ“º Serial qism qo'shish rejimi!")

@router.message(AdminStates.waiting_episode_movie_name)
async def handle_episode_movie_name(message: Message, state: FSMContext):
    """Admin: Serial nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text and message.text.startswith('/'):
        if message.text == '/cancel':
            await message.answer("âŒ Bekor qilindi.", reply_markup=Keyboards.admin_menu())
            await state.clear()
            return
    
    movie_name = message.text.strip() if message.text else ""
    
    if not movie_name:
        await message.answer("âŒ Serial nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    # Serialni bazadan qidirish
    async with db.connect() as conn:
        # Aniq nom bo'yicha qidirish
        cursor = await conn.execute(
            "SELECT id, caption, is_series, total_episodes FROM movies WHERE LOWER(caption) LIKE ? LIMIT 5",
            (f"%{movie_name.lower()}%",)
        )
        movies = await cursor.fetchall()
    
    if movies:
        # Topilgan seriallarni ko'rsatish
        builder = InlineKeyboardBuilder()
        for movie in movies:
            movie_id, caption, is_series, total_eps = movie
            eps_text = f" ({total_eps or 0} qism)" if is_series else ""
            builder.button(
                text=f"ðŸ“º {caption[:30]}{eps_text}",
                callback_data=f"add_ep_to_{movie_id}"
            )
        builder.button(text="ðŸ†• Yangi serial yaratish", callback_data=f"create_new_series_{movie_name[:50]}")
        builder.button(text="âŒ Bekor qilish", callback_data="admin_content_movies")
        builder.adjust(1)
        
        await message.answer(
            f"ðŸ” <b>Topilgan natijalar:</b>\n\n"
            f"Qaysi serialga qism qo'shmoqchisiz?\n"
            f"Yoki yangi serial yarating.",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
    else:
        # Serial topilmadi - yangi yaratish taklifi
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Yangi serial yaratish", callback_data=f"create_new_series_{movie_name[:50]}")
        builder.button(text="ðŸ”„ Qayta qidirish", callback_data="admin_add_episode")
        builder.button(text="âŒ Bekor qilish", callback_data="admin_content_movies")
        builder.adjust(1)
        
        await message.answer(
            f"âŒ <b>'{movie_name}' nomli serial topilmadi.</b>\n\n"
            f"Yangi serial yaratishni xohlaysizmi?",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
    
    await state.update_data(series_name=movie_name)

@router.callback_query(F.data.startswith("add_ep_to_"))
async def handle_add_episode_to_series(callback: CallbackQuery, state: FSMContext):
    """Mavjud serialga qism qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    movie_id = int(callback.data.replace("add_ep_to_", ""))
    
    # Serial ma'lumotlarini olish
    async with db.connect() as conn:
        cursor = await conn.execute(
            "SELECT caption, total_episodes FROM movies WHERE id = ?",
            (movie_id,)
        )
        movie = await cursor.fetchone()
        
        if not movie:
            await callback.answer("âŒ Serial topilmadi!", show_alert=True)
            return
        
        caption, total_eps = movie
        next_episode = (total_eps or 0) + 1
        
        # Serialni is_series=1 qilish
        await conn.execute(
            "UPDATE movies SET is_series = 1 WHERE id = ?",
            (movie_id,)
        )
        await conn.commit()
    
    await state.update_data(
        episode_movie_id=movie_id,
        episode_movie_name=caption,
        next_episode_number=next_episode
    )
    
    await safe_edit_text(callback,
        f"ðŸ“º <b>{caption}</b>\n\n"
        f"ðŸ“Š <b>Hozirgi qismlar:</b> {total_eps or 0} ta\n"
        f"ðŸ†• <b>Yangi qism:</b> {next_episode}-qism\n\n"
        f"ðŸ“¹ <b>Endi {next_episode}-qism video faylini yuboring:</b>\n"
        f"<i>Video yoki document formatida</i>\n\n"
        f"ðŸ’¡ Bir nechta qism qo'shish uchun ketma-ket video yuboring.\n"
        f"Tugatish uchun /done yoki /cancel",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_episode_file)
    await callback.answer(f"ðŸ“º {next_episode}-qism uchun video yuboring!")

@router.callback_query(F.data.startswith("create_new_series_"))
async def handle_create_new_series(callback: CallbackQuery, state: FSMContext):
    """Yangi serial yaratish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    series_name = callback.data.replace("create_new_series_", "")
    
    # Yangi serial yaratish
    async with db.connect() as conn:
        # Keyingi order_number olish
        cursor = await conn.execute("SELECT MAX(order_number) FROM movies")
        max_order = await cursor.fetchone()
        next_order = (max_order[0] or 0) + 1
        
        # Yangi serial qo'shish
        cursor = await conn.execute('''
            INSERT INTO movies (caption, is_series, total_episodes, order_number, is_active, status)
            VALUES (?, 1, 0, ?, 1, 'approved')
        ''', (series_name, next_order))
        movie_id = cursor.lastrowid
        await conn.commit()
    
    await state.update_data(
        episode_movie_id=movie_id,
        episode_movie_name=series_name,
        next_episode_number=1
    )
    
    await safe_edit_text(callback,
        f"âœ… <b>Yangi serial yaratildi!</b>\n\n"
        f"ðŸ“º <b>Nomi:</b> {series_name}\n"
        f"ðŸ†• <b>Yangi qism:</b> 1-qism\n\n"
        f"ðŸ“¹ <b>Endi 1-qism video faylini yuboring:</b>\n"
        f"<i>Video yoki document formatida</i>\n\n"
        f"ðŸ’¡ Bir nechta qism qo'shish uchun ketma-ket video yuboring.\n"
        f"Tugatish uchun /done yoki /cancel",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_episode_file)
    await callback.answer("âœ… Serial yaratildi! 1-qism uchun video yuboring!")

@router.message(AdminStates.waiting_episode_file)
async def handle_episode_file(message: Message, state: FSMContext):
    """Serial qism faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    # /done yoki /cancel buyruqlari
    if message.text:
        if message.text == '/cancel':
            await message.answer("âŒ Bekor qilindi.", reply_markup=Keyboards.admin_menu())
            await state.clear()
            return
        elif message.text == '/done':
            data = await state.get_data()
            series_name = data.get('episode_movie_name', 'Serial')
            added_count = data.get('added_episodes_count', 0)
            
            await message.answer(
                f"âœ… <b>Qism qo'shish tugadi!</b>\n\n"
                f"ðŸ“º <b>Serial:</b> {series_name}\n"
                f"ðŸ“Š <b>Qo'shilgan qismlar:</b> {added_count} ta\n\n"
                f"ðŸ’¡ Yana qism qo'shish uchun /admin_add_episode",
                reply_markup=Keyboards.admin_content_menu("movies"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
    
    # Video yoki document tekshirish
    file_id = None
    if message.video:
        file_id = message.video.file_id
    elif message.document:
        file_id = message.document.file_id
    
    if not file_id:
        await message.answer(
            "âŒ Iltimos, video yoki document formatida fayl yuboring!\n"
            "Tugatish uchun /done, bekor qilish uchun /cancel"
        )
        return
    
    data = await state.get_data()
    movie_id = data.get('episode_movie_id')
    series_name = data.get('episode_movie_name')
    episode_number = data.get('next_episode_number', 1)
    added_count = data.get('added_episodes_count', 0)
    
    if not movie_id:
        await message.answer("âŒ Xatolik! Qaytadan boshlang.")
        await state.clear()
        return
    
    # Qismni bazaga qo'shish
    try:
        async with db.connect() as conn:
            # Episode jadvaliga qo'shish
            await conn.execute('''
                INSERT INTO movie_episodes (movie_id, episode_number, file_id, title)
                VALUES (?, ?, ?, ?)
            ''', (movie_id, episode_number, file_id, f"{episode_number}-qism"))
            
            # Movies jadvalidagi total_episodes ni yangilash
            await conn.execute('''
                UPDATE movies SET total_episodes = total_episodes + 1 WHERE id = ?
            ''', (movie_id,))
            
            await conn.commit()
        
        # Keyingi qism uchun tayyorlash
        await state.update_data(
            next_episode_number=episode_number + 1,
            added_episodes_count=added_count + 1
        )
        
        await message.answer(
            f"âœ… <b>{episode_number}-qism qo'shildi!</b>\n\n"
            f"ðŸ“º <b>Serial:</b> {series_name}\n"
            f"ðŸ“Š <b>Jami qismlar:</b> {episode_number} ta\n\n"
            f"ðŸ“¹ <b>Keyingi qism ({episode_number + 1}) uchun video yuboring</b>\n"
            f"Tugatish uchun /done",
            parse_mode=ParseMode.HTML
        )
        
        logger.info(f"Admin {user_id} serial qism qo'shdi: {series_name} - {episode_number}-qism")
        
    except Exception as e:
        logger.error(f"Episode qo'shishda xatolik: {e}")
        await message.answer("âŒ Xatolik yuz berdi! Qaytadan urinib ko'ring.")

@router.callback_query(F.data == "admin_add_premium_movie")
async def handle_admin_add_premium_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Premium film qo'shish (nom so'rash)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ’Ž <b>PREMIUM FILM QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Film nomini yozing\n"
        "2. Keyin video qismlarini yuborish mumkin (cheksiz)\n"
        "3. Har bir qism avtomatik bazaga saqlanadi (HD/4K)\n"
        "4. Jarayonni to'xtatish uchun /cancel\n\n"
        "ðŸ“ <b>Film nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()
    
    await state.update_data(is_premium=1)  # Premium film
    await state.set_state(AdminStates.waiting_premium_movie_name)
    await callback.answer("âœ… Premium film qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_movie_name)
async def handle_movie_name(message: Message, state: FSMContext):
    """Admin: Film nomini qabul qilish va til/janr tanlash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    movie_name = message.text.strip()
    
    if not movie_name:
        await message.answer("âŒ Film nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(movie_name=movie_name, part_number=1)
    
    # Til va janr tanlash
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="movie_lang_uz")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="movie_lang_en")
    builder.button(text="âŒ O'tkazib yuborish", callback_data="movie_lang_skip")
    builder.adjust(2, 1)
    
    await message.answer(
        f"âœ… <b>Film nomi qabul qilindi!</b>\n\n"
        f"ðŸŽ¬ <b>Nomi:</b> {movie_name}\n\n"
        f"ðŸŒ <b>Tilni tanlang (ixtiyoriy):</b>",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_movie_language)

@router.callback_query(F.data.startswith("movie_lang_"))
async def handle_movie_language(callback: CallbackQuery, state: FSMContext):
    """Admin: Film tilini tanlash va janr so'rash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    lang_data = callback.data.replace("movie_lang_", "")
    language = "uz" if lang_data == "uz" else ("en" if lang_data == "en" else "")
    
    await state.update_data(movie_language=language)
    
    # Janr tanlash
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ¬ Multfilm", callback_data="movie_genre_Animation")
    builder.button(text="ðŸŽ¬ Action", callback_data="movie_genre_Action")
    builder.button(text="ðŸŽ¬ Comedy", callback_data="movie_genre_Comedy")
    builder.button(text="ðŸŽ¬ Drama", callback_data="movie_genre_Drama")
    builder.button(text="ðŸŽ¬ Horror", callback_data="movie_genre_Horror")
    builder.button(text="ðŸŽ¬ Romance", callback_data="movie_genre_Romance")
    builder.button(text="ðŸŽ¬ Sci-Fi", callback_data="movie_genre_Sci-Fi")
    builder.button(text="ðŸŽ¬ Thriller", callback_data="movie_genre_Thriller")
    builder.button(text="ðŸ“‚ Boshqa", callback_data="movie_genre_Boshqa")
    builder.button(text="âŒ O'tkazib yuborish", callback_data="movie_genre_skip")
    builder.adjust(2, 2, 2, 2, 1, 1)
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    lang_text = "ðŸ‡ºðŸ‡¿ O'zbek" if language == "uz" else ("ðŸ‡¬ðŸ‡§ English" if language == "en" else "âŒ Tanlanmadi")
    
    await safe_edit_text(callback,
        f"âœ… <b>Til:</b> {lang_text}\n\n"
        f"ðŸŽ¬ <b>Film:</b> {movie_name}\n\n"
        f"ðŸ“‚ <b>Janrni tanlang (ixtiyoriy):</b>",
        reply_markup=builder.as_markup()
    )
    await state.set_state(AdminStates.waiting_movie_genre_select)
    await callback.answer()

@router.callback_query(F.data.startswith("movie_genre_"))
async def handle_movie_genre_select(callback: CallbackQuery, state: FSMContext):
    """Admin: Film janrini tanlash va video so'rash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    genre_data = callback.data.replace("movie_genre_", "")
    genre = genre_data if genre_data != "skip" else ""
    
    await state.update_data(movie_genre=genre)
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    language = data.get('movie_language', '')
    lang_text = "ðŸ‡ºðŸ‡¿ O'zbek" if language == "uz" else ("ðŸ‡¬ðŸ‡§ English" if language == "en" else "")
    genre_text = genre if genre else "âŒ Tanlanmadi"
    
    await safe_edit_text(callback,
        f"âœ… <b>Ma'lumotlar:</b>\n\n"
        f"ðŸŽ¬ <b>Film:</b> {movie_name}\n"
        f"ðŸŒ <b>Til:</b> {lang_text}\n"
        f"ðŸ“‚ <b>Janr:</b> {genre_text}\n\n"
        f"ðŸ“Ž <b>Endi video qismlarini yuborishingiz mumkin:</b>\n"
        f"â€¢ Birinchi qismni yuboring\n"
        f"â€¢ Keyin ikkinchi, uchinchi va hokazo (cheksiz)\n"
        f"â€¢ Har bir qism avtomatik bazaga saqlanadi\n"
        f"â€¢ To'xtatish uchun /cancel\n\n"
        f"ðŸ“¹ <b>Birinchi video qismini yuboring:</b>",
        reply_markup=Keyboards.cancel_button()
    )
    
    await state.set_state(AdminStates.waiting_movie_parts)
    await callback.answer()

@router.message(AdminStates.waiting_premium_movie_name)
async def handle_premium_movie_name(message: Message, state: FSMContext):
    """Admin: Premium film nomini qabul qilish va video so'rash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    movie_name = message.text.strip()
    
    if not movie_name:
        await message.answer("âŒ Film nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(movie_name=movie_name, part_number=1)
    
    await message.answer(
        f"âœ… <b>Premium film nomi qabul qilindi!</b>\n\n"
        f"ðŸ’Ž <b>Nomi:</b> {movie_name}\n"
        f"ðŸ“º <b>Tip:</b> Premium (HD/4K)\n\n"
        f"ðŸ“Ž <b>Endi video qismlarini yuborishingiz mumkin:</b>\n"
        f"â€¢ Birinchi qismni yuboring\n"
        f"â€¢ Keyin ikkinchi, uchinchi va hokazo (cheksiz)\n"
        f"â€¢ Har bir qism avtomatik bazaga saqlanadi\n"
        f"â€¢ To'xtatish uchun /cancel\n\n"
        f"ðŸ“¹ <b>Birinchi video qismini yuboring:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_movie_parts)

@router.message(AdminStates.waiting_movie_name, F.text == "/cancel")
async def handle_admin_cancel_movie_name(message: Message, state: FSMContext):
    """Admin: Film nomini bekor qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        return
    
    await state.clear()
    await message.answer(
        "âŒ <b>Film qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.message(AdminStates.waiting_premium_movie_name, F.text == "/cancel")
async def handle_admin_cancel_premium_movie_name(message: Message, state: FSMContext):
    """Admin: Premium film nomini bekor qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        return
    
    await state.clear()
    await message.answer(
        "âŒ <b>Premium film qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.message(AdminStates.waiting_movie_parts, F.video)
async def handle_admin_movie_parts(message: Message, state: FSMContext):
    """Admin: Film qismlarini qabul qilish va avtomatik saqlash (cheksiz)"""
    user_id = message.from_user.id
    
    if not await check_is_admin(user_id, db):
        await message.answer("âŒ Siz admin emassiz!")
        await state.clear()
        return
    
    if not message.video:
        await message.answer("âŒ Video topilmadi! Video yuboring yoki /cancel tugmasini bosing.", reply_markup=Keyboards.cancel_button())
        return
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    is_premium = data.get('is_premium', 0)
    part_number = data.get('part_number', 1)
    
    file_id = message.video.file_id
    original_caption = message.caption or f"{movie_name} - Qism {part_number}"
    
    # Avtomatik janr tanlash va matn tozalash
    genre = "Boshqa"
    cleaned_caption = original_caption
    quality = "720p"
    
    # Bazadan mavjud janrlarni olish va avtomatik tanlash
    try:
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT DISTINCT genre, COUNT(*) as count 
                FROM movies 
                WHERE is_active = 1 AND genre IS NOT NULL AND genre != '' AND genre != 'Boshqa'
                GROUP BY genre
                ORDER BY count DESC
                LIMIT 20
            ''')
            existing_genres = await cursor.fetchall()
            
            # Caption'dan janrni aniqlash
            if UTILS_AVAILABLE:
                try:
                    genre = detect_genre(original_caption, "movie")
                    cleaned_caption = clean_text(original_caption) or original_caption
                    quality = detect_quality_from_caption(original_caption)
                except Exception as e:
                    logger.error(f"Avtomatik tahlil xatosi: {e}")
                    cleaned_caption = clean_text(original_caption) if UTILS_AVAILABLE else original_caption
    except Exception as e:
        logger.error(f"Janr olish xatosi: {e}")
    
    # Janrda " belgisini olib tashlash
    genre = genre.replace('"', '').replace("'", "").strip()
    if not genre or genre == "":
        genre = "Boshqa"
    
    # Premium uchun sifatni avtomatik belgilash (agar aniqlanmagan bo'lsa)
    if is_premium and quality == "720p":
        quality = "1080p"  # Premium uchun default HD
    
    # Bazaga saqlash
    try:
        success = await db.add_movie(file_id, cleaned_caption, genre=genre, quality=quality)
        
        if success:
            # Keyingi qism uchun raqamni oshirish
            await state.update_data(part_number=part_number + 1)
            
            movie_type = "ðŸ’Ž Premium" if is_premium else "ðŸŽ¬ Standart"
            genre_display = genre if genre != "Boshqa" else "Boshqa (avtomatik aniqlanmadi)"
            await message.answer(
                f"âœ… <b>Qism {part_number} muvaffaqiyatli qo'shildi!</b>\n\n"
                f"{movie_type} <b>Film:</b> {movie_name}\n"
                f"ðŸ“º <b>Sifat:</b> {quality}\n"
                f"ðŸ“‚ <b>Janr:</b> {genre_display}\n"
                f"ðŸ“Š <b>Qism:</b> {part_number}\n\n"
                f"ðŸ“Ž <b>Keyingi qismni yuborishingiz mumkin yoki /cancel tugmasini bosing.</b>",
                reply_markup=Keyboards.cancel_button(),
                parse_mode=ParseMode.HTML
            )
            logger.info(f"Admin {user_id} film qismi qo'shdi: {movie_name}, qism {part_number}, quality: {quality}, premium: {is_premium}")
        else:
            await message.answer(
                "âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.\n\n"
                "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
                reply_markup=Keyboards.cancel_button()
            )
    except Exception as e:
        logger.error(f"Film qo'shish xatosi: {e}", exc_info=True)
        await message.answer(
            f"âŒ Xatolik yuz berdi: {str(e)}\n\n"
            "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
            reply_markup=Keyboards.cancel_button()
        )

@router.message(AdminStates.waiting_movie_parts, F.text == "/cancel")
async def handle_cancel_movie_parts(message: Message, state: FSMContext):
    """Admin: Film qismlarini qo'shishni to'xtatish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        return
    
    data = await state.get_data()
    movie_name = data.get('movie_name', 'Kino')
    part_number = data.get('part_number', 1)
    is_premium = data.get('is_premium', 0)
    total_parts = part_number - 1
    
    movie_type = "ðŸ’Ž Premium" if is_premium else "ðŸŽ¬ Standart"
    
    await state.clear()
    await message.answer(
        f"âœ… <b>Film qo'shish yakunlandi!</b>\n\n"
        f"{movie_type} <b>Film:</b> {movie_name}\n"
        f"ðŸ“Š <b>Jami qismlar:</b> {total_parts}\n\n"
        f"Barcha qismlar bazaga saqlangan!",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.message(AdminStates.waiting_add_movie_file, F.video)
async def handle_admin_movie_file(message: Message, state: FSMContext):
    """Admin: Film faylini qabul qilish va sifat sozlamasini so'rash"""
    user_id = message.from_user.id
    
    if not await check_is_admin(user_id, db):
        await message.answer("âŒ Siz admin emassiz!")
        await state.clear()
        return
    
    if not message.video:
        await message.answer("âŒ Video topilmadi! Video yuboring yoki /cancel tugmasini bosing.", reply_markup=Keyboards.cancel_button())
        return
    
    file_id = message.video.file_id
    caption = message.caption or message.video.file_name or "Kino"
    
    # File ID va caption ni state ga saqlash
    await state.update_data(file_id=file_id, caption=caption)
    
    # Sifat sozlamasini so'rash
    builder = InlineKeyboardBuilder()
    builder.button(text="480p", callback_data="quality_480p")
    builder.button(text="720p", callback_data="quality_720p")
    builder.button(text="1080p (HD)", callback_data="quality_1080p")
    builder.button(text="4K (2160p)", callback_data="quality_4k")
    builder.button(text="âŒ Bekor qilish", callback_data="cancel_add_movie")
    builder.adjust(2, 2, 1)
    
    await message.answer(
        f"ðŸŽ¬ <b>Film qo'shish</b>\n\n"
        f"ðŸ“½ï¸ <b>Nomi:</b> {caption}\n\n"
        f"ðŸ“º <b>Video sifatini tanlang:</b>",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data.startswith("quality_"))
async def handle_movie_quality(callback: CallbackQuery, state: FSMContext):
    """Admin: Film sifatini tanlash va saqlash"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    quality_map = {
        "quality_480p": "480p",
        "quality_720p": "720p",
        "quality_1080p": "1080p",
        "quality_4k": "4K"
    }
    
    quality = quality_map.get(callback.data, "720p")
    
    data = await state.get_data()
    file_id = data.get('file_id')
    original_caption = data.get('caption', 'Kino')
    
    # Avtomatik janr tanlash va matn tozalash
    genre = "Boshqa"
    cleaned_caption = original_caption
    
    if UTILS_AVAILABLE:
        try:
            # Janrni aniqlash (tozalanmagan caption'dan)
            genre = detect_genre(original_caption, "movie")
            # Matnni tozalash
            cleaned_caption = clean_text(original_caption) or original_caption
            # Sifatni aniqlash (agar caption'da bo'lsa)
            detected_quality = detect_quality_from_caption(original_caption)
            if detected_quality != "720p":  # Agar aniqlangan bo'lsa
                quality = detected_quality
        except Exception as e:
            logger.error(f"Avtomatik tahlil xatosi: {e}")
            cleaned_caption = clean_text(original_caption) if UTILS_AVAILABLE else original_caption
    
    # Bazaga saqlash
    try:
        success = await db.add_movie(file_id, cleaned_caption, genre=genre, quality=quality)
        
        if success:
            genre_display = genre if genre != "Boshqa" else "Boshqa (avtomatik aniqlanmadi)"
            await callback.message.edit_text(
                f"âœ… <b>Film muvaffaqiyatli qo'shildi!</b>\n\n"
                f"ðŸŽ¬ <b>Nomi:</b> {cleaned_caption[:100]}\n"
                f"ðŸ“º <b>Sifat:</b> {quality}\n"
                f"ðŸ“‚ <b>Janr:</b> {genre_display}\n\n"
                f"Film endi bazada mavjud va foydalanuvchilar uni topa oladi!\n\n"
                f"ðŸ’¡ <b>Yana film qo'shish uchun video yuboring yoki /cancel tugmasini bosing.</b>",
                parse_mode=ParseMode.HTML
            )
            logger.info(f"Admin {user_id} film qo'shdi: {cleaned_caption}, quality: {quality}")
        else:
            await callback.message.edit_text(
                "âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.\n\n"
                "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
                reply_markup=Keyboards.cancel_button()
            )
    except Exception as e:
        logger.error(f"Admin movie add error: {e}", exc_info=True)
        await callback.message.edit_text(
            f"âŒ Xatolik yuz berdi: {str(e)}\n\n"
            "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
            reply_markup=Keyboards.cancel_button()
        )
    
    await state.clear()
    await callback.answer()

@router.callback_query(F.data == "cancel_add_movie")
async def handle_cancel_add_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Film qo'shishni bekor qilish"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await state.clear()
    await callback.message.edit_text(
        "âŒ <b>Film qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "premium_movies")
async def handle_premium_movies(callback: CallbackQuery):
    """Premium HD/4K kinolar (Premium foydalanuvchilar uchun)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Premium tekshiruvi
    if subscription_type < 2:
        await callback.answer(
            "âŒ Bu bo'lim faqat Premium foydalanuvchilar uchun!\n\n"
            "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    premium_movies = await db.get_premium_movies(limit=50)
    
    if not premium_movies:
        premium_text = "ðŸŽ¬ <b>HD/4K KINOLAR</b>\n\n"
        premium_text += "âŒ Hozircha HD/4K kinolar mavjud emas.\n\n"
        if subscription_type < 2:
            premium_text += "ðŸ’Ž <b>Premium obuna oling va HD/4K kinolarni ko'ring va yuklab oling!</b>\n\n"
            premium_text += "ðŸ“¤ HD/4K kinolar qo'shish uchun admin bilan bog'laning."
        else:
            premium_text += "ðŸ“¤ HD/4K kinolar qo'shish uchun admin bilan bog'laning."
        
        builder = InlineKeyboardBuilder()
        if subscription_type < 2:
            builder.button(text="ðŸ’Ž Premium obuna olish", callback_data="market_premium")
        builder.button(text="ðŸ”™ Kinoteatr", callback_data="cinema_menu")
        builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 2)
        
        await safe_edit_text(callback, premium_text, reply_markup=builder.as_markup())
        await callback.answer()
        return
    
    text = f"ðŸŽ¬ <b>HD/4K KINOLAR</b>\n\n"
    if subscription_type < 2:
        text += "ðŸ’Ž <b>Eslatma:</b> Bu kinolarni ko'rish va yuklab olish uchun Premium obuna kerak!\n\n"
    text += f"ðŸ“Š Jami: {len(premium_movies)} ta HD/4K kino\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, movie in enumerate(premium_movies[:20], 1):
        movie_title = movie.get('caption', 'Nomsiz')[:35] + "..." if len(movie.get('caption', '')) > 35 else movie.get('caption', 'Nomsiz')
        quality = movie.get('quality', '720p')
        text += f"{i}. <b>{movie_title}</b>\n"
        text += f"   ðŸ“º Sifat: {quality}\n"
        if movie.get('views'):
            text += f"   ðŸ‘ï¸ {movie.get('views', 0)} ko'rish\n"
        if subscription_type < 2:
            text += f"   ðŸ”’ Premium kerak\n"
        text += "\n"
        
        builder.button(text=f"ðŸŽ¬ {i}. {movie_title[:25]}", callback_data=f"watch_movie_{movie.get('id', 0)}")
    
    if len(premium_movies) > 20:
        text += f"\n... va yana {len(premium_movies) - 20} ta HD/4K kino\n"
    
    if subscription_type < 2:
        builder.button(text="ðŸ’Ž Premium obuna olish", callback_data="market_premium")
    builder.button(text="ðŸ”™ Kinoteatr", callback_data="cinema_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    if len(premium_movies) <= 10:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.message(F.text.in_(["ðŸŽ“ Kurslar", "Kurslar"]))
async def handle_courses(message: Message):
    """Kurslar bo'limi (OPTIMALLASHTIRILGAN - Marketing strategiya)"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "courses")
    
    menu_text = f"""
ðŸŽ“ <b>KURSLAR - PROFESSIONAL TA'LIM</b>

ðŸ’° <b>Barcha kurslar:</b> 19,990 so'm
ðŸ‘¨â€ðŸ« <b>Professional instructorlar</b> - Sertifikatlangan mutaxassislar
ðŸ“– <b>To'liq materiallar</b> - Video, PDF, kodlar
ðŸ’» <b>Amaliy topshiriqlar</b> - Real loyihalar
ðŸ† <b>Bitiruv sertifikati</b> - Ishga kirish uchun

ðŸ”¥ <b>Top kurslar:</b>
  ðŸ’» Python dasturlash - 500+ talaba
  ðŸŽ¨ Web dizayn - 300+ talaba
  ðŸ‡ºðŸ‡¸ Ingliz tili - 400+ talaba
  ðŸ’¼ Biznes menejment - 250+ talaba
  ðŸ¤– Sun'iy intellekt - 200+ talaba

ðŸ’¡ <b>Nima olasiz:</b>
  âœ… Hayotiy ko'nikmalar
  âœ… Ishga kirish imkoniyati
  âœ… Professional portfolio
  âœ… Doimiy qo'llab-quvvatlash

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await message.answer(menu_text, reply_markup=Keyboards.courses_menu(user.get('subscription_type', 0)), parse_mode=ParseMode.HTML)

@router.message(F.text == "ðŸ›’ Market")
async def handle_market(message: Message):
    """Market bo'limi (MARKETING STRATEGIYA)"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "market")
    
    user_xp = user.get('xp', 0)
    
    menu_text = f"""
ðŸ›’ <b>MARKET - XP DO'KONI</b>

ðŸ’° <b>Sizning XP: {user_xp:,}</b>

ðŸŽ <b>XP evaziga sotib olish:</b>
  â­ Premium tariflar (1-30 kun)
  ðŸ”¥ PRO obuna (30 kun)
  ðŸ’Ž Exclusive obuna (30 kun)

ðŸ¦ <b>To'lov orqali Premium:</b>
  ðŸ’Ž Premium: 19,990 so'm
  ðŸ”¥ PRO: 29,990 so'm
  ðŸ¥‡ Exclusive: 39,990 so'm
  ðŸ† Exclusive Pro+: 59,990 so'm

ðŸŽ° <b>Fortune Wheel (Aylana):</b>
  ðŸŽ Har kuni 1 marta bepul
  ðŸ’° 25-1000 XP yutib olish
  ðŸŽ¯ Bonus imkoniyatlar

ðŸ’¡ <b>Maslahat:</b>
  â€¢ XP to'plash uchun kunlik bonus oling
  â€¢ Referal taklif qiling
  â€¢ Kurslar yuklab pul ishlang

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await message.answer(menu_text, reply_markup=Keyboards.market_menu(user_xp), parse_mode=ParseMode.HTML)

@router.message(F.text == "ðŸ‘¥ Referal")
async def handle_referral(message: Message):
    """Referal bo'limi (MARKETING STRATEGIYA)"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "referral")
    
    # Referal statistikasini olish
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('''
                SELECT 
                    COUNT(*) as total_referrals,
                    SUM(xp_gained) as total_xp_earned,
                    SUM(limit_gained) as total_limit_earned
                FROM referrals 
                WHERE referrer_id = ?
            ''', (user_id,))
            ref_stats = await cursor.fetchone()
            total_refs = ref_stats['total_referrals'] or 0 if ref_stats else 0
            total_xp = ref_stats['total_xp_earned'] or 0 if ref_stats else 0
            total_limit = ref_stats['total_limit_earned'] or 0 if ref_stats else 0
        except Exception:
            total_refs = 0
            total_xp = 0
            total_limit = 0
    
    # Keyingi bonusni hisoblash
    next_bonus_at = 10 - (total_refs % 10) if total_refs % 10 != 0 else 0
    premium_bonus_count = total_refs // 10
    
    referral_link = f"https://t.me/{(await bot.get_me()).username}?start={user_id}"
    
    referral_text = f"""
ðŸ‘¥ <b>REFERAL TIZIMI - PUL ISHLASH</b>

ðŸ’° <b>Statistika:</b>
  ðŸ‘¥ Jami referallar: {total_refs}
  ðŸ’° Olingan XP: {total_xp:,}
  ðŸ¤– Olingan AI limit: {total_limit}
  ðŸŽ Premium bonuslar: {premium_bonus_count} ta (har 10 referal uchun)
  ðŸŽ¯ Keyingi Premium bonus: {next_bonus_at} referal qoldi

ðŸŽ <b>Bonuslar:</b>
  âœ… Har 1 referal: 75 XP + 1 AI limit
  âœ… Har 10 referal: 3 kunlik Premium obuna
  âœ… Har 20 referal: 7 kunlik Premium obuna
  âœ… Har 50 referal: 30 kunlik Premium obuna

ðŸ”— <b>Sizning referal havolangiz:</b>
<code>{referral_link}</code>

ðŸ’¡ <b>Qanday ishlatish:</b>
  1. Havolani nusxalang yoki ulashish tugmasini bosing
  2. Do'stlaringizga yuboring
  3. Ular botga qo'shilganda siz avtomatik bonus olasiz!
  4. Ko'proq do'st = Ko'proq pul!

ðŸš€ <b>Nima uchun ajoyib:</b>
  â€¢ Bepul pul ishlash
  â€¢ Cheksiz referallar
  â€¢ Premium obuna bepul
  â€¢ Do'stlaringizga foyda

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”— Referal linkni ulashish", url=f"tg://msg_url?url={referral_link}&text=Nexus Media - Kitoblar, filmlar, kurslar va AI Mentor!")
    builder.button(text="ðŸ“‹ Nusxa olish", callback_data="copy_referral")
    builder.button(text="ðŸŽ Bonuslar", callback_data="bonus_menu")
    builder.button(text="ðŸ“Š Referal statistikasi", callback_data="referral_stats")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1)
    
    await message.answer(referral_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(F.text == "ðŸ†˜ Yordam & Support")
async def handle_help(message: Message):
    """Yordam bo'limi (MARKETING STRATEGIYA)"""
    user_id = message.from_user.id
    await db.update_user_activity(user_id)
    analytics.track_command(user_id, "help")
    
    help_text = f"""
ðŸ“– <b>NEXUS MEDIA - TO'LIQ QO'LLANMA</b>

ðŸš€ <b>BOT HAQIDA:</b>
Nexus Media - eng katta kontent bazasi!
ðŸ“š 1000+ kitob  ðŸŽ¬ 500+ film  ðŸŽ“ 100+ kurs  ðŸ¤– AI Mentor

ðŸ“š <b>KUTUBXONA:</b>
â€¢ Janr bo'yicha qidirish
â€¢ Muallif bo'yicha qidirish
â€¢ Kitob yuklash (PDF, DOC, TXT)
â€¢ Kitob yuklash va pul ishlash
â€¢ Premium kitoblar (Exclusive/Pro uchun)

ðŸŽ¬ <b>KINOTEATR:</b>
â€¢ 14+ janr (Drama, Komediya, Ilmiy filmlar...)
â€¢ Sifat: 480p (bepul), 720p (Exclusive), 1080p/4K (Pro)
â€¢ Kod orqali qidirish
â€¢ Top filmlar

ðŸŽ“ <b>KURSLAR:</b>
â€¢ 10+ kategoriya
â€¢ Demo videolar
â€¢ AI Mentor bilan kurs haqida savol
â€¢ Kurs yuklash va pul ishlash (5,000 so'm/sotilgan)
â€¢ Mening kurslarim

ðŸ¤– <b>AI MENTOR:</b>
â€¢ Har qanday savolga javob
â€¢ Kod yozishda yordam
â€¢ Matn tahlili va tarjima
â€¢ Suhbat tarixi saqlanadi
â€¢ Limit: 10 ta (trial), 50+ (Premium)

ðŸ’Ž <b>PREMIUM OBUNA:</b>
â€¢ Exclusive (39,990 so'm) - 200 AI limit, 1080p/4K
â€¢ Exclusive Pro+ (59,990 so'm) - Cheksiz AI, 4K
â€¢ XP evaziga Premium (Market bo'limida)

ðŸ‘¥ <b>REFERAL TIZIMI:</b>
â€¢ Har do'st uchun: 75 XP + 1 AI limit
â€¢ Har 10 do'st uchun: 3 kunlik Premium
â€¢ Referal linkni ulashish

ðŸ’° <b>BALANS VA TO'LOV:</b>
â€¢ Click, Payme, Uzumbank, Apelsin
â€¢ Karta raqami: {Config.PAYMENT_CARD}
â€¢ Balans to'ldirish
â€¢ XP evaziga Premium

ðŸ“Š <b>STATISTIKA:</b>
â€¢ Shaxsiy statistika
â€¢ Reyting jadvali
â€¢ Liga tizimi (Bronza, Kumush, Oltin)

ðŸŽ« <b>SUPPORT:</b>
â€¢ Ticket yaratish (rasm, video, fayl, matn)
â€¢ Admin javobi
â€¢ Status kuzatish

ðŸ“± <b>KOMANDALAR:</b>
/start - Botni qayta ishga tushirish
/help - Qo'llanma (bu xabar)
/profile - Profil
/stats - Statistika
/premium - Premium obuna
/support - Yordam

ðŸ‘¨â€ðŸ’¼ <b>SUPPORT:</b>
{Config.SUPPORT_USERNAME}
24/7 javob (48 soat ichida)

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await message.answer(help_text, reply_markup=Keyboards.help_menu(), parse_mode=ParseMode.HTML)

# Til tanlash handler
@router.callback_query(F.data.startswith("lang_"))
async def handle_language_selection(callback: CallbackQuery):
    """Til tanlash va welcome video yuborish"""
    lang_code = callback.data.replace("lang_", "")
    user_id = callback.from_user.id
    
    await db.update_user_language(user_id, lang_code)
    user_lang = await db.get_user_language(user_id)
    
    await callback.answer(Translations.get('language_set', user_lang))
    
    full_name = callback.from_user.full_name or callback.from_user.username
    
    # Foydalanuvchi yangi ekanligini tekshirish
    user = await db.get_user(user_id)
    is_new_user = user is None or (user.get('trial_offered', 0) == 0 and user.get('subscription_type', 0) == 0)
    
    # Eski xabarni o'chirish
    await callback.message.delete()
    
    # Welcome video yuborish (agar mavjud bo'lsa va yangi foydalanuvchi bo'lsa)
    if is_new_user and Config.WELCOME_VIDEO_FILE_ID:
        try:
            # Trial taklif tugmalari bilan video yuborish
            trial_builder = InlineKeyboardBuilder()
            if user_lang == 'uz':
                trial_builder.button(text="âœ… Albatta", callback_data="accept_trial")
                trial_builder.button(text="â¸ï¸ Hozircha yo'q", callback_data="decline_trial")
                trial_caption = f"ðŸ‘‹ <b>{Translations.get('welcome', user_lang, name=full_name)}</b>\n\nðŸŽ <b>1 soatlik Premium Trial taklifini sinab ko'rasizmi?</b>"
            elif user_lang == 'ru':
                trial_builder.button(text="âœ… ÐšÐ¾Ð½ÐµÑ‡Ð½Ð¾", callback_data="accept_trial")
                trial_builder.button(text="â¸ï¸ ÐŸÐ¾ÐºÐ° Ð½ÐµÑ‚", callback_data="decline_trial")
                trial_caption = f"ðŸ‘‹ <b>{Translations.get('welcome', user_lang, name=full_name)}</b>\n\nðŸŽ <b>ÐŸÐ¾Ð¿Ñ€Ð¾Ð±Ð¾Ð²Ð°Ñ‚ÑŒ 1-Ñ‡Ð°ÑÐ¾Ð²Ð¾Ð¹ Premium Trial?</b>"
            else:  # en
                trial_builder.button(text="âœ… Sure", callback_data="accept_trial")
                trial_builder.button(text="â¸ï¸ Not now", callback_data="decline_trial")
                trial_caption = f"ðŸ‘‹ <b>{Translations.get('welcome', user_lang, name=full_name)}</b>\n\nðŸŽ <b>Try 1-hour Premium Trial now?</b>"
            
            trial_builder.adjust(2)
            
            # Welcome video yuborish
            await bot.send_video(
                chat_id=user_id,
                video=Config.WELCOME_VIDEO_FILE_ID,
                caption=trial_caption,
                reply_markup=trial_builder.as_markup(),
                parse_mode=ParseMode.HTML
            )
            
            # Asosiy menyu alohida xabar sifatida
            if user_lang == 'uz':
                menu_text = "<b>Quyidagi bo'limlardan birini tanlang:</b>"
            elif user_lang == 'ru':
                menu_text = "<b>Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð²:</b>"
            else:  # en
                menu_text = "<b>Select one of the sections:</b>"
            
            await bot.send_message(
                chat_id=user_id,
                text=menu_text,
                reply_markup=Keyboards.main_menu(user_id),
                parse_mode=ParseMode.HTML
            )
            return
        except Exception as e:
            logger.error(f"Welcome video yuborishda xatolik: {e}")
            # Video yuborishda xatolik bo'lsa, matnli xabarni yuboramiz
    
    # Video yo'q bo'lsa yoki xatolik bo'lsa, oddiy matnli xabar
    if user_lang == 'uz':
        welcome_text = f"""
<b>{Translations.get('welcome', user_lang, name=full_name)}</b>

<b>Nexus Media</b> botiga xush kelibsiz!

<b>Bizning imkoniyatlar:</b>
â€¢ 100,000+ kitob
â€¢ 30,000+ film
â€¢ 100+ kurs

<b>Bot haqida:</b>
â€¢ Eng katta kitob, film va kurslar bazasi
â€¢ AI Mentor - har qanday savolga javob
â€¢ Premium kontentlar va eksklyuziv materiallar
â€¢ Referal tizimi orqali daromad olish

Quyidagi bo'limlardan birini tanlang:
        """
    elif user_lang == 'ru':
        welcome_text = f"""
<b>{Translations.get('welcome', user_lang, name=full_name)}</b>

<b>Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð² Nexus Media!</b>

<b>ÐÐ°ÑˆÐ¸ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚Ð¸:</b>
â€¢ 100,000+ ÐºÐ½Ð¸Ð³
â€¢ 30,000+ Ñ„Ð¸Ð»ÑŒÐ¼Ð¾Ð²
â€¢ 100+ ÐºÑƒÑ€ÑÐ¾Ð²

<b>Ðž Ð±Ð¾Ñ‚Ðµ:</b>
â€¢ Ð¡Ð°Ð¼Ð°Ñ Ð±Ð¾Ð»ÑŒÑˆÐ°Ñ Ð±Ð°Ð·Ð° ÐºÐ½Ð¸Ð³, Ñ„Ð¸Ð»ÑŒÐ¼Ð¾Ð² Ð¸ ÐºÑƒÑ€ÑÐ¾Ð²
â€¢ AI Mentor - Ð¾Ñ‚Ð²ÐµÑ‚Ñ‹ Ð½Ð° Ð»ÑŽÐ±Ñ‹Ðµ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹
â€¢ ÐŸÑ€ÐµÐ¼Ð¸ÑƒÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐ½Ñ‚ Ð¸ ÑÐºÑÐºÐ»ÑŽÐ·Ð¸Ð²Ð½Ñ‹Ðµ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ñ‹
â€¢ Ð—Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð¾Ðº Ñ‡ÐµÑ€ÐµÐ· Ñ€ÐµÑ„ÐµÑ€Ð°Ð»ÑŒÐ½ÑƒÑŽ ÑÐ¸ÑÑ‚ÐµÐ¼Ñƒ

Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð²:
        """
    else:  # en
        welcome_text = f"""
<b>{Translations.get('welcome', user_lang, name=full_name)}</b>

<b>Welcome to Nexus Media!</b>

<b>Our features:</b>
â€¢ 100,000+ books
â€¢ 30,000+ movies
â€¢ 100+ courses

<b>About the bot:</b>
â€¢ Largest database of books, movies and courses
â€¢ AI Mentor - answers to any questions
â€¢ Premium content and exclusive materials
â€¢ Earn money through referral system

Select one of the sections:
        """
    
    await callback.message.answer(welcome_text, reply_markup=Keyboards.main_menu(user_id), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "accept_trial")
async def handle_accept_trial(callback: CallbackQuery):
    """1 soatlik trial qabul qilish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    # Trial allaqachon ishlatilganmi tekshirish
    trial_used = user.get('trial_used', 0)
    if trial_used:
        await callback.answer("âŒ Siz allaqachon trial ishlatgansiz!", show_alert=True)
        return
    
    # Trial boshlash
    success = await db.start_trial(user_id)
    
    if success:
        # Video xabarni o'chirish
        try:
            await callback.message.delete()
        except:
            pass
            
        await callback.message.answer(
            f"ðŸŽ‰ <b>Tabriklaymiz!</b>\n\n"
            f"âœ… 1 soatlik Premium Trial aktivlashtirildi!\n\n"
            f"ðŸ’Ž <b>Premium imkoniyatlar:</b>\n"
            f"  â€¢ Cheksiz yuklab olish\n"
            f"  â€¢ Premium kitoblar va filmlar\n"
            f"  â€¢ Audio kitoblar\n"
            f"  â€¢ Har soatda avtomatik XP\n"
            f"  â€¢ AI Mentor cheksiz\n\n"
            f"â° <b>Muddati:</b> 1 soat\n\n"
            f"ðŸš€ Botdan to'liq foydalaning!",
            parse_mode=ParseMode.HTML
        )
        await callback.message.answer(
            "Asosiy menyu:",
            reply_markup=Keyboards.main_menu(user_id)
        )
        await callback.answer("âœ… Trial aktivlashtirildi!")
        logger.info(f"Trial qabul qilindi: user_id={user_id}")
    else:
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data == "decline_trial")
async def handle_decline_trial(callback: CallbackQuery):
    """Trial taklifini rad etish"""
    user_id = callback.from_user.id
    
    # Video xabarni o'chirish
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        f"âœ… <b>Tushunarli!</b>\n\n"
        f"Istalgan vaqtda Premium obuna olishingiz mumkin.\n\n"
        f"ðŸ’Ž Premium obuna uchun /premium buyrug'ini yuboring.",
        parse_mode=ParseMode.HTML
    )
    await callback.message.answer(
        "Asosiy menyu:",
        reply_markup=Keyboards.main_menu(user_id)
    )
    await callback.answer()
    logger.info(f"Trial rad etildi: user_id={user_id}")

@router.message(Command("promo"))
async def handle_promo_command(message: Message, state: FSMContext):
    """Promo kod ishlatish komandasi"""
    user_id = message.from_user.id
    
    await message.answer(
        "ðŸŽ <b>PROMO KOD</b>\n\n"
        "Promo kodni kiriting:\n\n"
        "ðŸ’¡ <b>Promo kod nima beradi:</b>\n"
        "  â€¢ XP bonuslar\n"
        "  â€¢ Premium obuna\n"
        "  â€¢ AI limit\n\n"
        "âŒ Bekor qilish: /cancel",
        parse_mode=ParseMode.HTML
    )
    await state.set_state(UserStates.waiting_promo_code)

@router.message(UserStates.waiting_promo_code)
async def handle_promo_code_input(message: Message, state: FSMContext):
    """Promo kod kiritish"""
    user_id = message.from_user.id
    promo_code = message.text.strip().upper()
    
    if promo_code == "/CANCEL":
        await state.clear()
        await message.answer("âŒ Bekor qilindi.", reply_markup=Keyboards.main_menu(user_id))
        return
    
    # Promo kodni ishlatish
    success, msg, data = await db.use_promo_code(user_id, promo_code)
    
    if success:
        await message.answer(
            f"ðŸŽ‰ <b>TABRIKLAYMIZ!</b>\n\n"
            f"{msg}\n\n"
            f"âœ… Promo kod muvaffaqiyatli ishlatildi!",
            reply_markup=Keyboards.main_menu(user_id),
            parse_mode=ParseMode.HTML
        )
        logger.info(f"Promo kod ishlatildi: user_id={user_id}, code={promo_code}")
    else:
        await message.answer(
            f"{msg}\n\n"
            f"ðŸ’¡ Iltimos, to'g'ri promo kodni kiriting.",
            parse_mode=ParseMode.HTML
        )
    
    await state.clear()

@router.callback_query(F.data == "use_promo")
async def handle_use_promo_callback(callback: CallbackQuery, state: FSMContext):
    """Promo kod ishlatish callback"""
    await callback.message.answer(
        "ðŸŽ <b>PROMO KOD</b>\n\n"
        "Promo kodni kiriting:\n\n"
        "ðŸ’¡ <b>Promo kod nima beradi:</b>\n"
        "  â€¢ XP bonuslar\n"
        "  â€¢ Premium obuna\n"
        "  â€¢ AI limit\n\n"
        "âŒ Bekor qilish: /cancel",
        parse_mode=ParseMode.HTML
    )
    await state.set_state(UserStates.waiting_promo_code)
    await callback.answer()

@router.message(F.text.in_(["ðŸŽ® Gamification", "Gamification"]))
async def handle_gamification_text(message: Message):
    """Gamification Hub - WebApp'ga yo'naltirish"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    xp = user.get('xp', 0)
    gold = user.get('gold', 0)
    level = user.get('level', 1)
    streak = user.get('streak_count', 0)
    
    text = f"""
ðŸŽ® <b>GAMIFICATION HUB</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â­ <b>XP:</b> {xp:,}
ðŸª™ <b>Gold:</b> {gold:,}
ðŸ“ˆ <b>Level:</b> {level}
ðŸ”¥ <b>Streak:</b> {streak} kun
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸš€ <b>To'liq funksiyalar uchun WebApp'ni oching!</b>

<b>WebApp imkoniyatlari:</b>
â€¢ ðŸ† Real-time Leaderboard
â€¢ ðŸ… Achievements & Badges
â€¢ ðŸŽ¯ Daily Challenges
â€¢ âš¡ Live Battle Quiz
â€¢ ðŸ“Š Statistika va Analytics
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(
        text="ðŸš€ WebApp'ni ochish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=gamification&user_id={user_id}")
    )
    builder.button(text="ðŸ† Leaderboard", callback_data="leaderboard_menu")
    builder.button(text="ðŸ… Achievements", callback_data="achievements_menu")
    builder.button(text="ðŸŽ¯ Daily Challenge", callback_data="daily_challenge")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 2, 2)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(F.text.in_(["ðŸ¤– AI Mentor", "AI Mentor"]))
async def handle_ai_mentor(message: Message):
    """AI Mentor bo'limi (GPT-4 integratsiya - OPTIMALLASHTIRILGAN)"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    # Rate limiting
    if not rate_limiter.is_allowed(user_id):
        await message.answer("Juda ko'p so'rov. Iltimos, biroz kuting.")
        return
    
    analytics.track_command(user_id, "ai_mentor")
    await db.update_user_activity(user_id)
    
    # Subscription type bo'yicha limit tekshirish
    sub_type = user.get('subscription_type', 0)
    ai_limit = user.get('ai_limit', Config.DAILY_AI_LIMITS.get(sub_type, 0))
    
    menu_text = f"""
ðŸ¤– <b>AI MENTOR</b>

ðŸŽ¯ <b>Sizning statusingiz:</b> {DatabaseManager.get_subscription_name(sub_type)}
ðŸ’¬ <b>AI limit:</b> {ai_limit} ta qoldi

ðŸš€ <b>AI imkoniyatlari:</b>
  Har qanday savolga javob (GPT-4)
  Kod yozishda yordam
  Matn tahlili va tahri
  Ingliz tilidan tarjima
  Rasmlarni tahlil qilish

ðŸ“š <b>Kontekst xotirasi:</b>
  Premium foydalanuvchilar uchun suhbat tarixi
  Har savol uchun 1 limit sarflanadi
  Limit tugaganda, XP evaziga sotib olish

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await message.answer(menu_text, reply_markup=Keyboards.ai_menu(
        user_ai_limit=ai_limit,
        user_subscription=sub_type
    ), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "ai_menu")
async def handle_ai_menu_callback(callback: CallbackQuery):
    """AI Mentor menyusi callback"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    sub_type = user.get('subscription_type', 0)
    ai_limit = user.get('ai_limit', Config.DAILY_AI_LIMITS.get(sub_type, 0))
    
    menu_text = f"""
ðŸ¤– <b>AI MENTOR</b>

ðŸŽ¯ <b>Sizning statusingiz:</b> {DatabaseManager.get_subscription_name(sub_type)}
ðŸ’¬ <b>AI limit:</b> {ai_limit} ta qoldi

ðŸš€ <b>AI imkoniyatlari:</b>
  Har qanday savolga javob (GPT-4)
  Kod yozishda yordam
  Matn tahlili va tahri
  Ingliz tilidan tarjima
  Rasmlarni tahlil qilish

ðŸ“š <b>Kontekst xotirasi:</b>
  Premium foydalanuvchilar uchun suhbat tarixi
  Har savol uchun 1 limit sarflanadi
  Limit tugaganda, XP evaziga sotib olish

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await callback.message.edit_text(menu_text, reply_markup=Keyboards.ai_menu(
        user_ai_limit=ai_limit,
        user_subscription=sub_type
    ), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "ask_ai")
async def handle_ask_ai(callback: CallbackQuery, state: FSMContext):
    """AI Mentor: Savol berish (OPTIMALLASHTIRILGAN)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    ai_limit = user.get('ai_limit', 0)
    if ai_limit <= 0:
        await callback.message.edit_text(
            "ðŸ¤– <b>AI MENTOR</b>\n\n"
            "âŒ <b>AI limit tugadi!</b>\n\n"
            "ðŸ”„ Limitni qayta to'ldirish uchun:\n"
            "ðŸŽ Kunlik bonus oling\n"
            "ðŸ‘¥ Referal taklif qiling\n"
            "ðŸ›’ Marketdan XP evaziga limit sotib oling\n"
            "ðŸ’Ž Premium obuna sotib olish\n\n"
            "ðŸ‘‡ Quyidagilardan birini tanlang:",
            reply_markup=Keyboards.ai_menu(ai_limit, user.get('subscription_type', 0)),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    await callback.message.edit_text(
        "ðŸ¤– <b>AI MENTOR</b>\n\n"
        f"ðŸ’¬ Savol qoldiq: {ai_limit} ta\n\n"
        "âœï¸ Savolingizni yozing yoki rasm yuboring:\n\n"
        "<i>Masalan:</i>\n"
        "<code>Python dasturlashda list va tuple farqi nima?</code>\n"
        "<code>Ingliz tilidan o'zbek tiliga tarjima qiling: Hello, how are you?</code>\n"
        "<code>Menga biznes reja tuzishda yordam bering</code>\n\n"
        "ðŸ–¼ï¸ Rasm yuborsangiz, unga tahlil qilaman\n\n"
        "âŒ Bekor qilish uchun /cancel",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(UserStates.waiting_ai_question)
    await db.set_user_chat_state(user_id, "ai_chat")
    await callback.answer()

@router.callback_query(F.data == "ai_info")
async def handle_ai_info(callback: CallbackQuery):
    """AI haqida ma'lumot"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    ai_info_text = f"""
ðŸ¤– <b>AI MENTOR HAQIDA</b>

ðŸš€ <b>AI imkoniyatlari:</b>
  â€¢ Har qanday savolga javob berish (GPT-4)
  â€¢ Kod yozishda yordam
  â€¢ Matn tahlili va tahri
  â€¢ Ingliz tilidan tarjima
  â€¢ Matematik masalalarni yechish
  â€¢ Loyiha rejalari tuzish
  â€¢ Rasmlarni tahlil qilish

ðŸ“š <b>Qanday foydalanish:</b>
  1. Savolingizni to'liq va aniq yozing
  2. AI javob beradi (1-2 daqiqa)
  3. Har bir savol 1 AI limit
  4. Agar javob to'liq bo'lmasa, qo'shimcha savol bering

âš¡ <b>Limitlar:</b>
  Bepul: 0 ta/kun
  Trial: 10 ta/kun
  Premium: 50 ta/kun
  PRO: 100 ta/kun
  Exclusive: 200 ta/kun
  Exclusive Pro+: Cheksiz

ðŸ¤ <b>Suhbatni davom ettirish:</b>
  Limit tugaguncha suhbatni davom ettiring
  Limit tugaganda, Marketdan sotib oling
  Premium obuna bilan cheksiz foydalaning

ðŸ‘‡ <b>Savol bering yoki orqaga qayting:</b>
    """
    
    await callback.message.edit_text(
        ai_info_text,
        reply_markup=Keyboards.back_button("ai_menu"),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "ai_history")
async def handle_ai_history(callback: CallbackQuery):
    """AI suhbatlar tarixi"""
    user_id = callback.from_user.id
    
    conversations = await db.get_ai_conversations(user_id, limit=5)
    
    if not conversations:
        await callback.message.edit_text(
            "ðŸ“œ <b>AI SUHBATLAR TARIXI</b>\n\n"
            "Hozircha sizda saqlangan suhbatlar yo'q.\n"
            "AI Mentor bilan suhbatlashishni boshlang!",
            reply_markup=Keyboards.back_button("ai_menu"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    history_text = "ðŸ“œ <b>AI SUHBATLAR TARIXI</b>\n\n"
    
    for i, conv in enumerate(conversations, 1):
        message_preview = conv.get('message', '')[:50] + "..." if len(conv.get('message', '')) > 50 else conv.get('message', '')
        response_preview = conv.get('response', '')[:50] + "..." if len(conv.get('response', '')) > 50 else conv.get('response', '')
        
        history_text += f"<b>{i}. Savol:</b> {message_preview}\n"
        history_text += f"<b>Javob:</b> {response_preview}\n"
        timestamp = conv.get('timestamp', '')
        if timestamp:
            history_text += f"<i>Vaqt:</i> {timestamp[:16]}\n"
        history_text += "\n"
    
    await callback.message.edit_text(
        history_text,
        reply_markup=Keyboards.back_button("ai_menu"),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "stop_ai_chat")
async def handle_stop_ai_chat(callback: CallbackQuery, state: FSMContext):
    """AI chatni to'xtatish"""
    user_id = callback.from_user.id
    await state.clear()
    await db.clear_user_chat_state(user_id)
    
    try:
        await callback.message.delete()
    except Exception:
        pass
    
    await callback.message.answer(
        "âœ… <b>AI chat to'xtatildi!</b>\n\n"
        "Siz asosiy menyuga qaytdingiz. Qayta AI Mentor dan foydalanish uchun "
        "asosiy menyudan 'ðŸ¤– AI Mentor' tugmasini bosing.",
        reply_markup=Keyboards.main_menu(user_id),
        parse_mode=ParseMode.HTML
    )
    await callback.answer("âœ… Chat to'xtatildi!")

@router.message(UserStates.waiting_ai_question)
async def handle_ai_question(message: Message, state: FSMContext):
    """AI Mentor: Savolni qabul qilish (OPTIMALLASHTIRILGAN - 100% ishlaydigan)"""
    user_id = message.from_user.id
    
    if message.text == "/cancel":
        await state.clear()
        await db.clear_user_chat_state(user_id)
        await message.answer("âŒ Savol bekor qilindi.", reply_markup=Keyboards.main_menu(user_id))
        return
    
    # Rate limiting
    if not rate_limiter.is_allowed(user_id):
        await message.answer("Juda ko'p so'rov. Iltimos, biroz kuting.")
        return
    
    # Rasm yuborilgan bo'lsa
    if message.photo:
        await message.answer(
            "ðŸ–¼ï¸ <b>Rasm tahlili</b>\n\n"
            "Rasmni tahlil qilish uchun AI dan foydalanilmoqda...\n"
            "â³ Iltimos, kuting...",
            reply_markup=ReplyKeyboardRemove()
        )
        
        photo_id = message.photo[-1].file_id
        question = "Bu rasmda nima bor? Tahlil qiling."
    else:
        question = message.text.strip() if message.text else ""
        if not question:
            await message.answer("âŒ Savol matni topilmadi! Qayta kiriting:")
            return
    
    if len(question) < 3:
        await message.answer("âŒ Savol juda qisqa! Kamida 3 belgi bo'lishi kerak.")
        return
    
    user = await db.get_user(user_id)
    ai_limit = user.get('ai_limit', 0)
    
    if ai_limit <= 0:
        await state.clear()
        await db.clear_user_chat_state(user_id)
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ Kunlik bonus", callback_data="daily_bonus")
        builder.button(text="ðŸ›’ Market", callback_data="market_menu")
        builder.button(text="ðŸ’Ž Premium", callback_data="premium_menu")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(2, 2)
        
        await message.answer(
            "âŒ <b>AI limit tugadi!</b>\n\n"
            "Limitni to'ldirish uchun quyidagilardan birini tanlang:\n\n"
            "ðŸŽ <b>Kunlik bonus</b> - Har kuni bepul bonus\n"
            "ðŸ›’ <b>Market</b> - XP evaziga limit sotib oling\n"
            "ðŸ’Ž <b>Premium</b> - Cheksiz limit uchun Premium obuna",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        return
    
    new_limit = ai_limit - 1
    await db.update_user(user_id, ai_limit=new_limit)
    
    await message.answer(
        "ðŸ¤– <b>AI javobini tayyorlayapman...</b>\n\n"
        "â³ Iltimos, kuting...",
        reply_markup=ReplyKeyboardRemove()
    )
    
    try:
        # Foydalanuvchi tilini olish
        user_lang = await db.get_user_language(user_id)
        
        # OpenAI API orqali javob olish
        headers = {
            "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
            "Content-Type": "application/json"
        }
        
        # GPT-4 modelidan foydalanish
        data = {
            "model": Config.OPENAI_MODEL,
            "messages": [
                {
                    "role": "system", 
                    "content": f"Siz foydali va batafsil javob beruvchi yordamchisiz. Javoblar 4000 tokengacha bo'lishi mumkin. Foydalanuvchi {user_lang} tilida savol beradi, siz ham {user_lang} tilida javob bering."
                },
                {
                    "role": "user",
                    "content": question
                }
            ],
            "max_tokens": 4000,
            "temperature": 0.7
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                Config.OPENAI_API_URL,
                headers=headers,
                json=data,
                timeout=aiohttp.ClientTimeout(total=60)
            ) as response:
                
                if response.status == 200:
                    result = await response.json()
                    if 'choices' in result and len(result['choices']) > 0:
                        ai_response = result['choices'][0]['message']['content']
                        
                        # Tokens soni
                        tokens_used = result.get('usage', {}).get('total_tokens', 0)
                        
                        # Suhbatni saqlash
                        conversation_id = f"conv_{user_id}_{int(time.time())}"
                        await db.save_ai_conversation(user_id, question, ai_response, tokens_used, conversation_id)
                        
                        # Conversation ID ni state ga saqlash
                        await state.update_data(conversation_id=conversation_id)
                        
                        response_text = f"""
ðŸ¤– <b>AI MENTOR JAVOBI</b>

â“ <b>Savol:</b>
{question[:200]}{'...' if len(question) > 200 else ''}

ðŸ’¡ <b>Javob:</b>
{ai_response[:3500]}

ðŸ“Š <b>Statistika:</b>
ðŸ‘¤ Foydalanuvchi: {user.get('full_name', user_id)}
ðŸ’¬ Qolgan limit: {new_limit} ta
ðŸ”¢ Tokens: {tokens_used}
â° Vaqt: {datetime.now().strftime('%H:%M')}
                        """
                        
                        builder = InlineKeyboardBuilder()
                        builder.button(text="âŒ Chatni to'xtatish", callback_data="stop_ai_chat")
                        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
                        builder.adjust(1, 1)
                        
                        await message.answer(
                            response_text,
                            reply_markup=builder.as_markup(),
                            parse_mode=ParseMode.HTML
                        )
                        
                        # State ni saqlab qolish - keyingi savol uchun
                        await db.set_user_chat_state(user_id, "ai_chat")
                        
                        # Agar limit hali bor bo'lsa, keyingi savolni kutish
                        if new_limit > 0:
                            await message.answer(
                                f"ðŸ’¬ <b>Yana savolingiz bormi?</b>\n\n"
                                f"Qolgan limit: {new_limit} ta\n\n"
                                "Yana savol bering yoki tugmalar orqali chiqing.\n"
                                "âŒ To'xtatish uchun /cancel",
                                reply_markup=builder.as_markup(),
                                parse_mode=ParseMode.HTML
                            )
                            await state.set_state(UserStates.waiting_ai_question)
                        
                        analytics.track_command(user_id, "ai_question")
                    else:
                        raise Exception("AI javob olinmadi")
                else:
                    error_text = await response.text()
                    logger.error(f"OpenAI API error: {response.status} - {error_text}")
                    raise Exception(f"API xatosi: {response.status}")
                    
    except Exception as e:
        logger.error(f"AI response error: {e}")
        builder = InlineKeyboardBuilder()
        builder.button(text="âŒ Chatni to'xtatish", callback_data="stop_ai_chat")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 1)
        
        await message.answer(
            "âŒ <b>Xatolik yuz berdi!</b>\n\n"
            f"AI xizmatida xatolik: {str(e)[:200]}\n\n"
            "Iltimos, keyinroq urinib ko'ring yoki tugmalar orqali chiqing.",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        # State ni saqlab qolish - foydalanuvchi yana urinib ko'rishi mumkin
        await state.set_state(UserStates.waiting_ai_question)

@router.message(F.text.in_(["ðŸ‘¤ Profil", "Profil"]))
async def handle_profile(message: Message):
    """Shaxsiy kabinet bo'limi"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    
    bonus_available, bonus_amount = await db.check_daily_bonus(user_id)
    
    # Statistika va reytingni profil ichiga qo'shish
    level = calculate_level(user.get('xp', 0))
    league = "Bronza" if level < 10 else "Kumush" if level < 20 else "Oltin"
    
    profile_text = f"""
ðŸ‘¤ <b>PROFIL - SHAXSIY KABINET</b>

ðŸ†” ID: <code>{user_id}</code>
ðŸ‘¤ Ism: {user.get('full_name', 'Noma\'lum')}
ðŸ“± Username: @{user.get('username', 'yo\'q')}

ðŸ’° <b>XP: {user.get('xp', 0):,}</b>
ðŸ† <b>Daraja: {level}</b>
ðŸ‘‘ <b>Status:</b> {DatabaseManager.get_subscription_name(user.get('subscription_type', 0))}
ðŸ”¥ <b>Streak:</b> {user.get('streak_count', 0)} kun

ðŸ“Š <b>STATISTIKA & REYTING:</b>
  ðŸ“¥ Yuklamalar: {user.get('total_downloads', 0)}
  ðŸ‘¥ Referallar: {user.get('referral_count', 0)}
  ðŸ¤– AI limit: {user.get('ai_limit', 0)}
  ðŸ’¸ Sarflangan: {user.get('total_spent', 0):,} XP
  ðŸ… Liga: {league}

ðŸ”— <b>Referal havola:</b>
<code>https://t.me/{(await bot.get_me()).username}?start={user_id}</code>

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await message.answer(profile_text, reply_markup=Keyboards.profile_menu(user), parse_mode=ParseMode.HTML)

# Profil menyusi callback handlerlari
@router.callback_query(F.data == "profile_xp")
async def handle_profile_xp(callback: CallbackQuery):
    """XP ma'lumotlari"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    xp = user.get('xp', 0)
    level = calculate_level(xp)
    
    xp_text = f"""
ðŸ’° <b>XP MA'LUMOTLARI</b>

ðŸ’° <b>Joriy XP:</b> {xp:,}
ðŸ“Š <b>Daraja:</b> {level}
ðŸ“ˆ <b>Keyingi daraja:</b> {calculate_level(xp + 1000)} ({(level + 1) * 1000 - xp} XP qoldi)

ðŸŽ <b>XP olish usullari:</b>
  â€¢ Kunlik bonus: {Config.XP_GAINS.get('daily_bonus', 100)} XP
  â€¢ Referal: {Config.XP_GAINS.get('referral', 75)} XP
  â€¢ Kitob yuklash: {Config.XP_GAINS.get('download', 50)} XP
  â€¢ Film ko'rish: {Config.XP_GAINS.get('watch_movie', 100)} XP
  â€¢ Kurs tugatish: {Config.XP_GAINS.get('complete_course', 500)} XP

ðŸ”™ Orqaga qaytish uchun tugmani bosing.
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Profil", callback_data="profile_back")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    await callback.message.edit_text(xp_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "profile_streak")
async def handle_profile_streak(callback: CallbackQuery):
    """Streak ma'lumotlari"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    streak = user.get('streak_count', 0)
    last_date = user.get('streak_last_date')
    
    streak_text = f"""
ðŸ”¥ <b>STREAK MA'LUMOTLARI</b>

ðŸ”¥ <b>Joriy streak:</b> {streak} kun
ðŸ“… <b>Oxirgi kun:</b> {last_date or 'Noma\'lum'}

ðŸ’¡ <b>Streak qanday ishlaydi:</b>
  â€¢ Har kuni kunlik bonus oling
  â€¢ Streak uzilib ketmasligi uchun har kuni kirib turing
  â€¢ Har 7 kunda bonus 2 baravar ko'payadi!

ðŸŽ <b>Bonus ko'paytirish:</b>
  â€¢ 7 kun: x2 bonus
  â€¢ 14 kun: x3 bonus
  â€¢ 30 kun: x5 bonus

ðŸ”™ Orqaga qaytish uchun tugmani bosing.
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Profil", callback_data="profile_back")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    await callback.message.edit_text(streak_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "profile_subscription")
async def handle_profile_subscription(callback: CallbackQuery):
    """Subscription ma'lumotlari"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    sub_type = user.get('subscription_type', 0)
    sub_name = DatabaseManager.get_subscription_name(sub_type)
    sub_end = user.get('subscription_end')
    
    sub_text = f"""
ðŸ‘‘ <b>SUBSCRIPTION MA'LUMOTLARI</b>

ðŸ‘‘ <b>Joriy status:</b> {sub_name}
ðŸ“… <b>Muddati:</b> {sub_end or 'Cheksiz'}

ðŸ’Ž <b>Premium imkoniyatlari:</b>
  â€¢ Cheksiz yuklash
  â€¢ AI limit 50+ ta/kun
  â€¢ 1080p/4K kinolar
  â€¢ Premium kontentlar
  â€¢ Mining x2 tezlik

ðŸ’° <b>Premium sotib olish:</b>
  â€¢ Exclusive: 39,990 so'm
  â€¢ Exclusive Pro+: 59,990 so'm
  â€¢ XP evaziga ham mavjud

ðŸ”™ Orqaga qaytish uchun tugmani bosing.
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’Ž Premium sotib olish", callback_data="premium_menu")
    builder.button(text="ðŸ”™ Profil", callback_data="profile_back")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    await callback.message.edit_text(sub_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "daily_bonus")
async def handle_daily_bonus(callback: CallbackQuery):
    """Kunlik bonus olish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    bonus_available, bonus_amount = await db.check_daily_bonus(user_id)
    
    if bonus_available:
        success = await db.give_daily_bonus(user_id)
        if success:
            # Streak ni yangilash
            today = date.today().isoformat()
            last_date = user.get('streak_last_date')
            
            if last_date == today:
                # Bugun allaqachon bonus olgan
                streak = user.get('streak_count', 0)
            else:
                # Yangi kun - streak ni oshirish
                yesterday = (date.today() - timedelta(days=1)).isoformat()
                if last_date == yesterday:
                    # Streak davom etmoqda
                    streak = (user.get('streak_count', 0) or 0) + 1
                else:
                    # Streak yangi boshlanmoqda
                    streak = 1
                
                await db.update_user(user_id, streak_count=streak, streak_last_date=today)
            
            bonus_text = f"""
ðŸŽ <b>KUNLIK BONUS OLINDI!</b>

ðŸ’° <b>Bonus:</b> {bonus_amount} XP
ðŸ”¥ <b>Streak:</b> {streak} kun

ðŸ’¡ <b>Maslahat:</b>
  â€¢ Har kuni kirib turing
  â€¢ Streak uzilib ketmasligi uchun ehtiyot bo'ling
  â€¢ Har 7 kunda bonus 2 baravar ko'payadi!

ðŸ”™ Orqaga qaytish uchun tugmani bosing.
            """
        else:
            bonus_text = "âŒ Bonus olishda xatolik yuz berdi."
    else:
        bonus_text = f"""
âš ï¸ <b>BONUS OLINDI</b>

ðŸ’° Siz bugun allaqachon kunlik bonus olgansiz!

â° <b>Keyingi bonus:</b> Ertaga

ðŸ’¡ <b>Maslahat:</b>
  â€¢ Har kuni kirib turing
  â€¢ Streak uzilib ketmasligi uchun ehtiyot bo'ling

ðŸ”™ Orqaga qaytish uchun tugmani bosing.
        """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Profil", callback_data="profile_back")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    await callback.message.edit_text(bonus_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "stats_menu")
async def handle_stats_menu(callback: CallbackQuery):
    """Statistika menyusi"""
    await callback.message.edit_text(
        "ðŸ“Š <b>STATISTIKA & REYTING</b>\n\nQuyidagilardan birini tanlang:",
        reply_markup=Keyboards.stats_menu(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "my_stats")
async def handle_my_stats(callback: CallbackQuery):
    """Foydalanuvchi statistikasi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    stats_text = f"""
ðŸ“Š <b>SHAXSIY STATISTIKA</b>

ðŸ‘¤ <b>Ma'lumotlar:</b>
  ðŸ†” ID: <code>{user_id}</code>
  ðŸ‘¤ Ism: {user.get('full_name', 'Noma\'lum')}
  ðŸ“± Username: @{user.get('username', 'yo\'q')}

ðŸ’° <b>XP va Daraja:</b>
  ðŸ’° XP: {user.get('xp', 0):,}
  ðŸ“Š Daraja: {calculate_level(user.get('xp', 0))}
  ðŸ”¥ Streak: {user.get('streak_count', 0)} kun

ðŸ“ˆ <b>Faollik:</b>
  ðŸ“¥ Yuklamalar: {user.get('total_downloads', 0)}
  ðŸ‘¥ Referallar: {user.get('referral_count', 0)}
  ðŸ¤– AI limit: {user.get('ai_limit', 0)}/kun
  ðŸ’¸ Sarflangan: {user.get('total_spent', 0)} XP

ðŸ‘‘ <b>Status:</b>
  {DatabaseManager.get_subscription_name(user.get('subscription_type', 0))}
  ðŸ“… Muddati: {user.get('subscription_end', 'Cheksiz')}

ðŸ”™ Orqaga qaytish uchun tugmani bosing.
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Statistika", callback_data="stats_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    await callback.message.edit_text(stats_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

# ==================== MINING HANDLERS ====================

@router.callback_query(F.data == "mining_menu")
async def handle_mining_menu(callback: CallbackQuery):
    """Mining fermasi menyusi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    farm = await db.get_mining_farm(user_id)
    
    if not farm:
        await callback.answer("âŒ Mining fermasi topilmadi!")
        return
    
    # Lazy calculation dan olingan ma'lumotlar
    pending_xp = farm.get('pending_xp', 0)
    can_collect = farm.get('can_collect', False)
    minutes_until = farm.get('minutes_until_collect', 0)
    hours_passed = farm.get('hours_passed', 0)
    
    # Yig'ish holati
    if can_collect:
        collect_status = f"âœ… <b>Yig'ishga tayyor!</b> ({pending_xp:,} XP kutmoqda)"
    else:
        collect_status = f"â³ Keyingi yig'ish: {minutes_until} daqiqadan keyin"
    
    mining_text = f"""
â›ï¸ <b>MINING FERMASI</b>

ðŸ’° <b>Joriy holat:</b>
  â¬†ï¸ Level: {farm.get('level', 1)}
  âš¡ XP/soat: {farm.get('xp_per_hour', 10)}
  ðŸ’° Jami yig'ilgan: {farm.get('total_collected', 0):,} XP
  ðŸ’µ Upgrade narxi: {farm.get('upgrade_cost', 1000):,} XP

ðŸŽ <b>Kutilayotgan XP:</b> {pending_xp:,} XP
â° {collect_status}

ðŸ’¡ <b>Maslahat:</b>
  â€¢ Ko'proq XP = Ko'proq mining daromadi
  â€¢ Level oshgani sari XP/soat 2 baravar oshadi
  â€¢ Upgrade narxi har safar 3 baravar oshadi

ðŸ‘‡ <b>Tanlang:</b>
    """
    
    await callback.message.edit_text(
        mining_text,
        reply_markup=Keyboards.mining_menu(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "collect_mining")
async def handle_collect_mining(callback: CallbackQuery):
    """Mining rewardlarini yig'ish"""
    user_id = callback.from_user.id
    
    success, message, xp_earned = await db.collect_mining_rewards(user_id)
    
    if success:
        user = await db.get_user(user_id)
        farm = await db.get_mining_farm(user_id)
        await callback.message.edit_text(
            f"â›ï¸ <b>MINING FERMASI</b>\n\n"
            f"âœ… {message}\n\n"
            f"ðŸ’° <b>Statistika:</b>\n"
            f"ðŸ’° Joriy XP: {user['xp']:,}\n"
            f"âš¡ XP/soat: {farm.get('xp_per_hour', 10)}\n"
            f"ðŸ“Š Jami yig'ilgan: {farm.get('total_collected', 0)} XP\n\n"
            f"â³ Keyingi yig'ish 1 soatdan keyin.",
            reply_markup=Keyboards.mining_menu(),
            parse_mode=ParseMode.HTML
        )
    else:
        await callback.message.edit_text(
            f"âŒ <b>XATOLIK!</b>\n\n{message}",
            reply_markup=Keyboards.mining_menu(),
            parse_mode=ParseMode.HTML
        )
    
    await callback.answer()

@router.callback_query(F.data == "upgrade_mining")
async def handle_upgrade_mining(callback: CallbackQuery):
    """Mining fermasini yangilash"""
    user_id = callback.from_user.id
    
    success, message = await db.upgrade_mining_farm(user_id)
    
    if success:
        farm = await db.get_mining_farm(user_id)
        await callback.message.edit_text(
            f"âœ… <b>MINING FERMASI YANGILANDI!</b>\n\n"
            f"{message}\n\n"
            f"ðŸ’° <b>Yangi statistika:</b>\n"
            f"â¬†ï¸ Level: {farm.get('level', 1)}\n"
            f"âš¡ XP/soat: {farm.get('xp_per_hour', 10)}\n"
            f"ðŸ’µ Keyingi upgrade: {farm.get('upgrade_cost', 1000)} XP",
            reply_markup=Keyboards.mining_menu(),
            parse_mode=ParseMode.HTML
        )
    else:
        await callback.message.edit_text(
            f"âŒ <b>XATOLIK!</b>\n\n{message}",
            reply_markup=Keyboards.mining_menu(),
            parse_mode=ParseMode.HTML
        )
    
    await callback.answer()

@router.callback_query(F.data == "mining_stats")
async def handle_mining_stats(callback: CallbackQuery):
    """Mining statistikasi"""
    user_id = callback.from_user.id
    farm = await db.get_mining_farm(user_id)
    user = await db.get_user(user_id)
    
    if not farm:
        await callback.answer("âŒ Mining fermasi topilmadi!")
        return
    
    stats_text = f"""
â›ï¸ <b>MINING STATISTIKASI</b>

ðŸ’° <b>Joriy holat:</b>
  â¬†ï¸ Level: {farm.get('level', 1)}
  âš¡ XP/soat: {farm.get('xp_per_hour', 10)}
  ðŸ’° Jami yig'ilgan: {farm.get('total_collected', 0):,} XP
  ðŸ’µ Joriy XP: {user.get('xp', 0):,}

ðŸ“Š <b>Keyingi daraja:</b>
  ðŸ’µ Upgrade narxi: {farm.get('upgrade_cost', 1000):,} XP
  âš¡ Yangi XP/soat: {farm.get('xp_per_hour', 10) * 2}
  â¬†ï¸ Yangi level: {farm.get('level', 1) + 1}

ðŸ’¡ <b>Maslahat:</b>
  â€¢ Ko'proq XP yig'ing va upgrade qiling
  â€¢ Har soatda reward yig'ib oling
  â€¢ Level oshgani sari ko'proq XP olasiz
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’° Reward yig'ish", callback_data="collect_mining")
    builder.button(text="â¬†ï¸ Upgrade qilish", callback_data="upgrade_mining")
    builder.button(text="ðŸ”™ Mining menyu", callback_data="mining_menu")
    builder.adjust(1, 1, 1)
    
    await callback.message.edit_text(stats_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

# ==================== DUEL HANDLERS ====================

@router.callback_query(F.data == "duel")
async def handle_duel_menu(callback: CallbackQuery):
    """Duel o'yini menyusi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    stats = await db.get_user_duel_stats(user_id)
    
    wins = stats.get('wins', 0)
    losses = stats.get('losses', 0)
    draws = stats.get('draws', 0)
    total = stats.get('total_duels', 0)
    
    duel_text = f"""
âš”ï¸ <b>DUEL O'YINI - TOSH-QAYCHI-QOG'OZ</b>

ðŸ’° <b>Sizning XP:</b> {user.get('xp', 0):,}

ðŸŽ® <b>Qanday o'ynaladi?</b>
  â€¢ Raqibingizni tanlang (tasodifiy)
  â€¢ Har bir duel 50 XP ga tushadi
  â€¢ Tosh, Qaychi yoki Qog'oz tanlang
  â€¢ G'olib: 50 XP qaytariladi
  â€¢ Mag'lub: 50 XP yo'qotiladi
  â€¢ Durang: XP qaytarilmaydi

ðŸ† <b>Sizning statistikangiz:</b>
  âœ… G'alabalar: {wins}
  âŒ Mag'lubiyatlar: {losses}
  ðŸ¤ Duranglar: {draws}
  ðŸ“Š Jami: {total} ta duel

ðŸ’¡ <b>Maslahat:</b> Strategik o'ylab tanlang va ko'p XP yutib oling!

ðŸ‘‡ <b>Raqibingizni tanlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ² Tasodifiy raqib", callback_data="duel_random")
    builder.button(text="ðŸ¥‡ Top duelchilar", callback_data="duel_top")
    builder.button(text="ðŸ“Š Mening duel statistikam", callback_data="duel_stats")
    builder.button(text="ðŸ”™ Statistika", callback_data="stats_menu")
    builder.adjust(1, 2, 1)
    
    await callback.message.edit_text(duel_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "duel_stats")
async def handle_duel_stats(callback: CallbackQuery):
    """Duel statistikasi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    stats = await db.get_user_duel_stats(user_id)
    
    total = stats.get('total_duels', 0)
    wins = stats.get('wins', 0)
    losses = stats.get('losses', 0)
    draws = stats.get('draws', 0)
    
    win_rate = (wins / total * 100) if total > 0 else 0
    
    stats_text = f"""
âš”ï¸ <b>MENING DUEL STATISTIKAM</b>

ðŸ“Š <b>Umumiy statistika:</b>
  ðŸŽ® Jami duellar: {total}
  âœ… G'olibliklar: {wins}
  âŒ Mag'lubiyatlar: {losses}
  ðŸ¤ Duranglar: {draws}
  ðŸ“ˆ G'alaba foizi: {win_rate:.1f}%

ðŸ’° <b>Yutuqlar:</b>
  ðŸ’µ Yutuq: {wins * 50} XP
  ðŸ’¸ Yo'qotilgan: {losses * 50} XP
  ðŸ’° Sof daromad: {(wins - losses) * 50} XP

ðŸ† <b>Keyingi maqsad:</b>
  ðŸŽ¯ {wins + 1} g'alaba - keyingi daraja!
  ðŸ’Ž Top 10 ga kirish
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âš”ï¸ Duel o'ynash", callback_data="duel")
    builder.button(text="ðŸ† Top duelchilar", callback_data="duel_top")
    builder.button(text="ðŸ”™ Statistika", callback_data="stats_menu")
    builder.adjust(1, 1, 1)
    
    await callback.message.edit_text(stats_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "duel_random")
async def handle_duel_random(callback: CallbackQuery, state: FSMContext):
    """Tasodifiy duel"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if user.get('xp', 0) < 50:
        await callback.answer("âŒ Yetarli XP yo'q! Kamida 50 XP kerak.", show_alert=True)
        return
    
    # Tasodifiy raqib topish (bot o'zi)
    bot_id = 999999999  # Bot ID (real bot ID ni Config dan olish kerak)
    
    duel_id = await db.create_duel(user_id, bot_id, 50)
    
    if not duel_id:
        await callback.answer("âŒ Duel yaratishda xatolik!", show_alert=True)
        return
    
    await state.update_data(duel_id=duel_id, is_player1=True)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âœŠ Tosh", callback_data=f"duel_choice_rock_{duel_id}")
    builder.button(text="âœ‚ï¸ Qaychi", callback_data=f"duel_choice_scissors_{duel_id}")
    builder.button(text="ðŸ“„ Qog'oz", callback_data=f"duel_choice_paper_{duel_id}")
    builder.button(text="âŒ Bekor qilish", callback_data="duel")
    builder.adjust(1, 1, 1, 1)
    
    await callback.message.edit_text(
        "âš”ï¸ <b>DUEL BOSHLANDI!</b>\n\n"
        "Tanlang:",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data.startswith("duel_choice_"))
async def handle_duel_choice(callback: CallbackQuery):
    """Duel tanlovi"""
    user_id = callback.from_user.id
    data_parts = callback.data.replace("duel_choice_", "").split("_")
    
    if len(data_parts) < 2:
        await callback.answer("âŒ Xatolik!")
        return
    
    choice = data_parts[0]  # rock, scissors, paper
    duel_id = int(data_parts[1])
    
    # Bot tanlovi (tasodifiy)
    bot_choices = ['rock', 'scissors', 'paper']
    bot_choice = random.choice(bot_choices)
    
    # Foydalanuvchi tanlovini saqlash
    await db.update_duel_choice(duel_id, user_id, choice)
    
    # Bot tanlovini saqlash (bot_id = 999999999)
    await db.update_duel_choice(duel_id, 999999999, bot_choice)
    
    # G'olibni aniqlash
    winner_id = None
    if choice == bot_choice:
        winner_id = None  # Durang
    elif (choice == 'rock' and bot_choice == 'scissors') or \
         (choice == 'scissors' and bot_choice == 'paper') or \
         (choice == 'paper' and bot_choice == 'rock'):
        winner_id = user_id  # Foydalanuvchi g'olib
    else:
        winner_id = 999999999  # Bot g'olib
    
    # Duelni yakunlash
    await db.complete_duel(duel_id, winner_id)
    
    # Natijani ko'rsatish
    choice_icons = {'rock': 'âœŠ', 'scissors': 'âœ‚ï¸', 'paper': 'ðŸ“„'}
    user_icon = choice_icons.get(choice, 'â“')
    bot_icon = choice_icons.get(bot_choice, 'â“')
    
    if winner_id == user_id:
        result_text = "âœ… <b>SIZ YUTDINGIZ!</b>\n\n50 XP qaytarildi!"
    elif winner_id == 999999999:
        result_text = "âŒ <b>SIZ YUTQAZDINGIZ!</b>\n\n50 XP yo'qotildi!"
    else:
        result_text = "ðŸ¤ <b>DURANG!</b>\n\nXP qaytarilmaydi!"
    
    result_text += f"\n\nSiz: {user_icon}\nRaqib: {bot_icon}"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âš”ï¸ Yana duel", callback_data="duel_random")
    builder.button(text="ðŸ“Š Statistika", callback_data="duel_stats")
    builder.button(text="ðŸ”™ Duel menyu", callback_data="duel")
    builder.adjust(1, 2)
    
    await callback.message.edit_text(result_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "duel_top")
async def handle_duel_top(callback: CallbackQuery):
    """Top duelchilar"""
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT 
                u.user_id, 
                u.full_name, 
                u.username,
                COUNT(CASE WHEN d.winner_id = u.user_id THEN 1 END) as wins
            FROM users u
            LEFT JOIN duels d ON (d.player1_id = u.user_id OR d.player2_id = u.user_id) AND d.status = 'completed'
            GROUP BY u.user_id
            HAVING wins > 0
            ORDER BY wins DESC
            LIMIT 10
        ''')
        top_players_rows = await cursor.fetchall()
        top_players = [dict(p) for p in top_players_rows]
    
    top_text = "ðŸ† <b>TOP DUELCHILAR</b>\n\n"
    top_text += "ðŸ¥‡ <b>Eng ko'p g'alaba qozonganlar:</b>\n\n"
    
    for i, player in enumerate(top_players, 1):
        medal = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"][i-1] if i <= 3 else f"{i}."
        name = player.get('full_name', '') or player.get('username', '') or f"User {player.get('user_id', 0)}"
        wins = player.get('wins', 0) or 0
        top_text += f"{medal} {name[:20]}\n"
        top_text += f"   âœ… {wins} ta g'alaba\n\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âš”ï¸ Duel o'ynash", callback_data="duel")
    builder.button(text="ðŸ“Š Mening duel statistikam", callback_data="duel_stats")
    builder.button(text="ðŸ”™ Statistika", callback_data="stats_menu")
    builder.adjust(1, 1, 1)
    
    await callback.message.edit_text(top_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "rating_table")
async def handle_rating_table(callback: CallbackQuery):
    """Reyting jadvali"""
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT user_id, full_name, username, xp 
            FROM users 
            ORDER BY xp DESC 
            LIMIT 20
        ''')
        top_users_rows = await cursor.fetchall()
        top_users = [dict(u) for u in top_users_rows]
    
    rating_text = "ðŸ† <b>REYTING JADVALI</b>\n\n"
    rating_text += "ðŸ¥‡ <b>Eng ko'p XP ga ega foydalanuvchilar:</b>\n\n"
    
    for i, user in enumerate(top_users, 1):
        medal = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"][i-1] if i <= 3 else f"{i}."
        name = user.get('full_name', '') or user.get('username', '') or f"User {user.get('user_id', 0)}"
        xp = user.get('xp', 0)
        rating_text += f"{medal} {name[:25]}\n"
        rating_text += f"   ðŸ’° {xp:,} XP\n\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“Š Mening statistikam", callback_data="my_stats")
    builder.button(text="ðŸ”™ Statistika", callback_data="stats_menu")
    builder.adjust(1, 1)
    
    await callback.message.edit_text(rating_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "leagues")
async def handle_leagues(callback: CallbackQuery):
    """Ligalar menyusi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    user_xp = user.get('xp', 0)
    league = await db.get_user_league(user_xp)
    
    leagues_text = f"""
ðŸ… <b>LIGALAR</b>

ðŸ’° <b>Sizning XP:</b> {user_xp:,}

ðŸ† <b>Sizning ligangiz:</b>
"""
    
    if league:
        leagues_text += f"  {league.get('icon', 'ðŸ…')} {league.get('league_name', 'Noma\'lum')}\n"
        leagues_text += f"  ðŸ“Š XP oralig'i: {league.get('min_xp', 0):,} - {league.get('max_xp', 999999):,}\n\n"
    else:
        leagues_text += "  ðŸ… Standard Liga\n\n"
    
    leagues_text += "ðŸ’¡ <b>Maslahat:</b> Ko'proq XP yig'ing va yuqori ligaga chiqing!"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Statistika", callback_data="stats_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1)
    
    await callback.message.edit_text(leagues_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "favorites")
async def handle_favorites(callback: CallbackQuery):
    """Foydalanuvchi favoritelari"""
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM favorites 
            WHERE user_id = ? 
            ORDER BY created_date DESC 
            LIMIT 50
        ''', (user_id,))
        favorites = await cursor.fetchall()
    
    if not favorites:
        await callback.message.edit_text(
            "â¤ï¸ <b>FAVORITELAR</b>\n\n"
            "âŒ Hozircha sevimli kitob/film/kurs yo'q.\n\n"
            "ðŸ’¡ Kitob, film yoki kursni ko'rib chiqganingizda 'â¤ï¸ Sevimli' tugmasini bosing!",
            reply_markup=Keyboards.back_button("profile"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    text = f"â¤ï¸ <b>FAVORITELAR</b>\n\n"
    text += f"ðŸ“Š Jami: {len(favorites)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    
    for fav in favorites[:20]:
        item_type = fav[2]
        item_id = fav[3]
        item_name = ""
        
        if item_type == "book":
            book = await db.get_book_by_id(item_id) if hasattr(db, 'get_book_by_id') else None
            item_name = book.get('caption', 'Kitob') if book else f"Kitob #{item_id}"
            builder.button(text=f"ðŸ“š {item_name[:30]}", callback_data=f"view_favorite_{item_type}_{item_id}")
        elif item_type == "movie":
            movie = await db.get_movie(item_id)
            item_name = movie.get('caption', 'Film') if movie else f"Film #{item_id}"
            builder.button(text=f"ðŸŽ¬ {item_name[:30]}", callback_data=f"view_favorite_{item_type}_{item_id}")
        elif item_type == "course":
            course = await db.get_course(item_id)
            item_name = course.get('title', 'Kurs') if course else f"Kurs #{item_id}"
            builder.button(text=f"ðŸŽ“ {item_name[:30]}", callback_data=f"view_favorite_{item_type}_{item_id}")
        
        text += f"â€¢ {item_name[:40]}\n"
    
    builder.button(text="ðŸ”™ Profil", callback_data="profile")
    builder.adjust(1)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "history")
async def handle_history(callback: CallbackQuery):
    """Foydalanuvchi tarixi"""
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM user_history 
            WHERE user_id = ? 
            ORDER BY created_date DESC 
            LIMIT 50
        ''', (user_id,))
        history = await cursor.fetchall()
    
    if not history:
        await callback.message.edit_text(
            "ðŸ“œ <b>TARIX</b>\n\n"
            "âŒ Hozircha tarix yo'q.\n\n"
            "ðŸ’¡ Kitob, film yoki kursni ko'rib chiqganingizda bu yerda ko'rinadi!",
            reply_markup=Keyboards.back_button("profile"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    text = f"ðŸ“œ <b>TARIX</b>\n\n"
    text += f"ðŸ“Š Jami: {len(history)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    
    for hist in history[:20]:
        item_type = hist[2]
        item_name = hist[4] or f"{item_type} #{hist[3]}"
        action = hist[5] or "ko'rilgan"
        date = hist[6][:10] if len(hist[6]) > 10 else hist[6]
        
        icon = "ðŸ“š" if item_type == "book" else "ðŸŽ¬" if item_type == "movie" else "ðŸŽ“"
        text += f"{icon} {item_name[:35]} ({action})\n"
        text += f"   ðŸ“… {date}\n\n"
    
    builder.button(text="ðŸ”™ Profil", callback_data="profile")
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "accept_trial")
async def handle_accept_trial(callback: CallbackQuery):
    """Trial qabul qilish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    # Trial allaqachon ishlatilganligini tekshirish
    if user.get('trial_used', 0):
        await callback.answer("âŒ Siz allaqachon trial ishlatgansiz!", show_alert=True)
        return
    
    # Premium obuna borligini tekshirish
    if user.get('subscription_type', 0) > 0:
        await callback.answer("âœ… Sizda allaqachon Premium obuna bor!", show_alert=True)
        return
    
    from datetime import datetime, timedelta
    
    # Trial boshlanish va tugash vaqtini belgilash (3 kun)
    trial_start = datetime.now()
    trial_end = trial_start + timedelta(days=3)
    
    # Bazaga saqlash
    await db.update_user(
        user_id,
        subscription_type=2,  # Premium (trial)
        trial_used=1,
        trial_started_at=trial_start.strftime('%Y-%m-%d %H:%M:%S'),
        trial_ends_at=trial_end.strftime('%Y-%m-%d %H:%M:%S'),
        ai_limit=50  # Trial uchun 50 ta AI limit
    )
    
    await safe_edit_text(callback,
        "âœ… <b>TRIAL FAOLLASHTIRILDI!</b>\n\n"
        f"ðŸŽ‰ Tabriklaymiz! Sizga 3 kunlik Premium trial berildi!\n\n"
        f"â° <b>Muddati:</b>\n"
        f"  ðŸ“… Boshlanish: {trial_start.strftime('%Y-%m-%d %H:%M')}\n"
        f"  ðŸ“… Tugash: {trial_end.strftime('%Y-%m-%d %H:%M')}\n\n"
        f"ðŸŽ¯ <b>Sizga mavjud:</b>\n"
        f"  âœ… Cheksiz kitob/film/kurs yuklash\n"
        f"  âœ… 50 ta AI savol limiti\n"
        f"  âœ… 720p/1080p kinolar\n"
        f"  âœ… Premium kontentlar\n\n"
        f"ðŸ’¡ <b>Maslahat:</b> Trial tugagunga qadar Premium sotib oling va qo'shimcha 200 XP bonus oling!\n\n"
        f"ðŸ  Asosiy menyuga o'tish uchun /start bosing!",
        reply_markup=Keyboards.back_button("main_menu")
    )
    await callback.answer("âœ… Trial faollashtirildi!")

@router.callback_query(F.data == "decline_trial")
async def handle_decline_trial(callback: CallbackQuery):
    """Trial rad etish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    await safe_edit_text(callback,
        "âŒ <b>TRIAL RAD ETILDI</b>\n\n"
        "ðŸ˜” Siz trial olishni rad etdingiz.\n\n"
        "ðŸ’¡ <b>Eslatma:</b> Agar fikringizni o'zgartirsangiz, Premium obuna sotib olishingiz mumkin!\n\n"
        "ðŸ  Asosiy menyuga o'tish uchun /start bosing!",
        reply_markup=Keyboards.back_button("main_menu")
    )
    await callback.answer("âŒ Trial rad etildi")

@router.callback_query(F.data == "new_features_menu")
async def handle_new_features_menu(callback: CallbackQuery):
    """Yangi funksiyalar menyusi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    user_lang = await db.get_user_language(user_id) if user else 'uz'
    
    if user_lang == 'uz':
        text = """
âœ¨ <b>YANGI FUNKSIYALAR</b> ðŸŽ‰

ðŸ“Š <b>Shaxsiylashtirilgan Dashboard</b>
â€¢ Shaxsiy statistika
â€¢ XP va Level ko'rsatkichlari
â€¢ Quick actions

ðŸ† <b>Yutuqlar Tizimi</b>
â€¢ Har bir yutuq uchun XP mukofoti
â€¢ Yutuqlar tarixi
â€¢ Progress tracking

ðŸ“ˆ <b>Reyting Jadvali</b>
â€¢ Global reyting
â€¢ Do'stlar bilan raqobat
â€¢ O'z o'rningizni ko'rish

ðŸŽ¯ <b>Kunlik Vazifalar</b>
â€¢ 5 ta kunlik vazifa
â€¢ Progress tracking
â€¢ XP mukofotlari

ðŸ’¡ <b>Aqlli Takliflar</b>
â€¢ Top kitoblar
â€¢ Top filmlar
â€¢ Top kurslar

ðŸ‘¥ <b>Ijtimoiy Funksiyalar</b>
â€¢ Do'stlar ro'yxati
â€¢ Do'stlar statistikasi
â€¢ Raqobat
â€¢ Baham ko'rish
â€¢ Sharhlar va baholash

ðŸ“ˆ <b>Taraqqiyot Kuzatish</b>
â€¢ XP tarixi
â€¢ Yuklash tarixi
â€¢ Kurslar tarixi
â€¢ Progress tracking

ðŸ†˜ <b>Yordam & Support</b>
â€¢ Qo'llanma
â€¢ Troubleshooter
â€¢ Support ticket
â€¢ Status sahifasi

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
        """
    elif user_lang == 'ru':
        text = """
âœ¨ <b>ÐÐžÐ’Ð«Ð• Ð¤Ð£ÐÐšÐ¦Ð˜Ð˜</b> ðŸŽ‰

ðŸ“Š <b>ÐŸÐµÑ€ÑÐ¾Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð¿Ð°Ð½ÐµÐ»ÑŒ</b>
â€¢ Ð›Ð¸Ñ‡Ð½Ð°Ñ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°
â€¢ ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»Ð¸ XP Ð¸ ÑƒÑ€Ð¾Ð²Ð½Ñ
â€¢ Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ

ðŸ† <b>Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ð¹</b>
â€¢ XP Ð½Ð°Ð³Ñ€Ð°Ð´Ð° Ð·Ð° ÐºÐ°Ð¶Ð´Ð¾Ðµ Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ðµ
â€¢ Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ð¹
â€¢ ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ°

ðŸ“ˆ <b>Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð»Ð¸Ð´ÐµÑ€Ð¾Ð²</b>
â€¢ Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ¹Ñ‚Ð¸Ð½Ð³
â€¢ Ð¡Ð¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ Ð´Ñ€ÑƒÐ·ÑŒÑÐ¼Ð¸
â€¢ Ð£Ð·Ð½Ð°Ð¹Ñ‚Ðµ ÑÐ²Ð¾Ðµ Ð¼ÐµÑÑ‚Ð¾

ðŸŽ¯ <b>Ð•Ð¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ</b>
â€¢ 5 ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ñ… Ð·Ð°Ð´Ð°Ð½Ð¸Ð¹
â€¢ ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ°
â€¢ XP Ð½Ð°Ð³Ñ€Ð°Ð´Ñ‹

ðŸ’¡ <b>Ð£Ð¼Ð½Ñ‹Ðµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸</b>
â€¢ Ð¢Ð¾Ð¿ ÐºÐ½Ð¸Ð³Ð¸
â€¢ Ð¢Ð¾Ð¿ Ñ„Ð¸Ð»ÑŒÐ¼Ñ‹
â€¢ Ð¢Ð¾Ð¿ ÐºÑƒÑ€ÑÑ‹

ðŸ‘¥ <b>Ð¡Ð¾Ñ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸</b>
â€¢ Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð´Ñ€ÑƒÐ·ÐµÐ¹
â€¢ Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ° Ð´Ñ€ÑƒÐ·ÐµÐ¹
â€¢ Ð¡Ð¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸Ðµ
â€¢ ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ
â€¢ ÐšÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸Ð¸ Ð¸ Ð¾Ñ‚Ð·Ñ‹Ð²Ñ‹

ðŸ“ˆ <b>ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ°</b>
â€¢ Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ XP
â€¢ Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¾Ðº
â€¢ Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ ÐºÑƒÑ€ÑÐ¾Ð²
â€¢ ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ°

ðŸ†˜ <b>ÐŸÐ¾Ð¼Ð¾Ñ‰ÑŒ Ð¸ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ°</b>
â€¢ Ð ÑƒÐºÐ¾Ð²Ð¾Ð´ÑÑ‚Ð²Ð¾
â€¢ Ð£ÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð½ÐµÐ¿Ð¾Ð»Ð°Ð´Ð¾Ðº
â€¢ Ð¢Ð¸ÐºÐµÑ‚ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ¸
â€¢ Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° ÑÑ‚Ð°Ñ‚ÑƒÑÐ°

ðŸ‘‡ <b>Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð²:</b>
        """
    else:  # en
        text = """
âœ¨ <b>NEW FEATURES</b> ðŸŽ‰

ðŸ“Š <b>Personalized Dashboard</b>
â€¢ Personal statistics
â€¢ XP and Level indicators
â€¢ Quick actions

ðŸ† <b>Achievements System</b>
â€¢ XP reward for each achievement
â€¢ Achievement history
â€¢ Progress tracking

ðŸ“ˆ <b>Leaderboard</b>
â€¢ Global ranking
â€¢ Competition with friends
â€¢ See your position

ðŸŽ¯ <b>Daily Challenges</b>
â€¢ 5 daily tasks
â€¢ Progress tracking
â€¢ XP rewards

ðŸ’¡ <b>Smart Recommendations</b>
â€¢ Top books
â€¢ Top movies
â€¢ Top courses

ðŸ‘¥ <b>Social Features</b>
â€¢ Friends list
â€¢ Friends statistics
â€¢ Competition
â€¢ Share
â€¢ Comments and reviews

ðŸ“ˆ <b>Progress Tracking</b>
â€¢ XP history
â€¢ Download history
â€¢ Course history
â€¢ Progress tracking

ðŸ†˜ <b>Help & Support</b>
â€¢ Guide
â€¢ Troubleshooter
â€¢ Support ticket
â€¢ Status page

ðŸ‘‡ <b>Select one of the options:</b>
        """
    
    builder = InlineKeyboardBuilder()
    # Rangli va vizual tugmalar
    builder.button(text="ðŸ“Š ðŸ“ˆ Dashboard", callback_data="my_dashboard")
    builder.button(text="ðŸ† ðŸŽ–ï¸ Yutuqlar", callback_data="my_achievements")
    builder.button(text="ðŸ“ˆ ðŸ¥‡ Reyting", callback_data="leaderboard")
    builder.button(text="ðŸŽ¯ âœ… Kunlik vazifalar", callback_data="daily_challenges")
    builder.button(text="ðŸ’¡ ðŸ¤– AI takliflar", callback_data="smart_recommendations")
    builder.button(text="ðŸ‘¥ ðŸ¤ Ijtimoiy", callback_data="social_features")
    builder.button(text="ðŸ“ˆ ðŸ“Š Taraqqiyot", callback_data="progress_tracking")
    builder.button(text="ðŸ†˜ ðŸ’¬ Yordam", callback_data="help_menu")
    builder.button(text="ðŸ”™ â¬…ï¸ Asosiy menyu", callback_data="main_menu")
    builder.adjust(2, 2, 2, 2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()
#     pass

@router.callback_query(F.data == "profile_back")
async def handle_profile_back(callback: CallbackQuery):
    """Profilga qaytish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer(" Foydalanuvchi topilmadi!")
        return
    
    bonus_available, bonus_amount = await db.check_daily_bonus(user_id)
    
    # Statistika va reytingni profil ichiga qo'shish
    level = calculate_level(user.get('xp', 0))
    league = "Bronza" if level < 10 else "Kumush" if level < 20 else "Oltin"
    
    profile_text = f"""
ðŸ‘¤ <b>PROFIL - SHAXSIY KABINET</b>

ðŸ†” ID: <code>{user_id}</code>
ðŸ‘¤ Ism: {user.get('full_name', 'Noma\'lum')}
ðŸ“± Username: @{user.get('username', 'yo\'q')}

ðŸ’° <b>XP: {user.get('xp', 0):,}</b>
ðŸ† <b>Daraja: {level}</b>
ðŸ‘‘ <b>Status:</b> {DatabaseManager.get_subscription_name(user.get('subscription_type', 0))}
ðŸ”¥ <b>Streak:</b> {user.get('streak_count', 0)} kun

ðŸ“Š <b>STATISTIKA & REYTING:</b>
  ðŸ“¥ Yuklamalar: {user.get('total_downloads', 0)}
  ðŸ‘¥ Referallar: {user.get('referral_count', 0)}
  ðŸ¤– AI limit: {user.get('ai_limit', 0)}
  ðŸ’¸ Sarflangan: {user.get('total_spent', 0):,} XP
  ðŸ… Liga: {league}

ðŸ”— <b>Referal havola:</b>
<code>https://t.me/{(await bot.get_me()).username}?start={user_id}</code>

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await callback.message.edit_text(profile_text, reply_markup=Keyboards.profile_menu(user), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.message(F.text.in_(["âœ¨ Yangi funksiyalar", "Yangi funksiyalar", "ðŸ†• Yangi funksiyalar"]))
async def handle_new_features(message: Message):
    """Yangi funksiyalar bo'limi - WebApp'ga yo'naltirish"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    await db.update_user_activity(user_id)
    
    text = """
ðŸ†• <b>YANGI FUNKSIYALAR</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸš€ WebApp orqali to'liq tajriba!</b>

âœ… <b>Mavjud:</b>
â€¢ ðŸŽ® Gamification Hub
â€¢ âš¡ Live Battle Quiz
â€¢ ðŸ† Real-time Leaderboard
â€¢ ðŸ“Š Analytics Dashboard
â€¢ ðŸŽ¯ Daily Challenges

ðŸ”œ <b>Tez orada:</b>
â€¢ ðŸŽµ Music Player
â€¢ ðŸ“± Offline Mode
â€¢ ðŸŒ Multi-language
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>WebApp'ni ochib barcha funksiyalardan foydalaning!</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(
        text="ðŸš€ WebApp'ni ochish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=new_features&user_id={user_id}")
    )
    builder.button(text="âš¡ Live Battle", callback_data="start_group_battle")
    builder.button(text="ðŸŽ¯ AI Quiz", callback_data="quiz_menu")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 2, 1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "new_features_menu")
async def handle_new_features_callback(callback: CallbackQuery):
    """Yangi funksiyalar callback"""
    user_id = callback.from_user.id
    
    text = """
ðŸ†• <b>YANGI FUNKSIYALAR</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸš€ WebApp orqali to'liq tajriba!</b>

âœ… <b>Mavjud:</b>
â€¢ ðŸŽ® Gamification Hub
â€¢ âš¡ Live Battle Quiz
â€¢ ðŸ† Real-time Leaderboard
â€¢ ðŸ“Š Analytics Dashboard

ðŸ”œ <b>Tez orada:</b>
â€¢ ðŸŽµ Music Player
â€¢ ðŸ“± Offline Mode
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(
        text="ðŸš€ WebApp'ni ochish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=new_features&user_id={user_id}")
    )
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

# =============================================================================
# PREMIUM BO'LIMI - TO'LOV TIZIMI
# =============================================================================

@router.message(F.text.in_(["ðŸ’Ž Premium", "Premium"]))
async def handle_premium_text(message: Message):
    """Premium bo'limi - Serious Business Style"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    sub_type = user.get('subscription_type', 0)
    sub_name = DatabaseManager.get_subscription_name(sub_type)
    ai_limit = Config.DAILY_AI_LIMITS.get(sub_type, 10)
    
    text = f"""
ðŸ’Ž <b>PREMIUM OBUNA</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ‘¤ <b>Joriy status:</b> {sub_name}
ðŸ¤– <b>AI limit:</b> {ai_limit} savol/kun
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>O'z rivojlanishingizga kuniga 1,166 so'm ajrata olmasangiz, muvaffaqiyat haqida gapirmang.</b>

Bugungi kunda axborot va tezlik â€” eng qimmat resurs.
Biz sizga shunchaki obuna emas, <b>raqobatchilaringizdan ustun bo'lishingiz</b> uchun kompleks vosita taklif qilyapmiz.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ’Ž PREMIUM (25,000 so'm/oy)</b>
â€¢ ðŸ¤– 100 ta AI savol/kun
â€¢ ðŸ“¥ Cheksiz yuklash
â€¢ ðŸŽ¬ 1080p kinolar
â€¢ â­ Har soatda 15 XP

<b>ðŸ‘‘ EXCLUSIVE (75,000 so'm/oy)</b>
â€¢ ðŸ¤– 999 ta AI savol/kun
â€¢ ðŸ“¥ Cheksiz yuklash  
â€¢ ðŸŽ¬ 4K kinolar
â€¢ â­ Har soatda 25 XP
â€¢ ðŸ’Ž VIP support
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>ðŸ’³ To'lov:</b>
Karta: <code>{Config.PAYMENT_CARD}</code>
Egasi: {Config.PAYMENT_HOLDER}
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’Ž Premium (25,000)", callback_data="buy_premium_1")
    builder.button(text="ðŸ‘‘ Exclusive (75,000)", callback_data="buy_exclusive_1")
    builder.button(text="ðŸ“‹ Karta nusxalash", callback_data="copy_payment_card")
    builder.button(text="ðŸ“¤ Chek yuborish", callback_data="send_payment_receipt")
    builder.button(
        text="ðŸš€ WebApp'da ko'rish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=premium&user_id={user_id}")
    )
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(2, 2, 1, 1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "premium_menu")
async def handle_premium_menu_callback(callback: CallbackQuery):
    """Premium menu callback"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    sub_type = user.get('subscription_type', 0) if user else 0
    sub_name = DatabaseManager.get_subscription_name(sub_type)
    ai_limit = Config.DAILY_AI_LIMITS.get(sub_type, 10)
    
    text = f"""
ðŸ’Ž <b>PREMIUM OBUNA</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ‘¤ <b>Joriy status:</b> {sub_name}
ðŸ¤– <b>AI limit:</b> {ai_limit} savol/kun
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>ðŸ’Ž PREMIUM (25,000 so'm/oy)</b>
â€¢ ðŸ¤– 100 ta AI savol/kun
â€¢ ðŸ“¥ Cheksiz yuklash
â€¢ ðŸŽ¬ 1080p kinolar

<b>ðŸ‘‘ EXCLUSIVE (75,000 so'm/oy)</b>
â€¢ ðŸ¤– 999 ta AI savol/kun
â€¢ ðŸ“¥ Cheksiz yuklash  
â€¢ ðŸŽ¬ 4K kinolar
â€¢ ðŸ’Ž VIP support
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>ðŸ’³ To'lov:</b>
Karta: <code>{Config.PAYMENT_CARD}</code>
Egasi: {Config.PAYMENT_HOLDER}
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’Ž Premium (25,000)", callback_data="buy_premium_1")
    builder.button(text="ðŸ‘‘ Exclusive (75,000)", callback_data="buy_exclusive_1")
    builder.button(text="ðŸ“‹ Karta nusxalash", callback_data="copy_payment_card")
    builder.button(text="ðŸ“¤ Chek yuborish", callback_data="send_payment_receipt")
    builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
    builder.adjust(2, 2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "copy_payment_card")
async def handle_copy_payment_card(callback: CallbackQuery):
    """Karta raqamini ko'rsatish"""
    await callback.answer(
        f"ðŸ’³ Karta: {Config.PAYMENT_CARD}\nðŸ‘¤ {Config.PAYMENT_HOLDER}",
        show_alert=True
    )

@router.callback_query(F.data.startswith("buy_premium_"))
async def handle_buy_premium(callback: CallbackQuery):
    """Premium sotib olish"""
    plan = callback.data.replace("buy_premium_", "")
    price = Config.PREMIUM_PRICES.get(f'premium_{plan}', 25000)
    
    text = f"""
ðŸ’Ž <b>PREMIUM SOTIB OLISH</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Tanlangan tarif:</b> Premium ({plan} oylik)
<b>Narxi:</b> {price:,} so'm
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>To'lov qilish uchun:</b>

1ï¸âƒ£ Quyidagi kartaga to'lang:
   <code>{Config.PAYMENT_CARD}</code>
   ðŸ‘¤ {Config.PAYMENT_HOLDER}

2ï¸âƒ£ To'lov chekini rasmga oling

3ï¸âƒ£ "ðŸ“¤ Chek yuborish" tugmasini bosing

â° <b>Tekshiruv:</b> 24 soat ichida
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“‹ Karta nusxalash", callback_data="copy_payment_card")
    builder.button(text="ðŸ“¤ Chek yuborish", callback_data="send_payment_receipt")
    builder.button(text="ðŸ”™ Orqaga", callback_data="premium_menu")
    builder.adjust(2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("buy_exclusive_"))
async def handle_buy_exclusive(callback: CallbackQuery):
    """Exclusive sotib olish"""
    plan = callback.data.replace("buy_exclusive_", "")
    price = Config.PREMIUM_PRICES.get(f'exclusive_{plan}', 75000)
    
    text = f"""
ðŸ‘‘ <b>EXCLUSIVE SOTIB OLISH</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Tanlangan tarif:</b> Exclusive ({plan} oylik)
<b>Narxi:</b> {price:,} so'm
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>To'lov qilish uchun:</b>

1ï¸âƒ£ Quyidagi kartaga to'lang:
   <code>{Config.PAYMENT_CARD}</code>
   ðŸ‘¤ {Config.PAYMENT_HOLDER}

2ï¸âƒ£ To'lov chekini rasmga oling

3ï¸âƒ£ "ðŸ“¤ Chek yuborish" tugmasini bosing

â° <b>Tekshiruv:</b> 24 soat ichida
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“‹ Karta nusxalash", callback_data="copy_payment_card")
    builder.button(text="ðŸ“¤ Chek yuborish", callback_data="send_payment_receipt")
    builder.button(text="ðŸ”™ Orqaga", callback_data="premium_menu")
    builder.adjust(2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "send_payment_receipt")
async def handle_send_payment_receipt(callback: CallbackQuery, state: FSMContext):
    """To'lov cheki yuborish"""
    text = """
ðŸ“¤ <b>TO'LOV CHEKINI YUBORISH</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Quyidagilarni yuboring:</b>

1ï¸âƒ£ To'lov cheki <b>rasmi</b>
2ï¸âƒ£ Qaysi tarifni tanlaganingiz

<b>Masalan:</b>
"Premium 1 oylik" + chek rasmi
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Tekshiruv 24 soat ichida amalga oshiriladi.
âœ… Tasdiqlangandan so'ng darhol aktivlashadi.

<b>Iltimos, chek rasmini yuboring:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âŒ Bekor qilish", callback_data="premium_menu")
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await state.set_state(UserStates.waiting_payment_receipt)
    await callback.answer()

@router.message(UserStates.waiting_payment_receipt, F.photo)
async def handle_payment_receipt_photo(message: Message, state: FSMContext):
    """To'lov cheki rasmini qabul qilish"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    photo_id = message.photo[-1].file_id
    caption = message.caption or "Tarif ko'rsatilmagan"
    
    # Payment request yaratish
    payment_id = f"PAY{int(time.time())}{random.randint(1000, 9999)}"
    
    async with db.connect() as conn:
        await conn.execute('''
            INSERT INTO payment_requests (payment_id, user_id, plan, receipt_file_id, status, created_at)
            VALUES (?, ?, ?, ?, 'pending', datetime('now'))
        ''', (payment_id, user_id, caption, photo_id))
        await conn.commit()
    
    # Foydalanuvchiga tasdiqlash
    await message.answer(
        f"âœ… <b>CHEK QABUL QILINDI!</b>\n\n"
        f"ðŸ†” <b>So'rov ID:</b> <code>{payment_id}</code>\n"
        f"ðŸ“ <b>Tarif:</b> {caption}\n\n"
        f"â° Admin tomonidan 24 soat ichida tekshiriladi.\n"
        f"âœ… Tasdiqlangandan so'ng sizga xabar yuboriladi.",
        reply_markup=Keyboards.main_menu(user_id),
        parse_mode=ParseMode.HTML
    )
    
    # Adminlarga yuborish
    for admin_id in Config.ADMIN_IDS:
        try:
            admin_builder = InlineKeyboardBuilder()
            admin_builder.button(text="âœ… Tasdiqlash", callback_data=f"admin_approve_payment_{payment_id}")
            admin_builder.button(text="âŒ Rad etish", callback_data=f"admin_reject_payment_{payment_id}")
            admin_builder.adjust(2)
            
            await bot.send_photo(
                admin_id,
                photo=photo_id,
                caption=f"ðŸ’³ <b>YANGI TO'LOV SO'ROVI</b>\n\n"
                        f"ðŸ†” <b>ID:</b> <code>{payment_id}</code>\n"
                        f"ðŸ‘¤ <b>Foydalanuvchi:</b> {user.get('full_name', 'Noma\'lum')}\n"
                        f"ðŸ†” <b>User ID:</b> <code>{user_id}</code>\n"
                        f"ðŸ“ <b>Tarif:</b> {caption}\n"
                        f"ðŸ“… <b>Sana:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}",
                reply_markup=admin_builder.as_markup(),
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            logger.error(f"Admin {admin_id} ga yuborishda xatolik: {e}")
    
    await state.clear()
    logger.info(f"Payment request created: {payment_id} by user {user_id}")

@router.callback_query(F.data.startswith("admin_approve_payment_"))
async def handle_admin_approve_payment(callback: CallbackQuery):
    """Admin: To'lovni tasdiqlash"""
    admin_id = callback.from_user.id
    if not Config.is_admin(admin_id):
        await callback.answer("Siz admin emassiz!")
        return
    
    payment_id = callback.data.replace("admin_approve_payment_", "")
    
    async with db.connect() as conn:
        # Payment so'rovini olish
        cursor = await conn.execute(
            'SELECT user_id, plan FROM payment_requests WHERE payment_id = ?',
            (payment_id,)
        )
        payment = await cursor.fetchone()
        
        if not payment:
            await callback.answer("To'lov so'rovi topilmadi!")
            return
        
        user_id, plan = payment
        
        # Subscription turini aniqlash
        plan_lower = plan.lower() if plan else ""
        if "exclusive" in plan_lower:
            sub_type = 3  # Exclusive
            days = 30
        else:
            sub_type = 2  # Premium
            days = 30
        
        # Foydalanuvchi subscriptionini yangilash
        end_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')
        await conn.execute('''
            UPDATE users 
            SET subscription_type = ?, subscription_end = ?, ai_limit = ?
            WHERE user_id = ?
        ''', (sub_type, end_date, Config.DAILY_AI_LIMITS.get(sub_type, 100), user_id))
        
        # Payment statusini yangilash
        await conn.execute('''
            UPDATE payment_requests 
            SET status = 'approved', approved_by = ?, approved_at = datetime('now')
            WHERE payment_id = ?
        ''', (admin_id, payment_id))
        
        await conn.commit()
    
    # Foydalanuvchiga xabar
    try:
        await bot.send_message(
            user_id,
            f"ðŸŽ‰ <b>TO'LOV TASDIQLANDI!</b>\n\n"
            f"âœ… Sizning {DatabaseManager.get_subscription_name(sub_type)} obunangiz aktivlashtirildi!\n"
            f"ðŸ“… <b>Muddati:</b> {days} kun\n"
            f"ðŸ¤– <b>AI limit:</b> {Config.DAILY_AI_LIMITS.get(sub_type, 100)} savol/kun\n\n"
            f"ðŸš€ Botdan to'liq foydalaning!",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"User {user_id} ga xabar yuborishda xatolik: {e}")
    
    await callback.message.edit_caption(
        caption=callback.message.caption + f"\n\nâœ… <b>TASDIQLANDI</b> by {callback.from_user.full_name}",
        parse_mode=ParseMode.HTML
    )
    await callback.answer("âœ… To'lov tasdiqlandi!")
    logger.info(f"Payment {payment_id} approved by admin {admin_id}")

@router.callback_query(F.data.startswith("admin_reject_payment_"))
async def handle_admin_reject_payment(callback: CallbackQuery):
    """Admin: To'lovni rad etish"""
    admin_id = callback.from_user.id
    if not Config.is_admin(admin_id):
        await callback.answer("Siz admin emassiz!")
        return
    
    payment_id = callback.data.replace("admin_reject_payment_", "")
    
    async with db.connect() as conn:
        cursor = await conn.execute(
            'SELECT user_id FROM payment_requests WHERE payment_id = ?',
            (payment_id,)
        )
        payment = await cursor.fetchone()
        
        if not payment:
            await callback.answer("To'lov so'rovi topilmadi!")
            return
        
        user_id = payment[0]
        
        await conn.execute('''
            UPDATE payment_requests 
            SET status = 'rejected', approved_by = ?, approved_at = datetime('now')
            WHERE payment_id = ?
        ''', (admin_id, payment_id))
        await conn.commit()
    
    # Foydalanuvchiga xabar
    try:
        await bot.send_message(
            user_id,
            f"âŒ <b>TO'LOV RAD ETILDI</b>\n\n"
            f"Sizning to'lov so'rovingiz rad etildi.\n\n"
            f"<b>Mumkin sabablar:</b>\n"
            f"â€¢ Chek aniq ko'rinmayapti\n"
            f"â€¢ Summa to'g'ri kelmayapti\n"
            f"â€¢ Boshqa texnik muammo\n\n"
            f"Iltimos, qaytadan urinib ko'ring yoki @{Config.SUPPORT_USERNAME} ga murojaat qiling.",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"User {user_id} ga xabar yuborishda xatolik: {e}")
    
    await callback.message.edit_caption(
        caption=callback.message.caption + f"\n\nâŒ <b>RAD ETILDI</b> by {callback.from_user.full_name}",
        parse_mode=ParseMode.HTML
    )
    await callback.answer("âŒ To'lov rad etildi!")
    logger.info(f"Payment {payment_id} rejected by admin {admin_id}")

# =============================================================================
# PROFIL BO'LIMI
# =============================================================================

@router.message(F.text.in_(["ðŸ‘¤ Profil", "Profil"]))
async def handle_profile_text(message: Message):
    """Profil bo'limi - WebApp'ga yo'naltirish"""
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Iltimos, /start komandasini bosing.")
        return
    
    xp = user.get('xp', 0)
    level = user.get('level', 1)
    
    text = f"""
ðŸ‘¤ <b>MENING PROFILIM</b>

ðŸ†” <b>ID:</b> <code>{user_id}</code>
â­ï¸ <b>Level:</b> {level}
âœ¨ <b>XP:</b> {xp:,}

ðŸš€ <b>Batafsil statistika WebApp'da:</b>
â€¢ ðŸ“Š To'liq statistika va tahlil
â€¢ ðŸ… Yutuqlar va unvonlar
â€¢ ðŸ“… Kunlik faollik tarixi
â€¢ âš™ï¸ Sozlamalar

<i>Pastdagi tugmani bosing:</i>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(
        text="ðŸš€ WebApp'ni ochish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=profile&user_id={user_id}")
    )
    builder.button(text="ðŸŽ Kunlik bonus", callback_data="daily_bonus")
    builder.button(text="âš™ï¸ Sozlamalar", callback_data="settings_menu")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 2, 1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

# ========== Eski Premium handler o'chirildi, yangi to'lov tizimi bilan almashtirildi ==========

# Eski premium handlerlar o'chirildi - yangi to'lov tizimi yuqorida qo'shilgan

@router.callback_query(F.data.startswith("premium_"))
async def handle_premium_selection(callback: CallbackQuery, state: FSMContext):
    """Premium tarifni tanlash (3 ta tarif)"""
    plan_type = callback.data.replace("premium_", "")
    user_id = callback.from_user.id
    
    # Faqat 3 ta tarif: premium, exclusive va exclusive_pro_plus_1
    prices = {
        "premium": Config.PRICE_PREMIUM,
        "exclusive": Config.PRICE_EXCLUSIVE,
        "exclusive_pro_plus_1": 9990
    }
    
    plan_names = {
        "premium": "Premium",
        "exclusive": "Exclusive",
        "exclusive_pro_plus_1": "Exclusive Pro+ (1 kun)"
    }
    
    plan_days = {
        "premium": 30,
        "exclusive": 30,
        "exclusive_pro_plus_1": 1
    }
    
    subscription_types = {
        "premium": 5,  # Premium
        "exclusive": 2,  # Exclusive
        "exclusive_pro_plus_1": 3  # Exclusive Pro+
    }
    
    if plan_type not in prices:
        await callback.answer("âŒ Noto'g'ri tarif!")
        return
    
    price = prices[plan_type]
    plan_name = plan_names[plan_type]
    days = plan_days[plan_type]
    sub_type = subscription_types[plan_type]
    
    plan_descriptions = {
        "premium": """ðŸ”¥ <b>PREMIUM - BIR KOFE NARXIGA HAYOTINGIZNI O'ZGARTIRING!</b>

â˜• <b>1 kofe narxi = 15,000 so'm</b>
ðŸ’Ž <b>Premium (30 kun) = 24,990 so'm</b>
ðŸ’¡ <b>Bu faqat 1.7 kofe narxi - HAR KUNI 833 SO'M!</b>

âš¡ <b>NIMA O'ZGARADI?</b>
  ðŸ¤– <b>Cheksiz AI savol</b> - Har bir savol 10,000 so'm, sizda bepul!
  ðŸ“¥ <b>Cheksiz yuklash</b> - Har bir kitob 10,000 so'm, sizda cheksiz!
  ðŸŽ¬ <b>1080p kinolar</b> - Kinozalarga 50,000 so'm, sizda bepul!
  ðŸ“š <b>Premium kitoblar</b> - Barcha eksklyuziv kontentlar!
  â›ï¸ <b>Mining x2 tezlik</b> - XP 2 barobar tez to'plang!
  ðŸ’° <b>Har soatda 15 XP</b> - 30 kunda 10,800 XP bepul!
  ðŸŽ <b>VIP nishonlar</b> - Do'stlaringizdan ajralib turing!

ðŸ’¸ <b>TEJASH HISOB-KITOB:</b>
  â€¢ Kinozalarga: 50,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ Kitoblar: 100,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ AI Mentor: 500,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ XP mukofotlari: 10,800 XP â†’ <b>Bepul!</b>
  <b>Jami tejash: 658,640 so'm/oy!</b>
  <b>ROI: 2634%!</b>

â° <b>SHOSHILING - CHEGIRMA TUGAYDI!</b>
  ðŸ”¥ <b>Faqat bugun</b> maxsus narx!
  ðŸ“Š <b>Faqat 50 ta</b> Premium obuna qoldi!
  ðŸŽ <b>Birinchi 10 kishi</b> uchun qo'shimcha 5 kun bepul!
  âš¡ <b>Har kuni 833 so'm</b> - bu juda arzon!

ðŸ’­ <b>O'YLAMASDAN QAROR QILING!</b>
  Bu faqat bir kofe narxi - lekin hayotingizni butunlay o'zgartiradi!
  Har kuni 833 so'm - bu juda arzon!
  Do'stlaringiz allaqachon sotib olgan - siz ham qo'shiling!
  âš¡ <b>Bugun sotib oling va 10,800 XP bepul oling!</b>""",
        
        "exclusive": """ðŸ† <b>EXCLUSIVE - BIR TUSHLIK NARXIGA ENG YUQORI DARAJAGA ERISHING!</b>

ðŸ½ï¸ <b>1 tushlik narxi = 25,000 so'm</b>
ðŸ† <b>Exclusive (30 kun) = 34,990 so'm</b>
ðŸ’¡ <b>Bu faqat 1.4 tushlik narxi - HAR KUNI 1,166 SO'M!</b>

âš¡ <b>NIMA O'ZGARADI?</b>
  ðŸ¤– <b>Cheksiz AI savol</b> - Cheksiz savollar! (Qiymati: 1,000,000 so'm/oy)
  ðŸ“¥ <b>Cheksiz yuklash</b> - Barcha kitoblar, filmlar, kurslar bepul!
  ðŸŽ¬ <b>1080p/4K kinolar</b> - Eng yuqori sifat! (Kinozalarga 100,000 so'm/oy)
  ðŸ“š <b>Barcha Premium kitoblar</b> - Eksklyuziv kontentlar!
  â›ï¸ <b>Mining x3 tezlik</b> - XP 3 barobar tez to'plang!
  ðŸ’° <b>Har soatda 20 XP</b> - 30 kunda 14,400 XP bepul!
  ðŸŽ <b>VIP nishonlar</b> - Do'stlaringizdan ajralib turing!
  ðŸ’Ž <b>Kurslar uchun 20% chegirma</b> - Har bir kursda tejang!
  ðŸ† <b>Liga reytingida ustunlik</b> - Birinchi o'rinda bo'ling!

ðŸ’¸ <b>TEJASH HISOB-KITOB:</b>
  â€¢ Kinozalarga: 100,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ Kitoblar: 200,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ AI Mentor: 1,000,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ Kurslar chegirmasi: 50,000 so'm/oy â†’ <b>0 so'm</b>
  â€¢ XP mukofotlari: 14,400 XP â†’ <b>Bepul!</b>
  <b>Jami tejash: 1,362,960 so'm/oy!</b>
  <b>ROI: 3894%!</b>

â° <b>SHOSHILING - CHEGIRMA TUGAYDI!</b>
  ðŸ”¥ <b>Faqat bugun</b> maxsus narx!
  ðŸ“Š <b>Faqat 30 ta</b> Exclusive obuna qoldi!
  ðŸŽ <b>Birinchi 5 kishi</b> uchun qo'shimcha 7 kun bepul!
  âš¡ <b>Har kuni 1,166 so'm</b> - bu juda arzon!

ðŸ’­ <b>O'YLAMASDAN QAROR QILING!</b>
  Bu faqat bir tushlik narxi - lekin hayotingizni butunlay o'zgartiradi!
  Har kuni 1,166 so'm - bu juda arzon!
  Do'stlaringiz allaqachon sotib olgan - siz ham qo'shiling!
  âš¡ <b>Bugun sotib oling va 14,400 XP bepul oling!</b>
  Bu imkoniyatni qo'ldan bermang - bugun sotib oling!""",

        "exclusive_pro_plus_1": """ðŸ”¥ <b>EXCLUSIVE PRO+ (1 KUN) - ENG ARZON SINOV TARIFI!</b>

ðŸ’° <b>Narxi:</b> 9,990 so'm
â± <b>Muddati:</b> 24 soat (1 kun)

âš¡ <b>BARCHA IMKONIYATLAROCHILADI:</b>
  ðŸ¤– <b>Cheksiz AI savol</b> - Cheklovsiz testlar yarating!
  ðŸ“¥ <b>Cheksiz yuklash</b> - Barcha kitob va kinolar bepul!
  ðŸŽ¬ <b>4K Kinolar</b> - Eng yuqori sifatda tomosha qiling!
  â›ï¸ <b>Mining x3 tezlik</b> - 24 soat davomida!
  
ðŸŽ <b>MAXSUS BONUS:</b>
  â€¢ +1,000 XP darhol beriladi!
  â€¢ +500 Oltin (Gold)
  
ðŸ’¡ <b>KIMLAR UCHUN?</b>
  â€¢ Bot imkoniyatlarini sinab ko'rmoqchi bo'lganlar uchun
  â€¢ Faqat bugun ko'p narsa yuklab olmoqchi bo'lganlar uchun
  â€¢ Tezda XP yig'ib reytingda ko'tarilmoqchi bo'lganlar uchun

ðŸš€ <b>Hozir sinab ko'ring - atigi 9,990 so'm!</b>"""
    }
    
    description = plan_descriptions.get(plan_type, "")
    
    text = f"""{description}

ðŸ’° <b>Narx:</b> {price:,} so'm
ðŸ“… <b>Davomiylik:</b> {days} kun
ðŸ†” <b>Sizning ID:</b> <code>{user_id}</code>

ðŸ’³ <b>To'lov usulini tanlang:</b>
    """
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.payment_methods_menu())
    
    # FSMContext orqali ma'lumotlarni saqlash
    await state.update_data(
        plan_type=plan_type,
        plan_name=plan_name,
        price=price,
        days=days,
        sub_type=sub_type
    )
    
    await callback.answer()

@router.callback_query(F.data.startswith("payment_"))
async def handle_payment_method(callback: CallbackQuery, state: FSMContext):
    """To'lov usulini tanlash"""
    method = callback.data.replace("payment_", "")
    user_id = callback.from_user.id
    
    # FSMContext orqali ma'lumotlarni olish
    data = await state.get_data()
    
    if not data or not isinstance(data, dict):
        await callback.answer("âŒ Ma'lumotlar topilmadi! Qaytadan boshlang.")
        await safe_edit_text(callback,
            "âŒ <b>XATOLIK</b>\n\n"
            "Ma'lumotlar topilmadi. Iltimos, Premium obuna bo'limiga qaytib, qaytadan boshlang.",
            reply_markup=Keyboards.premium_menu()
        )
        await state.clear()
        return
    
    plan_type = data.get("plan_type")
    plan_name = data.get("plan_name", plan_type.capitalize())
    price = data.get("price")
    days = data.get("days")
    sub_type = data.get("sub_type")
    
    if not plan_type or not price or not days:
        await callback.answer("âŒ Ma'lumotlar to'liq emas!")
        return
    
    # Faqat Humo va Uzcard
    methods = {
        "humo": "HUMO",
        "uzcard": "Uzcard"
    }
    
    if method not in methods:
        await callback.answer("âŒ Noto'g'ri to'lov usuli! Faqat HUMO yoki Uzcard tanlang.")
        return
    
    method_name = methods[method]
    
    success, payment_id, payment_data = await db.create_payment(
        user_id=user_id,
        amount=price,
        description=f"{plan_name} obuna {days} kun",
        payment_method=method_name
    )
    
    if not success:
        await safe_edit_text(callback,
            "âŒ <b>To'lov yaratishda xatolik!</b>\n\n"
            "Iltimos, keyinroq urinib ko'ring.",
            reply_markup=Keyboards.back_button("premium_menu")
        )
        return
    
    # Karta raqamini ko'rsatish
    payment_card = Config.PAYMENT_CARD
    payment_name = Config.PAYMENT_CARD_NAME
    
    text = f"""
ðŸ”¥ <b>TO'LOV QILISH - HAYOTINGIZ O'ZGARMOQDA!</b>

ðŸ’³ <b>TO'LOV USULI:</b> {method_name}
ðŸ’° <b>SUMMA:</b> {price:,} so'm
ðŸ“… <b>KUNLAR:</b> {days} kun
ðŸ†” <b>PAYMENT ID:</b> <code>{payment_id}</code>

ðŸ’¡ <b>ESLATMA:</b>
  â˜• Bu faqat <b>{"1-2 kofe" if price == 29990 else "1-2 tushlik"}</b> narxi!
  ðŸ’¸ <b>650,000+ so'm tejaysiz</b> har oy!
  âš¡ <b>Hozir to'lov qiling</b> - hayotingiz bugundan o'zgara boshlaydi!

ðŸ“‹ <b>TO'LOV QILISH TARTIBI:</b>

1ï¸âƒ£ <b>Quyidagi kartaga to'lov qiling:</b>

ðŸ’³ <b>Karta raqami (nusxalash uchun bosib turing):</b>
<code>{payment_card}</code>

ðŸ‘¤ <b>Ism:</b> {payment_name}

ðŸ’¡ <b>Karta raqamini nusxalash:</b>
Karta raqamini bosib turing va nusxalang: <code>{payment_card}</code>

2ï¸âƒ£ <b>To'lov qilgandan so'ng, chekni rasm sifatida yuboring</b>

ðŸ“¸ <b>Chekni yuborish:</b>
To'lov qilgandan so'ng, chek rasmini yuboring. Admin tekshirib, Premium obunani faollashtiradi.

âš¡ <b>Tezkor tekshirish uchun:</b>
Payment ID: <code>{payment_id}</code>

â° <b>SHOSHILING!</b>
  ðŸ”¥ Chegirma <b>bugun</b> tugaydi!
  ðŸ“Š <b>Faqat {"50 ta" if price == 29990 else "30 ta"}</b> Premium obuna qoldi!
  ðŸŽ <b>Birinchi {"10 kishi" if price == 29990 else "5 kishi"}</b> uchun qo'shimcha {"5" if price == 29990 else "7"} kun bepul!

ðŸ’­ <b>O'YLAMASDAN QAROR QILING!</b>
  Bu faqat bir {"kofe" if price == 29990 else "tushlik"} narxi - lekin hayotingizni butunlay o'zgartiradi!

ðŸ”™ <b>Orqaga qaytish:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Orqaga", callback_data="premium_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    
    # FSMContext da payment_id ni saqlash va chek yuborish holatiga o'tkazish
    await state.update_data(payment_id=payment_id, plan_type=plan_type, price=price, days=days, sub_type=sub_type)
    await state.set_state(UserStates.waiting_payment_receipt)
    await callback.answer()

@router.callback_query(F.data == "market_premium")
async def handle_market_premium(callback: CallbackQuery):
    """Marketdagi premium tariflar"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    text = f"""
ðŸ›’ <b>MARKET - PREMIUM TARIFLAR</b>

ðŸ’° <b>Sizning XP: {user.get('xp', 0)}</b>

ðŸŽ <b>XP evaziga premium tariflar:</b>
  1ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[1]} XP
  3ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[3]} XP
  7ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[7]} XP
  1ï¸âƒ£5ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[15]} XP
  3ï¸âƒ£0ï¸âƒ£ Kunlik Premium - {Config.MARKET_PRICES[30]} XP
  ðŸ”¥ PRO (30 kun) - {Config.MARKET_PRICES[31]} XP

ðŸ’Ž <b>To'lov orqali Premium</b>
  Premium (30 kun) - 29,990 so'm
  Exclusive (30 kun) - 47,990 so'm

ðŸ‘‡ <b>Tarif tanlang:</b>
    """
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.market_premium_menu(user.get('xp', 0)))
    await callback.answer()

@router.callback_query(F.data.regexp(r"^buy_premium_\d+$"))
async def handle_buy_premium(callback: CallbackQuery):
    """Marketda premium tarif sotib olish"""
    days = int(callback.data.replace("buy_premium_", ""))
    user_id = callback.from_user.id
    
    user = await db.get_user(user_id)
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    price = Config.MARKET_PRICES.get(days, 1000)
    
    if user['xp'] < price:
        await callback.message.edit_text(
            f"âŒ <b>Yetarli XP yo'q!</b>\n\n"
            f"ðŸ’° Sizning XP: {user['xp']}\n"
            f"ðŸ’° Kerak: {price} XP\n\n"
            f"XP to'plash uchun:\n"
            f"ðŸŽ Kunlik bonus oling\n"
            f"ðŸ‘¥ Referal taklif qiling\n"
            f"ðŸ“¥ Kitob yuklang\n"
            f"â›ï¸ Mining fermasidan foydalaning",
            reply_markup=Keyboards.back_button("market_premium")
        )
        await callback.answer()
        return
    
    subscription_type = 5  # Premium
    if days == 31:
        subscription_type = 4  # PRO
    elif days >= 15:
        subscription_type = 3  # Exclusive Pro+
    elif days >= 7:
        subscription_type = 2  # Exclusive
    else:
        subscription_type = 5  # Premium
    
    await db.update_user(
        user_id,
        xp=user['xp'] - price
    )
    
    success = await db.activate_premium(user_id, days, subscription_type)
    
    if success:
        await callback.message.edit_text(
            f"âœ… <b>PREMIUM SOTIB OLINDI!</b>\n\n"
            f"ðŸŽ Sizga {days} kunlik Premium obuna berildi!\n"
            f"ðŸ’° Sarflangan XP: {price}\n"
            f"ðŸ’° Qolgan XP: {user['xp'] - price}\n"
            f"ðŸ‘‘ Status: {DatabaseManager.get_subscription_name(subscription_type)}\n\n"
            f"ðŸš€ Endi sizda:\n"
            f"ðŸ“¥ Cheksiz yuklash\n"
            f"ðŸ¤– AI limit {200 if subscription_type == 2 else 999 if subscription_type == 3 else 50} ta\n"
            f"ðŸŽ¬ Premium kinolar\n"
            f"ðŸ“š Premium kitoblar",
            reply_markup=Keyboards.back_button("main_menu")
        )
    else:
        await callback.message.edit_text(
            "âŒ <b>Xatolik!</b>\n\nPremium faollashtirishda xatolik yuz berdi.",
            reply_markup=Keyboards.back_button("market_premium")
        )
    
    await callback.answer()

@router.callback_query(F.data == "payment_methods")
async def handle_payment_methods(callback: CallbackQuery):
    """To'lov usullari"""
    await callback.message.edit_text(
        "ðŸ’³ <b>TO'LOV USULLARI</b>\n\n"
        "Quyidagi to'lov usullaridan birini tanlang:",
        reply_markup=Keyboards.payment_methods_menu()
    )
    await callback.answer()

@router.callback_query(F.data == "premium_exclusive")
async def handle_premium_exclusive(callback: CallbackQuery, state: FSMContext):
    """Premium Exclusive tarifini tanlash (34,990 so'm) - MARKETING"""
    await callback.answer()
    await state.update_data(
        plan_type="exclusive",
        price=Config.PRICE_EXCLUSIVE,
        days=30,
        sub_type=2
    )
    await callback.message.edit_text(
        "ðŸ† <b>EXCLUSIVE - BIR TUSHLIK NARXIGA ENG YUQORI DARAJAGA ERISHING!</b>\n\n"
        "ðŸ½ï¸ <b>1 tushlik narxi = 25,000 so'm</b>\n"
        "ðŸ† <b>Exclusive (30 kun) = 34,990 so'm</b>\n"
        "ðŸ’¡ <b>Bu faqat 1.4 tushlik narxi - HAR KUNI 1,166 SO'M!</b>\n\n"
        "âš¡ <b>NIMA O'ZGARADI?</b>\n"
        "  ðŸ¤– <b>Cheksiz AI savol</b> - Cheksiz savollar! (Qiymati: 1,000,000 so'm/oy)\n"
        "  ðŸ“¥ <b>Cheksiz yuklash</b> - Barcha kitoblar, filmlar, kurslar bepul!\n"
        "  ðŸŽ¬ <b>1080p/4K kinolar</b> - Eng yuqori sifat! (Kinozalarga 100,000 so'm/oy)\n"
        "  ðŸ’° <b>Har soatda 20 XP</b> - 30 kunda 14,400 XP bepul!\n"
        "  ðŸ’Ž <b>Kurslar uchun 20% chegirma</b> - Har bir kursda tejang!\n\n"
        "ðŸ’¸ <b>TEJASH HISOB-KITOB:</b>\n"
        "  â€¢ Kinozalarga: 100,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ Kitoblar: 200,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ AI Mentor: 1,000,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ Kurslar chegirmasi: 50,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ XP mukofotlari: 14,400 XP â†’ <b>Bepul!</b>\n"
        "  <b>Jami tejash: 1,362,960 so'm/oy!</b>\n"
        "  <b>ROI: 3894%!</b>\n\n"
        "â° <b>SHOSHILING - CHEGIRMA TUGAYDI!</b>\n"
        "  ðŸ”¥ <b>Faqat bugun</b> maxsus narx!\n"
        "  ðŸ“Š <b>Faqat 30 ta</b> Exclusive obuna qoldi!\n"
        "  ðŸŽ <b>Birinchi 5 kishi</b> uchun qo'shimcha 7 kun bepul!\n\n"
        "ðŸ’­ <b>O'YLAMASDAN QAROR QILING!</b>\n"
        "Bu faqat bir tushlik narxi - lekin hayotingizni butunlay o'zgartiradi!\n"
        "âš¡ <b>Bugun sotib oling va 14,400 XP bepul oling!</b>\n\n"
        "ðŸ’³ <b>To'lov usulini tanlang:</b>",
        reply_markup=Keyboards.payment_methods_menu(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "premium_premium")
async def handle_premium_premium(callback: CallbackQuery, state: FSMContext):
    """Premium tarifini tanlash (24,990 so'm) - MARKETING"""
    await callback.answer()
    await state.update_data(
        plan_type="premium",
        price=Config.PRICE_PREMIUM,
        days=30,
        sub_type=5
    )
    await callback.message.edit_text(
        "ðŸ”¥ <b>PREMIUM - BIR KOFE NARXIGA HAYOTINGIZNI O'ZGARTIRING!</b>\n\n"
        "â˜• <b>1 kofe narxi = 15,000 so'm</b>\n"
        "ðŸ’Ž <b>Premium (30 kun) = 24,990 so'm</b>\n"
        "ðŸ’¡ <b>Bu faqat 1.7 kofe narxi - HAR KUNI 833 SO'M!</b>\n\n"
        "âš¡ <b>NIMA O'ZGARADI?</b>\n"
        "  ðŸ¤– <b>Cheksiz AI savol</b> - Har bir savol 10,000 so'm, sizda bepul!\n"
        "  ðŸ“¥ <b>Cheksiz yuklash</b> - Har bir kitob 10,000 so'm, sizda cheksiz!\n"
        "  ðŸŽ¬ <b>1080p kinolar</b> - Kinozalarga 50,000 so'm, sizda bepul!\n"
        "  ðŸ’° <b>Har soatda 15 XP</b> - 30 kunda 10,800 XP bepul!\n\n"
        "ðŸ’¸ <b>TEJASH HISOB-KITOB:</b>\n"
        "  â€¢ Kinozalarga: 50,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ Kitoblar: 100,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ AI Mentor: 500,000 so'm/oy â†’ <b>0 so'm</b>\n"
        "  â€¢ XP mukofotlari: 10,800 XP â†’ <b>Bepul!</b>\n"
        "  <b>Jami tejash: 658,640 so'm/oy!</b>\n"
        "  <b>ROI: 2634%!</b>\n\n"
        "â° <b>SHOSHILING - CHEGIRMA TUGAYDI!</b>\n"
        "  ðŸ”¥ <b>Faqat bugun</b> maxsus narx!\n"
        "  ðŸ“Š <b>Faqat 50 ta</b> Premium obuna qoldi!\n"
        "  ðŸŽ <b>Birinchi 10 kishi</b> uchun qo'shimcha 5 kun bepul!\n\n"
        "ðŸ’­ <b>O'YLAMASDAN QAROR QILING!</b>\n"
        "Bu faqat bir kofe narxi - lekin hayotingizni butunlay o'zgartiradi!\n"
        "âš¡ <b>Bugun sotib oling va 10,800 XP bepul oling!</b>\n\n"
        "ðŸ’³ <b>To'lov usulini tanlang:</b>",
        reply_markup=Keyboards.payment_methods_menu(),
        parse_mode=ParseMode.HTML
    )

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def calculate_level(xp: int) -> int:
    """XP dan darajani hisoblash"""
    return xp // 1000 + 1

# -------------------------------------------------------------------------
# OPTIMIZATION: DECORATORS
# -------------------------------------------------------------------------

def admin_required(func):
    """Admin tekshiruv decorator"""
    async def wrapper(*args, **kwargs):
        # CallbackQuery yoki Message dan user_id olish
        if args and hasattr(args[0], 'from_user'):
            user_id = args[0].from_user.id
        elif 'callback' in kwargs:
            user_id = kwargs['callback'].from_user.id
        elif 'message' in kwargs:
            user_id = kwargs['message'].from_user.id
        else:
            return await func(*args, **kwargs)
        
        if not await check_is_admin(user_id, db):
            if hasattr(args[0], 'answer'):
                await args[0].answer("âŒ Siz admin emassiz!")
            return
        return await func(*args, **kwargs)
    return wrapper

def retry_on_error(max_retries: int = 3, delay: float = 1.0):
    """Xatolikda qayta urinish decorator"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        logger.error(f"{func.__name__} xatosi (max retries): {e}")
                        raise
                    logger.warning(f"{func.__name__} xatosi (attempt {attempt + 1}/{max_retries}): {e}")
                    await asyncio.sleep(delay * (attempt + 1))
            return None
        return wrapper
    return decorator

# ==================== PUSH NOTIFICATION WORKER ====================

async def push_notification_worker(bot: Bot, db: DatabaseManager):
    """Push notification worker - 2 kun botga kirmagan foydalanuvchilarga xabar yuboradi"""
    logger.info("Push notification worker ishga tushdi...")
    
    while True:
        try:
            await asyncio.sleep(3600)  # Har 1 soatda tekshirish
            
            # 2 kun botga kirmagan foydalanuvchilarni topish
            async with db.connect() as conn:
                cursor = await conn.execute('''
                    SELECT user_id, full_name, last_active_date, last_push_sent
                    FROM users
                    WHERE last_active_date < datetime('now', '-2 days')
                    AND (last_push_sent IS NULL OR last_push_sent < datetime('now', '-1 day'))
                    AND is_banned = 0
                    LIMIT 50
                ''')
                inactive_users = await cursor.fetchall()
            
            if not inactive_users:
                continue
            
            sent_count = 0
            failed_count = 0
            
            for user_row in inactive_users:
                try:
                    user_id = user_row[0]
                    full_name = user_row[1] or "Foydalanuvchi"
                    
                    # Push notification xabari
                    push_message = f"""
ðŸ‘‹ <b>Salom, {full_name}!</b>

ðŸ˜” Sizni ko'rmayapmiz! 2 kundan beri botga kirmadingiz.

ðŸ’¡ <b>Nima qilish mumkin:</b>
â€¢ ðŸ“š Yangi kitoblar o'qish
â€¢ ðŸŽ¬ Filmlar ko'rish
â€¢ ðŸŽ“ Kurslar sotib olish
â€¢ ðŸ’° XP to'plash
â€¢ ðŸŽ Kunlik bonus olish

ðŸ”¥ <b>Bugun qaytib keling va bonus oling!</b>

ðŸ‘‡ <b>Botni ishga tushiring:</b>
                    """
                    
                    builder = InlineKeyboardBuilder()
                    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
                    builder.button(text="ðŸŽ Kunlik bonus", callback_data="daily_bonus")
                    builder.adjust(1, 1)
                    
                    await bot.send_message(
                        chat_id=user_id,
                        text=push_message,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
                    
                    # last_push_sent ni yangilash
                    async with db.connect() as conn:
                        await conn.execute('''
                            UPDATE users 
                            SET last_push_sent = datetime('now')
                            WHERE user_id = ?
                        ''', (user_id,))
                        await conn.commit()
                    
                    sent_count += 1
                    await asyncio.sleep(0.1)  # Rate limit uchun
                    
                except Exception as e:
                    failed_count += 1
                    logger.error(f"Push notification xatosi {user_row[0]}: {e}")
            
            if sent_count > 0:
                logger.info(f"Push notification: {sent_count} ta yuborildi, {failed_count} ta xatolik")
                
        except Exception as e:
            logger.error(f"Push notification worker xatosi: {e}")
            await asyncio.sleep(3600)  # Xatolik bo'lsa, 1 soatdan keyin qayta urinish

# -------------------------------------------------------------------------
# SAFE FUNCTIONS (ERROR HANDLING)
# -------------------------------------------------------------------------

async def safe_answer(message: Message, text: str, reply_markup=None, protect_content=False, **kwargs):
    """Xavfsiz xabar yuborish - protect_content faqat filmlar va kurslar uchun"""
    try:
        return await message.answer(
            text, 
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=ParseMode.HTML,
            **kwargs
        )
    except Exception as e:
        logger.error(f"safe_answer xatosi: {e}")
        try:
            return await message.answer(text, parse_mode=ParseMode.HTML)
        except Exception:
            pass

async def safe_edit_text(callback: CallbackQuery, text: str, reply_markup=None, protect_content=False, parse_mode=None, **kwargs):
    """Xavfsiz xabarni tahrirlash - protect_content faqat filmlar va kurslar uchun"""
    from aiogram.types import ReplyKeyboardMarkup
    
    # parse_mode ni kwargs dan olib tashlash (agar mavjud bo'lsa)
    if 'parse_mode' in kwargs:
        kwargs.pop('parse_mode')
    
    # parse_mode ni belgilash (default: HTML)
    if parse_mode is None:
        parse_mode = ParseMode.HTML
    
    if reply_markup and isinstance(reply_markup, ReplyKeyboardMarkup):
        try:
            await callback.message.delete()
        except Exception as e:
            logger.debug(f"Message delete error (normal): {e}")
        return await callback.message.answer(
            text,
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=parse_mode,
            **kwargs
        )
    
    # Xabarda matn borligini tekshirish
    try:
        # Agar xabar matnli bo'lmasa (masalan, document yoki photo), yangi xabar yuboramiz
        if not callback.message.text and not callback.message.caption:
            return await callback.message.answer(
                text,
                reply_markup=reply_markup,
                protect_content=protect_content,
                parse_mode=parse_mode,
                **kwargs
            )
        
        # Matnli xabarni tahrirlash
        return await callback.message.edit_text(
            text,
            reply_markup=reply_markup,
            parse_mode=parse_mode,
            **kwargs
        )
    except Exception as e:
        error_text = str(e).lower()
        if "message is not modified" in error_text:
            if reply_markup is not None:
                try:
                    return await callback.message.edit_reply_markup(reply_markup=reply_markup)
                except Exception as e2:
                    logger.debug(f"Edit reply markup error: {e2}")
            return None

        # Agar tahrirlashda xatolik bo'lsa, yangi xabar yuboramiz
        logger.debug(f"Edit text error, sending new message: {e}")
        try:
            await callback.message.delete()
        except Exception:
            pass
        return await callback.message.answer(
            text,
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=parse_mode,
            **kwargs
        )

async def safe_send_document(bot: Bot, chat_id: int, document, caption: str = None, reply_markup=None, protect_content=False, **kwargs):
    """Xavfsiz hujjat yuborish - protect_content faqat kurslar uchun"""
    try:
        return await bot.send_document(
            chat_id=chat_id,
            document=document,
            caption=caption,
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=ParseMode.HTML,
            **kwargs
        )
    except Exception as e:
        logger.error(f"safe_send_document xatosi: {e}")
        raise

async def safe_send_video(bot: Bot, chat_id: int, video, caption: str = None, reply_markup=None, protect_content=True, **kwargs):
    """Xavfsiz video yuborish - protect_content=True (filmlar va kurslar uchun)"""
    try:
        return await bot.send_video(
            chat_id=chat_id,
            video=video,
            caption=caption,
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=ParseMode.HTML,
            **kwargs
        )
    except Exception as e:
        logger.error(f"safe_send_video xatosi: {e}")
        raise

async def safe_send_photo(bot: Bot, chat_id: int, photo, caption: str = None, reply_markup=None, protect_content=False, **kwargs):
    """Xavfsiz rasm yuborish"""
    try:
        return await bot.send_photo(
            chat_id=chat_id,
            photo=photo,
            caption=caption,
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=ParseMode.HTML,
            **kwargs
        )
    except Exception as e:
        logger.error(f"safe_send_photo xatosi: {e}")
        raise

async def safe_send_audio(bot: Bot, chat_id: int, audio, caption: str = None, reply_markup=None, protect_content=False, **kwargs):
    """Xavfsiz audio yuborish"""
    try:
        return await bot.send_audio(
            chat_id=chat_id,
            audio=audio,
            caption=caption,
            reply_markup=reply_markup,
            protect_content=protect_content,
            parse_mode=ParseMode.HTML,
            **kwargs
        )
    except Exception as e:
        logger.error(f"safe_send_audio xatosi: {e}")
        raise

async def safe_delete_message(bot: Bot, chat_id: int, message_id: int):
    """Xavfsiz xabarni o'chirish"""
    try:
        await bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception as e:
        logger.debug(f"Message delete error (normal): {e}")

# -------------------------------------------------------------------------
# AUTO SEND FUNCTIONS
# -------------------------------------------------------------------------

async def auto_send_worker():
    """Background worker - bazadagi fayllarni avtomatik yuborish"""
    global auto_send_running, auto_send_target_user_id, bot, db
    
    logger.info("ðŸš€ Avtomatik yuborish ishga tushdi!")
    
    while auto_send_running:
        try:
            if not auto_send_target_user_id or not bot or not db:
                await asyncio.sleep(5)
                continue
            
            # Bazadan yuborilmagan fayllarni olish
            async with db.connect() as conn:
                files = []
                
                # Books jadvalidan (kitoblar va audio)
                cursor = await conn.execute('''
                    SELECT 'book' as type, code as item_id, caption as title, file_id, '' as genre, file_type
                    FROM books
                    WHERE file_id IS NOT NULL AND file_id != ''
                    AND status = 'approved'
                    AND is_active = 1
                    AND code NOT IN (SELECT item_id FROM sent_files WHERE item_type = 'book')
                    ORDER BY id ASC
                    LIMIT 10
                ''')
                books = await cursor.fetchall()
                files.extend(books)
                
                # Movies jadvalidan (filmlar)
                cursor = await conn.execute('''
                    SELECT 'movie' as type, CAST(id AS TEXT) as item_id, caption as title, file_id, genre, '' as file_type
                    FROM movies
                    WHERE file_id IS NOT NULL AND file_id != ''
                    AND status = 'approved'
                    AND is_active = 1
                    AND CAST(id AS TEXT) NOT IN (SELECT item_id FROM sent_files WHERE item_type = 'movie')
                    ORDER BY id ASC
                    LIMIT 10
                ''')
                movies = await cursor.fetchall()
                files.extend(movies)
            
            if not files:
                # Fayl qolmagan, 30 soniya kutish
                logger.info("ðŸ“­ Barcha fayllar yuborilgan, 30 soniya kutamiz...")
                await asyncio.sleep(30)
                continue
            
            # Har bir faylni yuborish
            for file_row in files:
                if not auto_send_running:
                    break
                
                try:
                    # aiosqlite.Row obyekti - dict'ga o'girish
                    file_dict = dict(file_row)
                    file_type = file_dict.get('type', 'book')
                    item_id = file_dict.get('item_id', '')
                    title = file_dict.get('title', 'Noma\'lum')
                    file_id = file_dict.get('file_id', '')
                    
                    if not file_id:
                        continue
                    
                    # Oddiy file_id - to'g'ridan-to'g'ri yuborish
                    try:
                        file_type_from_db = file_dict.get('file_type', '')
                        
                        if file_type == 'book':
                            # Audio fayllar uchun send_audio, qolganlari uchun send_document
                            if file_type_from_db == 'audio':
                                await safe_send_audio(
                                    bot, auto_send_target_user_id,
                                    audio=file_id,
                                    caption=f"ðŸŽµ {title}"
                                )
                            else:
                                await safe_send_document(
                                    bot, auto_send_target_user_id,
                                    document=file_id,
                                    caption=f"ðŸ“š {title}"
                                )
                        elif file_type == 'movie':
                            await safe_send_video(
                                bot, auto_send_target_user_id,
                                video=file_id,
                                caption=f"ðŸŽ¬ {title}"
                            )
                        
                        # Yuborilgan faylni bazaga saqlash
                        async with db.connect() as conn2:
                            await conn2.execute('''
                                INSERT OR IGNORE INTO sent_files (file_id, item_id, item_type, title, sent_at)
                                VALUES (?, ?, ?, ?, datetime('now'))
                            ''', (file_id, item_id, file_type, title))
                            await conn2.commit()
                        
                        logger.info(f"âœ… {file_type} yuborildi: {title} (ID: {item_id})")
                        await asyncio.sleep(2)  # 2 soniya kutish
                    except Exception as e:
                        logger.error(f"Fayl yuborishda xatolik: {e}")
                        await asyncio.sleep(1)
                
                except Exception as e:
                    logger.error(f"Fayl yuborishda xatolik: {e}")
                    await asyncio.sleep(1)
            
            # Barcha fayllar yuborilgandan keyin, 5 soniya kutish
            await asyncio.sleep(5)
        
        except Exception as e:
            logger.error(f"Avtomatik yuborish xatosi: {e}")
            await asyncio.sleep(10)
    
    logger.info("â¸ï¸ Avtomatik yuborish to'xtatildi!")

# =============================================================================
#                         ADMIN PANEL HANDLERS
# =============================================================================
# Admin panel boshqaruvi - statistika, kontent, foydalanuvchilar.
# To'lovlarni tasdiqlash, broadcast, export va boshqalar.
# =============================================================================

# =============================================================================
#                    ADMIN PANEL - MAIN HANDLERS
# =============================================================================
# Admin panel asosiy handlerlari - menu, statistika, kontent boshqaruvi.
# Foydalanuvchilar, to'lovlar, broadcast va export funksiyalari.
# =============================================================================

@router.message(F.text.in_(["âš™ï¸ Admin Panel", "Admin Panel", "Admin panel"]))
async def handle_admin_panel(message: Message, state: FSMContext):
    """Admin panel"""
    user_id = message.from_user.id
    
    # State'ni tozalash (qidiruv state'i bo'lsa)
    await state.clear()
    
    if not await check_is_admin(user_id, db):
        await message.answer("âŒ Siz admin emassiz!")
        return
    
    # Kutilayotgan to'lovlar sonini olish
    pending_payments = await db.get_pending_payments()
    pending_count = len(pending_payments)
    
    # Badge bilan xabar
    if pending_count > 0:
        text = f"ðŸ‘‘ <b>ADMIN PANEL</b>\n\nðŸ”” <b>Kutilayotgan to'lovlar: {pending_count} ta</b>\n\nQuyidagilardan birini tanlang:"
    else:
        text = "ðŸ‘‘ <b>ADMIN PANEL</b>\n\nQuyidagilardan birini tanlang:"
    
    await message.answer(text, reply_markup=Keyboards.admin_menu(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "admin_menu")
async def handle_admin_menu_callback(callback: CallbackQuery):
    """Admin panel menyusi"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    try:
        # Kutilayotgan to'lovlar sonini olish
        pending_payments = await db.get_pending_payments()
        pending_count = len(pending_payments)
        
        # Badge bilan xabar
        if pending_count > 0:
            text = f"ðŸ‘‘ <b>ADMIN PANEL</b>\n\nðŸ”” <b>Kutilayotgan to'lovlar: {pending_count} ta</b>\n\nQuyidagilardan birini tanlang:"
        else:
            text = "ðŸ‘‘ <b>ADMIN PANEL</b>\n\nQuyidagilardan birini tanlang:"
        
        await safe_edit_text(callback, text, reply_markup=Keyboards.admin_menu())
    except Exception as e:
        logger.error(f"Admin menu edit xatosi: {e}")
        await callback.answer("Xabar o'zgarmadi", show_alert=False)
    await callback.answer()

@router.callback_query(F.data == "admin_stats")
async def handle_admin_stats(callback: CallbackQuery):
    """Admin statistikasi"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    stats = await db.get_system_stats()
    
    stats_text = f"""
ðŸ“Š <b>ADMIN STATISTIKASI</b>

ðŸ‘¥ <b>Foydalanuvchilar:</b>
  ðŸ“Š Jami: {stats.get('total_users', 0)}
  ðŸ‘‘ Premium: {stats.get('premium_users', 0)}
  ðŸ†• Bugungi yangi: {stats.get('new_users_today', 0)}

ðŸ“š <b>Kontent:</b>
  ðŸ“š Kitoblar: {stats.get('total_books', 0)}
  ðŸŽ¬ Filmlar: {stats.get('total_movies', 0)}
  ðŸŽ“ Kurslar: {stats.get('total_courses', 0)}

ðŸ“ˆ <b>Faollik:</b>
  ðŸ“Š DAU: {stats.get('dau', 0)}
  ðŸ“ˆ MAU: {stats.get('mau', 0)}
  ðŸ“Š Faollik: {stats.get('dau_percentage', 0):.1f}%

ðŸ’° <b>Moliyaviy:</b>
  ðŸ’° Jami tushum: {stats.get('total_revenue', 0):,} so'm
  ðŸ“¥ Kitob yuklash: {stats.get('book_downloads', 0)}
  ðŸŽ¬ Film ko'rish: {stats.get('movie_views', 0)}

â° <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“ˆ Real-time stats", callback_data="admin_realtime_stats")
    builder.button(text="ðŸ‘‘ Premium foydalanuvchilar", callback_data="admin_premium_users")
    builder.button(text="ðŸ”„ Yangilash", callback_data="admin_stats")
    builder.button(text="ðŸ‘¥ Foydalanuvchilar", callback_data="admin_users")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(2, 2, 1)
    
    await safe_edit_text(callback, stats_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "admin_users")
async def handle_admin_users(callback: CallbackQuery):
    """Admin: Foydalanuvchilar boshqaruvi"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ‘¥ <b>FOYDALANUVCHILARNI BOSHQARISH</b>\n\n"
        "Foydalanuvchilarni qidirish, tahrirlash va boshqarish:\n\n"
        "ðŸ” Qidirish - Foydalanuvchi ID, ism yoki username bo'yicha\n"
        "ðŸ“Š Statistika - Foydalanuvchi faolligi va harakatlari\n"
        "ðŸŽ XP berish - Foydalanuvchiga XP qo'shish\n"
        "ðŸ‘‘ Premium berish - Premium obuna berish\n"
        "â›” Bloklash - Foydalanuvchini bloklash\n"
        "âœ… Blokdan chiqarish - Blokni olib tashlash\n"
        "ðŸ“ Xabar yuborish - Shaxsiy xabar yuborish\n\n"
        "ðŸ‘‡ Quyidagilardan birini tanlang:",
        reply_markup=Keyboards.admin_users_menu()
    )
    await callback.answer()

# =============================================================================
#                    ADMIN PANEL - BOOKS MANAGEMENT
# =============================================================================
# Kitoblarni boshqarish - qo'shish, tahrirlash, o'chirish, qidirish.
# =============================================================================

@router.callback_query(F.data == "admin_books")
async def handle_admin_books(callback: CallbackQuery):
    """Admin: Kitoblar boshqaruvi"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ“š <b>KITOBNI BOSHQARISH</b>\n\n"
        "Kitoblarni qo'shish, tahrirlash va o'chirish:\n\n"
        "ðŸ“š Qo'shish - Yangi kitob qo'shish\n"
        "ðŸ” Qidirish - Kitob kod, nom yoki muallif bo'yicha\n"
        "ðŸ“Š Statistika - Kitob yuklashlari va reytingi\n"
        "âœï¸ Tahrirlash - Kitob ma'lumotlarini o'zgartirish\n"
        "ðŸ—‘ï¸ O'chirish - Kitobni o'chirish\n\n"
        "ðŸ‘‡ Quyidagilardan birini tanlang:",
        reply_markup=Keyboards.admin_content_menu("books")
    )
    await callback.answer()

# =============================================================================
#                    ADMIN PANEL - MOVIES MANAGEMENT
# =============================================================================
# Filmlarni boshqarish - qo'shish, tahrirlash, o'chirish, qidirish.
# =============================================================================

@router.callback_query(F.data == "admin_movies")
async def handle_admin_movies(callback: CallbackQuery):
    """Admin: Filmlar boshqaruvi"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>FILMLARNI BOSHQARISH</b>\n\n"
        "Filmlarni qo'shish, tahrirlash va o'chirish:\n\n"
        "ðŸŽ¬ Qo'shish - Yangi film qo'shish\n"
        "ðŸ” Qidirish - Film nom, rejissor yoki yil bo'yicha\n"
        "ðŸ“Š Statistika - Film ko'rishlar va reytingi\n"
        "âœï¸ Tahrirlash - Film ma'lumotlarini o'zgartirish\n"
        "ðŸ—‘ï¸ O'chirish - Filmini o'chirish\n\n"
        "ðŸ‘‡ Quyidagilardan birini tanlang:",
        reply_markup=Keyboards.admin_content_menu("movies")
    )
    await callback.answer()

# =============================================================================
#                    ADMIN PANEL - COURSES MANAGEMENT
# =============================================================================
# Kurslarni boshqarish - qo'shish, tahrirlash, o'chirish, narx o'zgartirish.
# =============================================================================

@router.callback_query(F.data == "admin_courses")
async def handle_admin_courses(callback: CallbackQuery):
    """Admin: Kurslar boshqaruvi"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ“ <b>KURSLARNI BOSHQARISH</b>\n\n"
        "Kurslarni qo'shish, tahrirlash va o'chirish:\n\n"
        "ðŸŽ“ Qo'shish - Yangi kurs qo'shish\n"
        "ðŸ” Qidirish - Kurs nom, kategoriya yoki narx bo'yicha\n"
        "ðŸ“Š Statistika - Kurs sotuvlari va reytingi\n"
        "âœï¸ Tahrirlash - Kurs ma'lumotlarini o'zgartirish\n"
        "ðŸ—‘ï¸ O'chirish - Kursni o'chirish\n\n"
        "ðŸ‘‡ Quyidagilardan birini tanlang:",
        reply_markup=Keyboards.admin_content_menu("courses")
    )
    await callback.answer()

# =============================================================================
#                    ADMIN PANEL - PODCASTS MANAGEMENT
# =============================================================================
# Podcastlarni boshqarish - qo'shish, tahrirlash, approve/reject, premium.
# =============================================================================

@router.callback_query(F.data == "admin_podcasts")
async def handle_admin_podcasts(callback: CallbackQuery):
    """Admin: Podcastlar boshqaruvi"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    # Podcastlar ro'yxatini olish
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT id, title, category, language, content_type, downloads, status, created_date
            FROM podcasts
            ORDER BY created_date DESC
            LIMIT 50
        ''')
        podcasts = await cursor.fetchall()
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸŽ™ï¸ <b>PODCASTLARNI BOSHQARISH</b>\n\n"
            "âŒ Hozircha podcastlar mavjud emas.\n\n"
            "ðŸ’¡ Podcast qo'shish uchun 'ðŸŽ™ï¸ Podcast qo'shish' tugmasini bosing.",
            reply_markup=Keyboards.admin_content_menu("podcasts")
        )
        await callback.answer()
        return
    
    text = "ðŸŽ™ï¸ <b>PODCASTLARNI BOSHQARISH</b>\n\n"
    text += f"ðŸ“Š Jami: {len(podcasts)} ta podcast\n\n"
    
    # Til bo'yicha guruhlash
    podcasts_by_lang = {}
    motivational_count = 0
    
    for podcast in podcasts:
        lang = dict(podcast).get('language', 'uz')
        category = dict(podcast).get('category', '')
        
        if lang not in podcasts_by_lang:
            podcasts_by_lang[lang] = 0
        podcasts_by_lang[lang] += 1
        
        if 'Motivatsion' in category or 'Motivational' in category:
            motivational_count += 1
    
    text += "ðŸ“Š <b>Statistika:</b>\n"
    for lang, count in podcasts_by_lang.items():
        lang_name = "ðŸ‡ºðŸ‡¿ O'zbek" if lang == 'uz' else "ðŸ‡¬ðŸ‡§ English"
        text += f"   {lang_name}: {count} ta\n"
    text += f"   ðŸ’ª Motivatsion: {motivational_count} ta\n\n"
    
    text += "ðŸ‘‡ Quyidagilardan birini tanlang:"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ™ï¸ Podcast qo'shish", callback_data="admin_add_podcast")
    builder.button(text="ðŸ“‚ Bo'limlar boshqaruvi", callback_data="admin_podcast_sections")
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek podcastlar", callback_data="admin_podcasts_uz")
    builder.button(text="ðŸ‡¬ðŸ‡§ English podcasts", callback_data="admin_podcasts_en")
    builder.button(text="ðŸ’ª Motivatsion podcastlar", callback_data="admin_podcasts_motivational")
    builder.button(text="ðŸ” Qidirish", callback_data="admin_search_podcasts")
    builder.button(text="ðŸ“Š Statistika", callback_data="admin_podcasts_stats")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 2, 1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_podcasts_uz")
async def handle_admin_podcasts_uz(callback: CallbackQuery):
    """Admin: O'zbek podcastlar"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcasts = await db.get_random_podcasts(limit=50, language="uz")
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸ‡ºðŸ‡¿ <b>O'ZBEK PODCASTLAR</b>\n\n"
            "âŒ Hozircha o'zbek podcastlar mavjud emas.",
            reply_markup=Keyboards.back_button("admin_podcasts")
        )
        await callback.answer()
        return
    
    text = f"ðŸ‡ºðŸ‡¿ <b>O'ZBEK PODCASTLAR</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:20], 1):
        title = dict(podcast).get('title', 'Nomsiz')[:40]
        text += f"{i}. {title}\n"
        builder.button(text=f"ðŸŽ™ï¸ {title[:30]}", callback_data=f"admin_edit_podcast_{dict(podcast).get('id')}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="admin_podcasts")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_podcasts_en")
async def handle_admin_podcasts_en(callback: CallbackQuery):
    """Admin: English podcasts"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcasts = await db.get_random_podcasts(limit=50, language="en")
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸ‡¬ðŸ‡§ <b>ENGLISH PODCASTS</b>\n\n"
            "âŒ No English podcasts available yet.",
            reply_markup=Keyboards.back_button("admin_podcasts")
        )
        await callback.answer()
        return
    
    text = f"ðŸ‡¬ðŸ‡§ <b>ENGLISH PODCASTS</b>\n\n"
    text += f"ðŸ“Š Found: {len(podcasts)} podcasts\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:20], 1):
        title = dict(podcast).get('title', 'Untitled')[:40]
        text += f"{i}. {title}\n"
        builder.button(text=f"ðŸŽ™ï¸ {title[:30]}", callback_data=f"admin_edit_podcast_{dict(podcast).get('id')}")
    
    builder.button(text="ðŸ”™ Podcasts", callback_data="admin_podcasts")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_podcasts_motivational")
async def handle_admin_podcasts_motivational(callback: CallbackQuery):
    """Admin: Motivatsion podcastlar"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcasts = await db.get_motivational_podcasts(limit=50)
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸ’ª <b>MOTIVATSION PODCASTLAR</b>\n\n"
            "âŒ Hozircha motivatsion podcastlar mavjud emas.",
            reply_markup=Keyboards.back_button("admin_podcasts")
        )
        await callback.answer()
        return
    
    text = f"ðŸ’ª <b>MOTIVATSION PODCASTLAR</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:20], 1):
        title = dict(podcast).get('title', 'Nomsiz')[:40]
        text += f"{i}. {title}\n"
        builder.button(text=f"ðŸ’ª {title[:30]}", callback_data=f"admin_edit_podcast_{dict(podcast).get('id')}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="admin_podcasts")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_podcasts_stats")
async def handle_admin_podcasts_stats(callback: CallbackQuery):
    """Admin: Podcastlar statistikasi"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        # Umumiy statistika
        cursor = await conn.execute('SELECT COUNT(*) as total FROM podcasts')
        total = dict(await cursor.fetchone()).get('total', 0)
        
        cursor = await conn.execute('SELECT COUNT(*) as total FROM podcasts WHERE language = "uz"')
        uz_count = dict(await cursor.fetchone()).get('total', 0)
        
        cursor = await conn.execute('SELECT COUNT(*) as total FROM podcasts WHERE language = "en"')
        en_count = dict(await cursor.fetchone()).get('total', 0)
        
        cursor = await conn.execute('''
            SELECT COUNT(*) as total FROM podcasts 
            WHERE category LIKE '%Motivatsion%' OR category LIKE '%Motivational%'
        ''')
        motivational = dict(await cursor.fetchone()).get('total', 0)
        
        cursor = await conn.execute('SELECT SUM(downloads) as total FROM podcasts')
        total_downloads = dict(await cursor.fetchone()).get('total', 0) or 0
        
        cursor = await conn.execute('SELECT COUNT(*) as total FROM podcasts WHERE content_type = "video"')
        video_count = dict(await cursor.fetchone()).get('total', 0)
        
        cursor = await conn.execute('SELECT COUNT(*) as total FROM podcasts WHERE content_type = "audio"')
        audio_count = dict(await cursor.fetchone()).get('total', 0)
    
    text = f"""ðŸ“Š <b>PODCASTLAR STATISTIKASI</b>

ðŸ“ˆ <b>Umumiy:</b>
   â€¢ Jami podcastlar: {total} ta
   â€¢ Jami yuklashlar: {total_downloads:,} ta

ðŸŒ <b>Til bo'yicha:</b>
   â€¢ ðŸ‡ºðŸ‡¿ O'zbek: {uz_count} ta
   â€¢ ðŸ‡¬ðŸ‡§ English: {en_count} ta

ðŸ’ª <b>Kategoriya:</b>
   â€¢ Motivatsion: {motivational} ta

ðŸ“¹ <b>Format:</b>
   â€¢ ðŸŽ§ Audio: {audio_count} ta
   â€¢ ðŸŽ¬ Video: {video_count} ta"""
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Podcastlar", callback_data="admin_podcasts")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_search_podcasts")
async def handle_admin_search_podcasts(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcastlar qidirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "<b>PODCASTLAR QIDIRISH</b>\n\n"
        "Podcast nomi, kategoriyasi yoki host nomini yozing:\n\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_podcast_search)
    await callback.answer()

@router.message(AdminStates.waiting_podcast_search)
async def handle_podcast_search_query(message: Message, state: FSMContext):
    """Admin: Podcast qidirish natijalari"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    search_query = message.text.strip()
    if search_query == "/cancel":
        await state.clear()
        await message.answer("âŒ Qidirish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT id, title, category, language, content_type, downloads
            FROM podcasts
            WHERE (title LIKE ? OR category LIKE ? OR host LIKE ?)
            AND is_active = 1
            ORDER BY downloads DESC
            LIMIT 20
        ''', (f'%{search_query}%', f'%{search_query}%', f'%{search_query}%'))
        podcasts = await cursor.fetchall()
    
    if not podcasts:
        await message.answer(
            f"âŒ '{search_query}' bo'yicha podcast topilmadi.",
            reply_markup=Keyboards.back_button("admin_podcasts")
        )
        await state.clear()
        return
    
    text = f"<b>QIDIRUV NATIJALARI</b>\n\n"
    text += f"<b>Topilgan:</b> {len(podcasts)} ta podcast\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:15], 1):
        title = dict(podcast).get('title', 'Nomsiz')[:40]
        text += f"{i}. {title}\n"
        builder.button(text=f"{title[:30]}", callback_data=f"admin_edit_podcast_{dict(podcast).get('id')}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="admin_podcasts")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await state.clear()

@router.callback_query(F.data.regexp(r"^admin_edit_podcast_\d+$"))
async def handle_admin_edit_podcast(callback: CallbackQuery):
    """Admin: Podcastni ko'rish va boshqarish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_edit_podcast_", ""))
    
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT * FROM podcasts WHERE id = ?', (podcast_id,))
            podcast = await cursor.fetchone()
        except Exception as e:
            logger.error(f"Podcast olish xatosi: {e}")
            await callback.answer("Podcast topilmadi!", show_alert=True)
            return
    
    if not podcast:
        await callback.answer("âŒ Podcast topilmadi!")
        return
    
    podcast_dict = dict(podcast)
    title = podcast_dict.get('title', 'Noma\'lum')
    description = podcast_dict.get('description', 'Tavsif yo\'q')
    category = podcast_dict.get('category', 'Boshqa')
    host = podcast_dict.get('host', 'Noma\'lum')
    language = podcast_dict.get('language', 'uz')
    content_type = podcast_dict.get('content_type', 'audio')
    downloads = podcast_dict.get('downloads', 0)
    rating = podcast_dict.get('rating', 0.0)
    rating_count = podcast_dict.get('rating_count', 0)
    is_premium = podcast_dict.get('is_premium', 0)
    file_id = podcast_dict.get('file_id')
    video_file_id = podcast_dict.get('video_file_id')
    
    text = f"<b>PODCAST MA'LUMOTLARI</b>\n\n"
    text += f"<b>ID:</b> {podcast_id}\n"
    text += f"<b>Nomi:</b> {title}\n"
    text += f"<b>Tavsif:</b> {description[:200]}{'...' if len(description) > 200 else ''}\n"
    text += f"<b>Host:</b> {host}\n"
    text += f"<b>Kategoriya:</b> {category}\n"
    text += f"<b>Til:</b> {'O\'zbek' if language == 'uz' else 'English'}\n"
    text += f"<b>Format:</b> {content_type}\n"
    text += f"<b>Premium:</b> {'Ha' if is_premium else 'Yo\'q'}\n"
    text += f"<b>Yuklashlar:</b> {downloads}\n"
    text += f"<b>Reyting:</b> {rating:.1f}/5.0 ({rating_count} ta baholash)\n"
    
    builder = InlineKeyboardBuilder()
    
    # Podcastni ko'rish (foydalanuvchi ko'rinishida)
    builder.button(text="ðŸ‘ï¸ Ko'rish", callback_data=f"view_podcast_{podcast_id}")
    
    # Ma'lumotlarni o'zgartirish
    builder.button(text="âœï¸ Tahrirlash", callback_data=f"admin_edit_podcast_data_{podcast_id}")
    
    # Premium statusni o'zgartirish
    premium_text = "âŒ Premiumdan olib tashlash" if is_premium else "âœ… Premium qilish"
    builder.button(text=premium_text, callback_data=f"admin_toggle_podcast_premium_{podcast_id}")
    
    # Statusni o'zgartirish
    status = podcast_dict.get('status', 'approved')
    if status == 'pending':
        builder.button(text="âœ… Tasdiqlash", callback_data=f"admin_approve_podcast_{podcast_id}")
        builder.button(text="âŒ Rad etish", callback_data=f"admin_reject_podcast_{podcast_id}")
    
    # O'chirish
    builder.button(text="ðŸ—‘ï¸ O'chirish", callback_data=f"admin_delete_podcast_{podcast_id}")
    
    # Orqaga
    builder.button(text="ðŸ”™ Podcastlar", callback_data="admin_podcasts")
    builder.adjust(1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_podcast_data_"))
async def handle_admin_edit_podcast_data(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast ma'lumotlarini tahrirlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_edit_podcast_data_", ""))
    
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT * FROM podcasts WHERE id = ?', (podcast_id,))
            podcast = await cursor.fetchone()
        except Exception as e:
            logger.error(f"Podcast olish xatosi: {e}")
            await callback.answer("Podcast topilmadi!", show_alert=True)
            return
    
    if not podcast:
        await callback.answer("âŒ Podcast topilmadi!")
        return
    
    await state.update_data(podcast_id=podcast_id)
    await safe_edit_text(callback,
        "<b>PODCAST MA'LUMOTLARINI TAHRIRLASH</b>\n\n"
        "Qaysi ma'lumotni o'zgartirmoqchisiz?\n\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“ Nomi", callback_data=f"admin_edit_podcast_title_{podcast_id}")
    builder.button(text="ðŸ“„ Tavsif", callback_data=f"admin_edit_podcast_desc_{podcast_id}")
    builder.button(text="ðŸ“‚ Kategoriya", callback_data=f"admin_edit_podcast_cat_{podcast_id}")
    builder.button(text="ðŸŒ Til", callback_data=f"admin_edit_podcast_lang_{podcast_id}")
    builder.button(text="ðŸ”™ Orqaga", callback_data=f"admin_edit_podcast_{podcast_id}")
    builder.adjust(1, 1, 1, 1, 1)
    
    await callback.message.edit_reply_markup(reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_podcast_title_"))
async def handle_admin_edit_podcast_title(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast nomini tahrirlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_edit_podcast_title_", ""))
    await state.update_data(podcast_id=podcast_id, edit_field="title")
    await state.set_state(AdminStates.editing_podcast_title)
    
    await safe_edit_text(callback,
        "<b>PODCAST NOMINI O'ZGARTIRISH</b>\n\n"
        "Yangi nomni yozing:\n\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_podcast_desc_"))
async def handle_admin_edit_podcast_desc(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast tavsifini tahrirlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_edit_podcast_desc_", ""))
    await state.update_data(podcast_id=podcast_id, edit_field="description")
    await state.set_state(AdminStates.editing_podcast_description)
    
    await safe_edit_text(callback,
        "<b>PODCAST TAVSIFINI O'ZGARTIRISH</b>\n\n"
        "Yangi tavsifni yozing:\n\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_podcast_cat_"))
async def handle_admin_edit_podcast_cat(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast kategoriyasini tahrirlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_edit_podcast_cat_", ""))
    await state.update_data(podcast_id=podcast_id, edit_field="category")
    await state.set_state(AdminStates.editing_podcast_category)
    
    await safe_edit_text(callback,
        "<b>PODCAST KATEGORIYASINI O'ZGARTIRISH</b>\n\n"
        "Yangi kategoriyani yozing:\n\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_podcast_lang_"))
async def handle_admin_edit_podcast_lang(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast tilini tahrirlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_edit_podcast_lang_", ""))
    await state.update_data(podcast_id=podcast_id)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data=f"admin_set_podcast_lang_{podcast_id}_uz")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data=f"admin_set_podcast_lang_{podcast_id}_en")
    builder.button(text="ðŸ”™ Orqaga", callback_data=f"admin_edit_podcast_{podcast_id}")
    builder.adjust(1, 1, 1)
    
    await safe_edit_text(callback,
        "<b>PODCAST TILINI O'ZGARTIRISH</b>\n\n"
        "Tilni tanlang:",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_set_podcast_lang_"))
async def handle_admin_set_podcast_lang(callback: CallbackQuery):
    """Admin: Podcast tilini o'rnatish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    parts = callback.data.replace("admin_set_podcast_lang_", "").split("_")
    podcast_id = int(parts[0])
    language = parts[1]
    
    async with db.connect() as conn:
        try:
            # language ustunini tekshirish
            cursor = await conn.execute('PRAGMA table_info(podcasts)')
            pod_columns = await cursor.fetchall()
            pod_column_names = [col[1] for col in pod_columns] if pod_columns else []
            
            if 'language' in pod_column_names:
                await conn.execute('UPDATE podcasts SET language = ? WHERE id = ?', (language, podcast_id))
                await conn.commit()
            else:
                await callback.answer("Podcasts jadvalida language ustuni yo'q!", show_alert=True)
                return
        except Exception as e:
            logger.error(f"Podcast language o'zgartirish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
    
    await callback.answer(f"âœ… Til {'O\'zbek' if language == 'uz' else 'English'} ga o'zgartirildi!")
    await handle_admin_edit_podcast(callback)

@router.message(AdminStates.editing_podcast_title)
async def handle_admin_podcast_title_edit(message: Message, state: FSMContext):
    """Admin: Podcast nomini yangilash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    podcast_id = data.get('podcast_id')
    edit_field = data.get('edit_field')
    
    if not podcast_id or edit_field != 'title':
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Tahrirlash bekor qilindi.")
        return
    
    new_title = message.text.strip()
    
    async with db.connect() as conn:
        try:
            await conn.execute('UPDATE podcasts SET title = ? WHERE id = ?', (new_title, podcast_id))
            await conn.commit()
        except Exception as e:
            logger.error(f"Podcast title o'zgartirish xatosi: {e}")
            await message.answer("Xatolik yuz berdi!")
            await state.clear()
            return
    
    await message.answer(f"âœ… Podcast nomi '{new_title}' ga o'zgartirildi!")
    await state.clear()
    
    # Podcast ma'lumotlarini ko'rsatish
    text = f"<b>PODCAST MA'LUMOTLARI</b>\n\n"
    text += f"<b>ID:</b> {podcast_id}\n"
    text += f"<b>Nomi:</b> {new_title}\n"
    text += f"âœ… Podcast nomi yangilandi!\n\n"
    text += "Podcast ma'lumotlarini ko'rish uchun admin panelda 'Podcastlar' bo'limiga o'ting."
    
    builder = InlineKeyboardBuilder()
    builder.button(text="Podcastlar", callback_data="admin_podcasts")
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(AdminStates.editing_podcast_description)
async def handle_admin_podcast_desc_edit(message: Message, state: FSMContext):
    """Admin: Podcast tavsifini yangilash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    podcast_id = data.get('podcast_id')
    edit_field = data.get('edit_field')
    
    if not podcast_id or edit_field != 'description':
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Tahrirlash bekor qilindi.")
        return
    
    new_description = message.text.strip()
    
    async with db.connect() as conn:
        try:
            await conn.execute('UPDATE podcasts SET description = ? WHERE id = ?', (new_description, podcast_id))
            await conn.commit()
        except Exception as e:
            logger.error(f"Podcast description o'zgartirish xatosi: {e}")
            await message.answer("Xatolik yuz berdi!")
            await state.clear()
            return
    
    await message.answer(f"âœ… Podcast tavsifi yangilandi!")
    await state.clear()
    
    # Podcast ma'lumotlarini ko'rsatish
    text = f"<b>PODCAST MA'LUMOTLARI</b>\n\n"
    text += f"<b>ID:</b> {podcast_id}\n"
    text += f"âœ… Podcast tavsifi yangilandi!\n\n"
    text += "Podcast ma'lumotlarini ko'rish uchun admin panelda 'Podcastlar' bo'limiga o'ting."
    
    builder = InlineKeyboardBuilder()
    builder.button(text="Podcastlar", callback_data="admin_podcasts")
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(AdminStates.editing_podcast_category)
async def handle_admin_podcast_cat_edit(message: Message, state: FSMContext):
    """Admin: Podcast kategoriyasini yangilash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    podcast_id = data.get('podcast_id')
    edit_field = data.get('edit_field')
    
    if not podcast_id or edit_field != 'category':
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Tahrirlash bekor qilindi.")
        return
    
    new_category = message.text.strip()
    
    async with db.connect() as conn:
        try:
            await conn.execute('UPDATE podcasts SET category = ? WHERE id = ?', (new_category, podcast_id))
            await conn.commit()
        except Exception as e:
            logger.error(f"Podcast category o'zgartirish xatosi: {e}")
            await message.answer("Xatolik yuz berdi!")
            await state.clear()
            return
    
    await message.answer(f"âœ… Podcast kategoriyasi '{new_category}' ga o'zgartirildi!")
    await state.clear()
    
    # Podcast ma'lumotlarini ko'rsatish
    text = f"<b>PODCAST MA'LUMOTLARI</b>\n\n"
    text += f"<b>ID:</b> {podcast_id}\n"
    text += f"<b>Kategoriya:</b> {new_category}\n"
    text += f"âœ… Podcast kategoriyasi yangilandi!\n\n"
    text += "Podcast ma'lumotlarini ko'rish uchun admin panelda 'Podcastlar' bo'limiga o'ting."
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Podcastlar", callback_data="admin_podcasts")
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data.startswith("admin_toggle_podcast_premium_"))
async def handle_admin_toggle_podcast_premium(callback: CallbackQuery):
    """Admin: Podcast premium statusini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_toggle_podcast_premium_", ""))
    
    async with db.connect() as conn:
        try:
            # is_premium ustunini tekshirish
            cursor = await conn.execute('PRAGMA table_info(podcasts)')
            pod_columns = await cursor.fetchall()
            pod_column_names = [col[1] for col in pod_columns] if pod_columns else []
            
            if 'is_premium' not in pod_column_names:
                await callback.answer("Podcasts jadvalida is_premium ustuni yo'q!", show_alert=True)
                return
            
            cursor = await conn.execute('SELECT is_premium FROM podcasts WHERE id = ?', (podcast_id,))
            result = await cursor.fetchone()
            if result:
                current_premium = result[0] or 0
                new_premium = 1 if current_premium == 0 else 0
                await conn.execute('UPDATE podcasts SET is_premium = ? WHERE id = ?', (new_premium, podcast_id))
                await conn.commit()
            else:
                await callback.answer("Podcast topilmadi!", show_alert=True)
                return
        except Exception as e:
            logger.error(f"Podcast premium o'zgartirish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return

    status_text = "Premium" if new_premium else "Oddiy"
    await callback.answer(f"âœ… Podcast {status_text} ga o'zgartirildi!")
    await handle_admin_edit_podcast(callback)

@router.callback_query(F.data.startswith("admin_approve_podcast_"))
async def handle_admin_approve_podcast(callback: CallbackQuery):
    """Admin: Podcastni tasdiqlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_approve_podcast_", ""))
    
    async with db.connect() as conn:
        try:
            # status ustunini tekshirish
            cursor = await conn.execute('PRAGMA table_info(podcasts)')
            pod_columns = await cursor.fetchall()
            pod_column_names = [col[1] for col in pod_columns] if pod_columns else []
            
            if 'status' not in pod_column_names:
                await callback.answer("Podcasts jadvalida status ustuni yo'q!", show_alert=True)
                return
            
            await conn.execute('UPDATE podcasts SET status = ? WHERE id = ?', ('approved', podcast_id))
            await conn.commit()
        except Exception as e:
            logger.error(f"Podcast tasdiqlash xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
    
    await callback.answer("âœ… Podcast tasdiqlandi!")
    
    # Podcast ma'lumotlarini ko'rsatish
    text = f"<b>PODCAST MA'LUMOTLARI</b>\n\n"
    text += f"<b>ID:</b> {podcast_id}\n"
    text += f"âœ… Podcast tasdiqlandi!\n\n"
    text += "Podcast ma'lumotlarini ko'rish uchun admin panelda 'Podcastlar' bo'limiga o'ting."
    
    builder = InlineKeyboardBuilder()
    builder.button(text="Podcastlar", callback_data="admin_podcasts")
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.startswith("admin_reject_podcast_"))
async def handle_admin_reject_podcast(callback: CallbackQuery):
    """Admin: Podcastni rad etish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_reject_podcast_", ""))
    
    async with db.connect() as conn:
        try:
            # status va is_active ustunlarini tekshirish
            cursor = await conn.execute('PRAGMA table_info(podcasts)')
            pod_columns = await cursor.fetchall()
            pod_column_names = [col[1] for col in pod_columns] if pod_columns else []
            
            if 'status' not in pod_column_names or 'is_active' not in pod_column_names:
                await callback.answer("Podcasts jadvalida kerakli ustunlar yo'q!", show_alert=True)
                return
            
            await conn.execute('UPDATE podcasts SET status = ?, is_active = 0 WHERE id = ?', ('rejected', podcast_id))
            await conn.commit()
        except Exception as e:
            logger.error(f"Podcast rad etish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
    
    await callback.answer("âŒ Podcast rad etildi va o'chirildi!")
    await handle_admin_podcasts(callback)

@router.callback_query(F.data.startswith("admin_delete_podcast_"))
async def handle_admin_delete_podcast(callback: CallbackQuery):
    """Admin: Podcastni o'chirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    podcast_id = int(callback.data.replace("admin_delete_podcast_", ""))
    
    async with db.connect() as conn:
        try:
            # is_active ustunini tekshirish
            cursor = await conn.execute('PRAGMA table_info(podcasts)')
            pod_columns = await cursor.fetchall()
            pod_column_names = [col[1] for col in pod_columns] if pod_columns else []
            
            if 'is_active' not in pod_column_names:
                await callback.answer("Podcasts jadvalida is_active ustuni yo'q!", show_alert=True)
                return
            
            await conn.execute('UPDATE podcasts SET is_active = 0 WHERE id = ?', (podcast_id,))
            await conn.commit()
        except Exception as e:
            logger.error(f"Podcast o'chirish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
    
    await callback.answer("âœ… Podcast o'chirildi!")
    await handle_admin_podcasts(callback)

@router.callback_query(F.data == "admin_pending")
async def handle_admin_pending(callback: CallbackQuery):
    """Admin: Kutilayotgan yuklamalar"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    pending_uploads = await db.get_pending_uploads(limit=20)
    
    if not pending_uploads:
        await safe_edit_text(callback,
            "â³ <b>KUTILAYOTGAN YUKLAMALAR</b>\n\n"
            "Hozircha kutilayotgan yuklamalar yo'q.",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        await callback.answer()
        return
    
    text = f"â³ <b>KUTILAYOTGAN YUKLAMALAR</b>\n\n"
    text += f"ðŸ“Š Jami: {len(pending_uploads)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, upload in enumerate(pending_uploads[:10], 1):
        item_type = upload.get('item_type', 'unknown')
        item_name = upload.get('item_name', 'Nomsiz')
        uploader_id = upload.get('uploader_id', 0)
        upload_id = upload.get('id', 0)
        
        text += f"{i}. <b>{item_name}</b>\n"
        text += f"   ðŸ“‚ Turi: {item_type}\n"
        text += f"   ðŸ‘¤ Yuklovchi: {uploader_id}\n\n"
        
        builder.button(text=f"âœ… {i}", callback_data=f"approve_upload_{upload_id}")
        builder.button(text=f"âŒ {i}", callback_data=f"reject_upload_{upload_id}")
    
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(2, 2, 2, 2, 2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("approve_upload_"))
async def handle_approve_upload(callback: CallbackQuery):
    """Admin: Yuklamani tasdiqlash"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    upload_id = int(callback.data.replace("approve_upload_", ""))
    
    # Pending upload ma'lumotlarini olish
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT * FROM pending_uploads WHERE id = ?', (upload_id,))
            row = await cursor.fetchone()
            if not row:
                await callback.answer("Yuklama topilmadi!", show_alert=True)
                return
        except Exception as e:
            logger.error(f"Pending upload olish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
        
        upload = dict(row)
        item_type = upload.get('item_type')
        item_data = json.loads(upload.get('item_data', '{}'))
        uploader_id = upload.get('uploader_id')
        
        # Item ni bazaga qo'shish
        if item_type == "book":
            book_code = item_data.get('book_code', f"BOOK{int(time.time())}{random.randint(1000, 9999)}")
            file_id = item_data.get('file_id')
            caption = item_data.get('caption', 'Kitob')
            author = item_data.get('author', '')
            genre = item_data.get('genre', 'Boshqa')
            
            await db.add_book(book_code, file_id, caption, author, genre)
        
        elif item_type == "movie":
            file_id = item_data.get('file_id')
            caption = item_data.get('caption', 'Kino')
            genre = item_data.get('genre', 'Boshqa')
            
            await db.add_movie(file_id, caption, genre)
        
        elif item_type == "course":
            title = item_data.get('title', 'Kurs')
            description = item_data.get('description', '')
            file_id = item_data.get('file_id')
            category = item_data.get('category', 'Boshqa')
            price = item_data.get('price', 19990)
            
            course_id = await db.add_course(title, description, "", file_id, category, price=price)
            if not course_id:
                logger.error(f"Kurs qo'shishda xatolik: {title}")
        
        # Status ni yangilash
        await db.update_pending_upload_status(upload_id, "approved", user_id)
    
    await callback.answer("âœ… Yuklama tasdiqlandi!", show_alert=True)
    
    # Foydalanuvchiga xabar
    try:
        await bot.send_message(
            uploader_id,
            f"âœ… <b>Yuklama tasdiqlandi!</b>\n\n"
            f"Sizning yuklagan {item_type}ingiz admin tomonidan tasdiqlandi va endi barcha foydalanuvchilar uchun mavjud!",
            parse_mode=ParseMode.HTML
        )
    except Exception:
        pass
    
    # Admin panelga qaytish
    await handle_admin_pending(callback)

@router.callback_query(F.data.startswith("reject_upload_"))
async def handle_reject_upload(callback: CallbackQuery):
    """Admin: Yuklamani rad etish"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    upload_id = int(callback.data.replace("reject_upload_", ""))
    
    # Status ni yangilash
    await db.update_pending_upload_status(upload_id, "rejected", user_id)
    
    # Foydalanuvchiga xabar
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT uploader_id, item_type FROM pending_uploads WHERE id = ?', (upload_id,))
            row = await cursor.fetchone()
            if row:
                uploader_id = row[0]
                item_type = row[1]
                
                try:
                    await bot.send_message(
                        uploader_id,
                        f"Yuklama rad etildi\n\n"
                        f"Sizning yuklagan {item_type}ingiz admin tomonidan rad etildi.\n"
                        f"Qayta urinib ko'ring yoki boshqa kontent yuklang.",
                        parse_mode=ParseMode.HTML
                    )
                except Exception as e:
                    logger.error(f"Foydalanuvchiga xabar yuborish xatosi: {e}")
                    pass
        except Exception as e:
            logger.error(f"Pending upload ma'lumotlarini olish xatosi: {e}")
    
    await callback.answer("âŒ Yuklama rad etildi!", show_alert=True)
    await handle_admin_pending(callback)

@router.callback_query(F.data == "admin_update_all_course_prices")
async def handle_admin_update_all_course_prices(callback: CallbackQuery):
    """Admin: Barcha kurslar narxini 19990 ga yangilash"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.answer("â³ Kurslar narxi yangilanmoqda...")
    
    try:
        updated_count = await db.update_all_course_prices(19990)
        
        await safe_edit_text(callback,
            f"âœ… <b>KURSLAR NARXI YANGILANDI!</b>\n\n"
            f"ðŸ’° Yangi narx: 19,990 so'm\n"
            f"ðŸ“Š Yangilangan kurslar: {updated_count} ta\n\n"
            f"Barcha faol kurslar narxi 19,990 so'm ga o'rnatildi.",
            reply_markup=Keyboards.admin_content_menu("courses")
        )
    except Exception as e:
        logger.error(f"Kurslar narxini yangilashda xatolik: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

# Placeholder handlers for other admin functions
@router.callback_query(F.data == "admin_realtime_stats")
async def handle_admin_realtime_stats(callback: CallbackQuery):
    """Admin: Real-time stats (TO'LIQ FUNKSIYA)"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    stats = await db.get_system_stats()
    
    # Premium foydalanuvchilar statistikasi
    async with db.connect() as conn:
        try:
            # Premium foydalanuvchilar bo'yicha statistikalar
            cursor = await conn.execute('''
                SELECT 
                    subscription_type,
                    COUNT(*) as count,
                    COUNT(CASE WHEN subscription_end > datetime('now') THEN 1 END) as active_count
                FROM users 
                WHERE subscription_type > 0
                GROUP BY subscription_type
            ''')
            premium_stats = await cursor.fetchall()
            
            # Premium foydalanuvchilar ro'yxati
            cursor = await conn.execute('''
                SELECT user_id, full_name, username, subscription_type, subscription_end, xp
                FROM users 
                WHERE subscription_type > 0 AND subscription_end > datetime('now')
                ORDER BY subscription_end DESC
                LIMIT 20
            ''')
            premium_users = await cursor.fetchall()
        except Exception as e:
            logger.error(f"Premium stats error: {e}")
            premium_stats = []
            premium_users = []
    
    stats_text = f"""
ðŸ“Š <b>REAL-TIME STATISTIKA</b>

ðŸ‘¥ <b>Foydalanuvchilar:</b>
  ðŸ“Š Jami: {stats.get('total_users', 0):,}
  ðŸ‘‘ Premium: {stats.get('premium_users', 0):,}
  ðŸ†• Bugungi yangi: {stats.get('new_users_today', 0):,}

ðŸ“š <b>Kontent:</b>
  ðŸ“š Kitoblar: {stats.get('total_books', 0):,}
  ðŸŽ¬ Filmlar: {stats.get('total_movies', 0):,}
  ðŸŽ“ Kurslar: {stats.get('total_courses', 0):,}

ðŸ“ˆ <b>Faollik:</b>
  ðŸ“Š DAU: {stats.get('dau', 0):,}
  ðŸ“ˆ MAU: {stats.get('mau', 0):,}
  ðŸ“Š Faollik: {stats.get('dau_percentage', 0):.1f}%

ðŸ’° <b>Moliyaviy:</b>
  ðŸ’° Jami tushum: {stats.get('total_revenue', 0):,} so'm
  ðŸ“¥ Kitob yuklash (bugun): {stats.get('book_downloads', 0):,}
  ðŸŽ¬ Film ko'rish (bugun): {stats.get('movie_views', 0):,}

ðŸ‘‘ <b>PREMIUM FOYDALANUVCHILAR STATISTIKASI:</b>
"""
    
    if premium_stats:
        for row in premium_stats:
            sub_type = row[0]
            count = row[1]
            active = row[2] if len(row) > 2 else count
            sub_name = DatabaseManager.get_subscription_name(sub_type)
            stats_text += f"  {sub_name}: {active}/{count} (faol/jami)\n"
    else:
        stats_text += "  Hozircha ma'lumotlar yo'q.\n"
    
    stats_text += f"\nâ° <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‘‘ Premium foydalanuvchilar", callback_data="admin_premium_users")
    builder.button(text="ðŸ”„ Yangilash", callback_data="admin_realtime_stats")
    builder.button(text="ðŸ“Š Asosiy statistika", callback_data="admin_stats")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 2)
    
    await callback.message.edit_text(stats_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "admin_premium_users")
async def handle_admin_premium_users(callback: CallbackQuery):
    """Admin: Premium foydalanuvchilar ro'yxati (TO'LIQ FUNKSIYA)"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        try:
            # Premium foydalanuvchilar ro'yxati
            cursor = await conn.execute('''
                SELECT user_id, full_name, username, subscription_type, subscription_end, xp, joined_date
                FROM users 
                WHERE subscription_type > 0 AND subscription_end > datetime('now')
                ORDER BY subscription_end DESC
                LIMIT 50
            ''')
            premium_users = await cursor.fetchall()
            
            # Umumiy statistika
            cursor = await conn.execute('''
                SELECT 
                    COUNT(*) as total_premium,
                    COUNT(CASE WHEN subscription_end > datetime('now') THEN 1 END) as active_premium,
                    SUM(CASE WHEN subscription_type = 2 THEN 1 ELSE 0 END) as exclusive_count,
                    SUM(CASE WHEN subscription_type = 5 THEN 1 ELSE 0 END) as premium_count
                FROM users 
                WHERE subscription_type > 0
            ''')
            total_stats = await cursor.fetchone()
        except Exception as e:
            logger.error(f"Premium users stats error: {e}")
            premium_users = []
            total_stats = None
    
    stats_text = f"""
ðŸ‘‘ <b>PREMIUM FOYDALANUVCHILAR</b>

ðŸ“Š <b>Umumiy statistika:</b>
  ðŸ‘‘ Jami Premium: {total_stats[0] if total_stats else 0}
  âœ… Faol Premium: {total_stats[1] if total_stats else 0}
  ðŸ† Exclusive: {total_stats[2] if total_stats else 0}
  ðŸ’Ž Premium: {total_stats[3] if total_stats else 0}

ðŸ“‹ <b>Faol Premium foydalanuvchilar (top 50):</b>
"""
    
    if premium_users:
        for i, user in enumerate(premium_users[:20], 1):
            sub_type = user[3]
            sub_name = DatabaseManager.get_subscription_name(sub_type)
            sub_end = user[4]
            user_name = user[1] or f"User {user[0]}"
            username = f"@{user[2]}" if user[2] else "N/A"
            
            # Qolgan vaqtni hisoblash
            try:
                if 'T' in str(sub_end):
                    end_date = datetime.fromisoformat(str(sub_end).replace('Z', '').split('.')[0])
                elif ' ' in str(sub_end):
                    end_date = datetime.strptime(str(sub_end), '%Y-%m-%d %H:%M:%S')
                else:
                    end_date = datetime.strptime(str(sub_end), '%Y-%m-%d')
                
                remaining = end_date - datetime.now()
                remaining_days = remaining.days
                remaining_hours = remaining.seconds // 3600
                
                if remaining_days > 0:
                    remaining_str = f"{remaining_days} kun {remaining_hours} soat"
                else:
                    remaining_str = f"{remaining_hours} soat"
            except Exception:
                remaining_str = "N/A"
            
            stats_text += f"\n{i}. <b>{user_name}</b> ({username})\n"
            stats_text += f"   ðŸ‘‘ {sub_name}\n"
            stats_text += f"   ðŸ“… Qolgan: {remaining_str}\n"
            stats_text += f"   ðŸ’° XP: {user[5]:,}\n"
    else:
        stats_text += "\nHozircha faol Premium foydalanuvchilar yo'q.\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”„ Yangilash", callback_data="admin_premium_users")
    builder.button(text="ðŸ“Š Real-time stats", callback_data="admin_realtime_stats")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1)
    
    await callback.message.edit_text(stats_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.message(UserStates.waiting_payment_receipt, F.photo)
async def handle_payment_receipt(message: Message, state: FSMContext):
    """To'lov cheki yuborilganda (TO'LIQ FUNKSIYA)"""
    user_id = message.from_user.id
    data = await state.get_data()
    payment_id = data.get('payment_id')
    
    if not payment_id:
        await message.answer("âŒ Xatolik! Payment ID topilmadi. Qaytadan boshlang.")
        await state.clear()
        return
    
    # Chekni adminga yuborish
    photo = message.photo[-1]  # Eng yuqori sifatli rasm
    payment = await db.get_payment(payment_id)
    
    if not payment:
        await message.answer("âŒ To'lov topilmadi!")
        await state.clear()
        return
    
    # Adminlarga chekni yuborish
    admin_text = f"""
ðŸ’³ <b>YANGI TO'LOV CHEKI</b>

ðŸ‘¤ <b>Foydalanuvchi:</b>
  ID: {user_id}
  Ism: {message.from_user.full_name}
  Username: @{message.from_user.username or 'N/A'}

ðŸ’° <b>To'lov ma'lumotlari:</b>
  Payment ID: <code>{payment_id}</code>
  Summa: {payment.get('amount', 0):,} so'm
  Usul: {payment.get('payment_method', 'N/A')}
  Tavsif: {payment.get('description', 'N/A')}

ðŸ“… <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ðŸ‘‡ <b>To'lovni tekshiring va tasdiqlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âœ… Tasdiqlash", callback_data=f"approve_payment_{payment_id}")
    builder.button(text="âŒ Rad etish", callback_data=f"reject_payment_{payment_id}")
    builder.button(text="ðŸ‘¤ Foydalanuvchi profil", callback_data=f"admin_user_{user_id}")
    builder.adjust(2, 1)
    
    # Barcha adminlarga yuborish
    for admin_id in Config.ADMIN_IDS:
        try:
            await bot.send_photo(
                chat_id=admin_id,
                photo=photo.file_id,
                caption=admin_text,
                reply_markup=builder.as_markup(),
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            logger.error(f"Admin {admin_id} ga chek yuborishda xatolik: {e}")
    
    # Foydalanuvchiga tasdiqlash xabari
    await message.answer(
        "âœ… <b>Chek qabul qilindi!</b>\n\n"
        f"ðŸ“‹ Payment ID: <code>{payment_id}</code>\n\n"
        "â³ Admin to'lovni tekshirgach, Premium obuna faollashtiriladi.\n"
        "ðŸ“¬ Tasdiqlash xabari sizga yuboriladi.",
        parse_mode=ParseMode.HTML
    )
    
    await state.clear()

# =============================================================================
#                    ADMIN PANEL - PAYMENTS MANAGEMENT
# =============================================================================
# To'lovlarni boshqarish - tasdiqlash, rad etish, tarix ko'rish.
# =============================================================================

async def add_quiz_gold(user_id: int, amount: int) -> int:
    """Quiz RPG tizimi uchun oltin qo'shish (quiz_streaks jadvali)"""
    if amount <= 0:
        return 0
    try:
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT gold FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            if row:
                await conn.execute('UPDATE quiz_streaks SET gold = gold + ? WHERE user_id = ?', (amount, user_id))
            else:
                await conn.execute('INSERT INTO quiz_streaks (user_id, gold) VALUES (?, ?)', (user_id, amount))
            await conn.commit()
        return amount
    except Exception as e:
        logger.error(f"Oltin qo'shishda xatolik: {e}")
        return 0

@router.callback_query(F.data == "admin_payments")
async def handle_admin_payments(callback: CallbackQuery):
    """Admin: To'lovlar (TO'LIQ FUNKSIYA)"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    pending_payments = await db.get_pending_payments(limit=20)
    
    if not pending_payments:
        await safe_edit_text(
            callback,
            "ðŸ’³ <b>TO'LOVLAR</b>\n\n"
            "â³ Hozircha kutilayotgan to'lovlar yo'q.",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        await callback.answer()
        return
    
    text = f"ðŸ’³ <b>KUTILAYOTGAN TO'LOVLAR</b>\n\n"
    text += f"ðŸ“Š Jami: {len(pending_payments)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, payment in enumerate(pending_payments[:10], 1):
        user_name = payment.get('full_name', f"User {payment.get('user_id', 'N/A')}")
        text += f"{i}. <b>{user_name}</b>\n"
        text += f"   ðŸ’° {payment.get('amount', 0):,} so'm\n"
        text += f"   ðŸ“‹ {payment.get('description', 'N/A')}\n"
        text += f"   ðŸ†” <code>{payment.get('payment_id', 'N/A')}</code>\n\n"
        
        builder.button(text=f"âœ… {i}", callback_data=f"approve_payment_{payment.get('payment_id')}")
        builder.button(text=f"âŒ {i}", callback_data=f"reject_payment_{payment.get('payment_id')}")
    
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(2, 2, 2, 2, 2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("approve_payment_"))
async def handle_admin_approve_payment(callback: CallbackQuery):
    """Admin: To'lovni tasdiqlash (TO'LIQ FUNKSIYA)"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    payment_id = callback.data.replace("approve_payment_", "")
    payment = await db.get_payment(payment_id)
    
    if not payment:
        await callback.answer("âŒ To'lov topilmadi!", show_alert=True)
        return
    
    if payment.get('status') != 'pending':
        await callback.answer(f"âš ï¸ Bu to'lov allaqachon {payment.get('status')} holatida!", show_alert=True)
        return
    
    # To'lovni tasdiqlash
    success = await db.confirm_payment(payment_id, confirmed_by=user_id)
    
    if not success:
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)
        return
    
    # Supabase status update (if applicable)
    if payment_id.startswith("supa_") and db.supabase:
        try:
            supa_id = payment_id.replace("supa_", "")
            db.supabase.table('payment_requests').update({'status': 'approved'}).eq('id', supa_id).execute()
            logger.info(f"Supabase payment approved: {supa_id}")
        except Exception as e:
            logger.error(f"Supabase update error: {e}")
    
    # Foydalanuvchiga Premium obuna berish
    payment_user_id = payment.get('user_id')
    description = payment.get('description', '')
    
    description_text = description or ''
    description_lower = description_text.lower()
    is_gold_purchase = 'oltin' in description_lower and 'premium' not in description_lower and 'exclusive' not in description_lower
    
    if is_gold_purchase:
        import re
        gold_amount = 0
        gold_match = re.search(r'(\d+)\s*(?:ta)?\s*oltin', description_lower)
        if gold_match:
            try:
                gold_amount = int(gold_match.group(1))
            except ValueError:
                gold_amount = 0
        
        if gold_amount <= 0:
            fallback_match = re.search(r'(\d+)', description_lower)
            if fallback_match:
                try:
                    gold_amount = int(fallback_match.group(1))
                except ValueError:
                    gold_amount = 0
        
        if gold_amount <= 0:
            gold_amount = payment.get('amount', 0) // 10  # Taxminiy konvertatsiya
        
        gold_added = await add_quiz_gold(payment_user_id, gold_amount)
        if gold_added <= 0:
            logger.error(f"Oltin berishda xatolik: gold_amount={gold_amount}, user={payment_user_id}")
            await callback.answer("âŒ Oltin berishda xatolik!", show_alert=True)
            return
        
        try:
            await bot.send_message(
                payment_user_id,
                f"âœ… <b>TO'LOV TASDIQLANDI!</b>\n\n"
                f"ðŸ’° Summa: {payment.get('amount', 0):,} so'm\n"
                f"ðŸ“‹ {description_text}\n\n"
                f"ðŸª™ <b>{gold_added} oltin</b> hisobingizga qo'shildi!",
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            logger.error(f"Foydalanuvchiga oltin haqida xabar yuborishda xatolik: {e}")
        
        await callback.answer("âœ… To'lov tasdiqlandi va oltin berildi!", show_alert=True)
        try:
            await callback.message.answer(
                "âœ… <b>To'lov tasdiqlandi!</b>\n\n"
                "ðŸª™ Oltin foydalanuvchiga qo'shildi.",
                reply_markup=Keyboards.back_button("admin_payments"),
                parse_mode=ParseMode.HTML
            )
        except Exception:
            await handle_admin_payments(callback)
        return
    
    # Premium to'lovlari uchun davom etamiz
    # Description dan kun va subscription type ni ajratish
    days = 30  # Default
    sub_type = 5  # Premium default
    
    if 'pro+' in description_lower or 'pro plus' in description_lower:
        sub_type = 3  # Exclusive Pro+
    elif 'exclusive' in description_lower:
        sub_type = 2  # Exclusive
    elif 'premium' in description_lower:
        sub_type = 5  # Premium
    
    # Kunlarni ajratish
    import re
    days_match = re.search(r'(\d+)\s*kun', description_lower)
    if days_match:
        days = int(days_match.group(1))
    
    # Premium obuna berish (TO'G'RI VAQT HISOBLASH - qolgan vaqtga qo'shish)
    success = await db.activate_premium(payment_user_id, days, sub_type)
    
    if not success:
        await callback.answer("âŒ Premium faollashtirishda xatolik!", show_alert=True)
        return
    
    # BONUS OLTIN BERISH - Premium/Pro+ uchun
    bonus_gold = 0
    if sub_type == 5:  # Premium
        bonus_gold = 500
    elif sub_type == 2:  # Exclusive
        bonus_gold = 1000
    elif sub_type == 3:  # Exclusive Pro+
        bonus_gold = 500  # 1 kunlik uchun kamroq bonus (yoki tavsifda aytilganidek 500)
    
    if bonus_gold > 0:
        added_bonus = await add_quiz_gold(payment_user_id, bonus_gold)
        if added_bonus <= 0:
            logger.error(f"Bonus oltin berishda xatolik: bonus={bonus_gold}, user={payment_user_id}")
    
    # Yangi tugash sanasini olish
    user = await db.get_user(payment_user_id)
    end_date = user.get('subscription_end', 'N/A') if user else 'N/A'
    
    # Foydalanuvchiga xabar
    bonus_text = f"\nðŸª™ <b>Bonus oltin:</b> +{bonus_gold} oltin!" if bonus_gold > 0 else ""
    try:
        await bot.send_message(
            payment_user_id,
            f"âœ… <b>TO'LOV TASDIQLANDI!</b>\n\n"
            f"ðŸ’° Summa: {payment.get('amount', 0):,} so'm\n"
            f"ðŸ“‹ {description_text}\n\n"
            f"ðŸŽ‰ Premium obuna faollashtirildi!\n"
            f"ðŸ“… Tugash sanasi: {end_date}{bonus_text}\n\n"
            f"ðŸ’Ž Endi barcha Premium imkoniyatlardan foydalanishingiz mumkin!",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Foydalanuvchiga xabar yuborishda xatolik: {e}")
    
    await callback.answer("âœ… To'lov tasdiqlandi va Premium obuna faollashtirildi!", show_alert=True)
    
    # Admin panelga qaytish (yangi xabar yuborish - rasm bo'lishi mumkin)
    try:
        await callback.message.answer(
            "âœ… <b>To'lov tasdiqlandi!</b>\n\n"
            "ðŸ“‹ To'lovlar ro'yxatiga qaytish uchun quyidagi tugmani bosing:",
            reply_markup=Keyboards.back_button("admin_payments"),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Admin xabar yuborishda xatolik: {e}")
        # Agar xatolik bo'lsa, callback orqali qaytish
        await handle_admin_payments(callback)

@router.callback_query(F.data.startswith("reject_payment_"))
async def handle_admin_reject_payment(callback: CallbackQuery):
    """Admin: To'lovni rad etish (TO'LIQ FUNKSIYA)"""
    user_id = callback.from_user.id
    
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    payment_id = callback.data.replace("reject_payment_", "")
    payment = await db.get_payment(payment_id)
    
    if not payment:
        await callback.answer("âŒ To'lov topilmadi!", show_alert=True)
        return
    
    if payment.get('status') != 'pending':
        await callback.answer(f"âš ï¸ Bu to'lov allaqachon {payment.get('status')} holatida!", show_alert=True)
        return
    
    # To'lovni rad etish
    success = await db.reject_payment(payment_id, rejected_by=user_id)
    
    if not success:
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)
        return
        
    # Supabase status update (if applicable)
    if payment_id.startswith("supa_") and db.supabase:
        try:
            supa_id = payment_id.replace("supa_", "")
            db.supabase.table('payment_requests').update({'status': 'rejected'}).eq('id', supa_id).execute()
            logger.info(f"Supabase payment rejected: {supa_id}")
        except Exception as e:
            logger.error(f"Supabase update error: {e}")
    
    # Foydalanuvchiga xabar
    payment_user_id = payment.get('user_id')
    try:
        await bot.send_message(
            payment_user_id,
            f"âŒ <b>TO'LOV RAD ETILDI</b>\n\n"
            f"ðŸ’° Summa: {payment.get('amount', 0):,} so'm\n"
            f"ðŸ“‹ {payment.get('description', 'N/A')}\n\n"
            f"âš ï¸ To'lov cheki noto'g'ri yoki to'liq emas.\n"
            f"ðŸ’¡ Iltimos, qaytadan to'lov qiling va to'g'ri chekni yuboring.\n\n"
            f"ðŸ“ž Savollar bo'lsa, support bilan bog'laning: {Config.SUPPORT_USERNAME}",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Foydalanuvchiga xabar yuborishda xatolik: {e}")
    
    await callback.answer("âŒ To'lov rad etildi!", show_alert=True)
    
    # Admin panelga qaytish (yangi xabar yuborish - rasm bo'lishi mumkin)
    try:
        await callback.message.answer(
            "âŒ <b>To'lov rad etildi!</b>\n\n"
            "ðŸ“‹ To'lovlar ro'yxatiga qaytish uchun quyidagi tugmani bosing:",
            reply_markup=Keyboards.back_button("admin_payments"),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Admin xabar yuborishda xatolik: {e}")
        # Agar xatolik bo'lsa, callback orqali qaytish
        await handle_admin_payments(callback)

@router.callback_query(F.data == "admin_promos")
async def handle_admin_promos(callback: CallbackQuery):
    """Admin: Promo kodlar ro'yxati (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT code, discount_percent, discount_amount, max_uses, used_count,
                   expiry_date, is_active, created_date
            FROM promo_codes
            ORDER BY created_date DESC
            LIMIT 50
        ''')
        promos = await cursor.fetchall()
        
        # Statistika
        cursor = await conn.execute('SELECT COUNT(*) FROM promo_codes WHERE is_active = 1')
        active_count = (await cursor.fetchone())[0] or 0
        
        cursor = await conn.execute('SELECT COUNT(*) FROM promo_codes')
        total_count = (await cursor.fetchone())[0] or 0
    
    text = f"ðŸŽ <b>PROMO KODLAR</b>\n\n"
    text += f"ðŸ“Š <b>Jami:</b> {total_count} ta\n"
    text += f"âœ… <b>Faol:</b> {active_count} ta\n\n"
    
    if not promos:
        text += "âŒ Hozircha promo kodlar mavjud emas."
    else:
        text += f"<b>Oxirgi {len(promos)} ta promo kod:</b>\n\n"
        for i, promo in enumerate(promos[:15], 1):
            code = promo[0]
            discount_p = promo[1] or 0
            discount_a = promo[2] or 0
            max_uses = promo[3] or 0
            used_count = promo[4] or 0
            expiry = promo[5] or "Cheksiz"
            is_active = promo[6]
            
            status = "âœ…" if is_active else "âŒ"
            discount_text = f"{discount_p}%" if discount_p > 0 else f"{discount_a:,} so'm"
            
            text += f"{status} <b>{code}</b>\n"
            text += f"   ðŸ’° Chegirma: {discount_text}\n"
            text += f"   ðŸ“Š Ishlatilgan: {used_count}/{max_uses if max_uses > 0 else 'âˆž'}\n"
            if expiry != "Cheksiz":
                text += f"   ðŸ“… Muddati: {expiry}\n"
            text += "\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âž• Yangi promo kod", callback_data="admin_add_promo")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_add_promo")
async def handle_admin_add_promo(callback: CallbackQuery, state: FSMContext):
    """Admin: Promo kod qo'shish (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "âž• <b>YANGI PROMO KOD</b>\n\n"
        "Promo kod nomini yozing (masalan: SUMMER2024):",
        reply_markup=Keyboards.back_button("admin_promos"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_promo_code)
    await callback.answer("âœ… Promo kod qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_promo_code)
async def handle_admin_promo_code(message: Message, state: FSMContext):
    """Admin: Promo kod nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    promo_code = message.text.strip().upper()
    
    # Promo kod mavjudligini tekshirish
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT code FROM promo_codes WHERE code = ?', (promo_code,))
            existing = await cursor.fetchone()
            
            if existing:
                await message.answer(
                    f"Bu promo kod allaqachon mavjud!\n\n"
                    f"Kod: <code>{promo_code}</code>\n\n"
                    f"Boshqa kod kiriting:",
                    reply_markup=Keyboards.back_button("admin_promos"),
                    parse_mode=ParseMode.HTML
                )
                return
        except Exception as e:
            logger.error(f"Promo kod tekshirish xatosi: {e}")
            await message.answer("Xatolik yuz berdi! Qayta urinib ko'ring.")
            return
    
    await state.update_data(promo_code=promo_code)
    await message.answer(
        f"âœ… <b>Promo kod nomi qabul qilindi!</b>\n\n"
        f"ðŸ”‘ <b>Kod:</b> <code>{promo_code}</code>\n\n"
        f"Chegirma foizini kiriting (masalan: 10 yoki 0):",
        reply_markup=Keyboards.back_button("admin_promos"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_promo_discount)

@router.message(AdminStates.waiting_promo_discount)
async def handle_admin_promo_discount(message: Message, state: FSMContext):
    """Admin: Promo kod chegirmasini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        discount_input = message.text.strip()
        
        # Foiz yoki miqdor?
        if '%' in discount_input:
            discount_percent = float(discount_input.replace('%', ''))
            discount_amount = 0
        else:
            discount_percent = 0
            discount_amount = int(discount_input)
        
        if discount_percent < 0 or discount_percent > 100:
            await message.answer(
                "âŒ <b>Noto'g'ri foiz!</b>\n\n"
                "Foiz 0 dan 100 gacha bo'lishi kerak.\n\n"
                "Qayta kiriting:",
                reply_markup=Keyboards.back_button("admin_promos"),
                parse_mode=ParseMode.HTML
            )
            return
        
        if discount_amount < 0:
            await message.answer(
                "âŒ <b>Noto'g'ri miqdor!</b>\n\n"
                "Miqdor 0 dan katta bo'lishi kerak.\n\n"
                "Qayta kiriting:",
                reply_markup=Keyboards.back_button("admin_promos"),
                parse_mode=ParseMode.HTML
            )
            return
        
        await state.update_data(discount_percent=discount_percent, discount_amount=discount_amount)
        
        discount_text = f"{discount_percent}%" if discount_percent > 0 else f"{discount_amount:,} so'm"
        
        await message.answer(
            f"âœ… <b>Chegirma qabul qilindi!</b>\n\n"
            f"ðŸ’° <b>Chegirma:</b> {discount_text}\n\n"
            f"Maksimal ishlatish sonini kiriting (0 = cheksiz):",
            reply_markup=Keyboards.back_button("admin_promos"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_promo_max_uses)
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri format!</b>\n\n"
            "Raqam kiriting (masalan: 10 yoki 10000):",
            reply_markup=Keyboards.back_button("admin_promos"),
            parse_mode=ParseMode.HTML
        )

@router.message(AdminStates.waiting_promo_max_uses)
async def handle_admin_promo_max_uses(message: Message, state: FSMContext):
    """Admin: Promo kod maksimal ishlatish sonini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        max_uses = int(message.text.strip())
        
        if max_uses < 0:
            await message.answer(
                "âŒ <b>Noto'g'ri son!</b>\n\n"
                "Son 0 yoki undan katta bo'lishi kerak.\n\n"
                "Qayta kiriting:",
                reply_markup=Keyboards.back_button("admin_promos"),
                parse_mode=ParseMode.HTML
            )
            return
        
        await state.update_data(max_uses=max_uses)
        
        await message.answer(
            f"âœ… <b>Maksimal ishlatish soni qabul qilindi!</b>\n\n"
            f"ðŸ“Š <b>Maksimal:</b> {max_uses if max_uses > 0 else 'Cheksiz'}\n\n"
            f"Muddati (kun) kiriting (0 = cheksiz, masalan: 30):",
            reply_markup=Keyboards.back_button("admin_promos"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_promo_expiry)
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri son!</b>\n\n"
            "Raqam kiriting:",
            reply_markup=Keyboards.back_button("admin_promos"),
            parse_mode=ParseMode.HTML
        )

@router.message(AdminStates.waiting_promo_expiry)
async def handle_admin_promo_expiry(message: Message, state: FSMContext):
    """Admin: Promo kod muddatini qabul qilish va saqlash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        days = int(message.text.strip())
        
        if days < 0:
            await message.answer(
                "âŒ <b>Noto'g'ri kun!</b>\n\n"
                "Kun 0 yoki undan katta bo'lishi kerak.\n\n"
                "Qayta kiriting:",
                reply_markup=Keyboards.back_button("admin_promos"),
                parse_mode=ParseMode.HTML
            )
            return
        
        data = await state.get_data()
        promo_code = data.get('promo_code')
        discount_percent = data.get('discount_percent', 0)
        discount_amount = data.get('discount_amount', 0)
        max_uses = data.get('max_uses', 0)
        
        # Muddati hisoblash
        if days > 0:
            from datetime import datetime, timedelta
            expiry_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d %H:%M:%S')
        else:
            expiry_date = None
        
        # Bazaga saqlash
        async with db.connect() as conn:
            await conn.execute('''
                INSERT INTO promo_codes (code, discount_percent, discount_amount, max_uses, expiry_date, is_active, created_date)
                VALUES (?, ?, ?, ?, ?, 1, datetime('now'))
            ''', (promo_code, discount_percent, discount_amount, max_uses, expiry_date))
            await conn.commit()
        
        discount_text = f"{discount_percent}%" if discount_percent > 0 else f"{discount_amount:,} so'm"
        expiry_text = expiry_date if expiry_date else "Cheksiz"
        
        await message.answer(
            f"âœ… <b>PROMO KOD QO'SHILDI!</b>\n\n"
            f"ðŸ”‘ <b>Kod:</b> <code>{promo_code}</code>\n"
            f"ðŸ’° <b>Chegirma:</b> {discount_text}\n"
            f"ðŸ“Š <b>Maksimal:</b> {max_uses if max_uses > 0 else 'Cheksiz'}\n"
            f"ðŸ“… <b>Muddati:</b> {expiry_text}",
            reply_markup=Keyboards.back_button("admin_promos"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri kun!</b>\n\n"
            "Raqam kiriting:",
            reply_markup=Keyboards.back_button("admin_promos"),
            parse_mode=ParseMode.HTML
        )

@router.callback_query(F.data == "admin_broadcast")
async def handle_admin_broadcast(callback: CallbackQuery, state: FSMContext):
    """Admin: Broadcast xabar yuborish (matn, rasm, video, audio)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ“¢ <b>BROADCAST XABAR</b>\n\n"
        "ðŸ“ <b>Qo'llab-quvvatlanadigan formatlar:</b>\n"
        "â€¢ ðŸ“ Matn xabar\n"
        "â€¢ ðŸ–¼ï¸ Rasm (photo)\n"
        "â€¢ ðŸŽ¬ Video\n"
        "â€¢ ðŸŽµ Audio\n"
        "â€¢ ðŸ“„ Hujjat (document)\n"
        "â€¢ ðŸŽ¤ Ovoz xabari (voice)\n\n"
        "ðŸ’¡ <b>Maslahat:</b>\n"
        "Xabarni yuboring (matn, rasm, video yoki audio):\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_broadcast_message)
    await callback.answer()

@router.message(AdminStates.waiting_broadcast_message)
async def handle_broadcast_message(message: Message, state: FSMContext):
    """Admin: Broadcast xabar qabul qilish (matn, rasm, video, audio)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Broadcast bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    # Media turini aniqlash
    broadcast_type = "text"
    media_file_id = None
    broadcast_text = message.text or message.caption or ""
    
    if message.photo:
        broadcast_type = "photo"
        media_file_id = message.photo[-1].file_id  # Eng katta rasm
        if not broadcast_text:
            broadcast_text = "ðŸ“¢ Yangilik"
    elif message.video:
        broadcast_type = "video"
        media_file_id = message.video.file_id
        if not broadcast_text:
            broadcast_text = "ðŸ“¢ Yangilik"
    elif message.audio:
        broadcast_type = "audio"
        media_file_id = message.audio.file_id
        if not broadcast_text:
            broadcast_text = "ðŸ“¢ Yangilik"
    elif message.document:
        broadcast_type = "document"
        media_file_id = message.document.file_id
        if not broadcast_text:
            broadcast_text = "ðŸ“¢ Yangilik"
    elif message.voice:
        broadcast_type = "voice"
        media_file_id = message.voice.file_id
        if not broadcast_text:
            broadcast_text = "ðŸ“¢ Yangilik"
    elif message.video_note:
        broadcast_type = "video_note"
        media_file_id = message.video_note.file_id
        broadcast_text = "ðŸ“¢ Yangilik"
    elif not broadcast_text:
        await message.answer("âŒ Xabar matni yoki media bo'lishi kerak!")
        return
    
    # Tasdiqlash
    builder = InlineKeyboardBuilder()
    builder.button(text="âœ… Yuborish", callback_data="broadcast_confirm")
    builder.button(text="âŒ Bekor qilish", callback_data="admin_menu")
    builder.adjust(1)
    
    await state.update_data(
        broadcast_text=broadcast_text,
        broadcast_type=broadcast_type,
        media_file_id=media_file_id
    )
    
    # Foydalanuvchilar sonini olish
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT COUNT(*) FROM users')
            total_users = (await cursor.fetchone())[0] or 0
        except Exception as e:
            logger.error(f"Foydalanuvchilar sonini olish xatosi: {e}")
            total_users = 0
    
    type_icons = {
        "text": "ðŸ“",
        "photo": "ðŸ–¼ï¸",
        "video": "ðŸŽ¬",
        "audio": "ðŸŽµ",
        "document": "ðŸ“„",
        "voice": "ðŸŽ¤",
        "video_note": "ðŸŽ¥"
    }
    
    type_names = {
        "text": "Matn",
        "photo": "Rasm",
        "video": "Video",
        "audio": "Audio",
        "document": "Hujjat",
        "voice": "Ovoz",
        "video_note": "Video xabar"
    }
    
    preview_text = f"""
ðŸ“¢ <b>BROADCAST XABAR</b>

{type_icons.get(broadcast_type, "ðŸ“")} <b>Tur:</b> {type_names.get(broadcast_type, "Matn")}

ðŸ“ <b>Xabar:</b>
{broadcast_text[:500]}{'...' if len(broadcast_text) > 500 else ''}

ðŸ‘¥ <b>Yuboriladigan foydalanuvchilar:</b> {total_users:,}

Xabarni yuborishni tasdiqlaysizmi?
    """
    
    # Media bo'lsa, uni ko'rsatish
    if broadcast_type == "photo" and media_file_id:
        await message.answer_photo(
            photo=media_file_id,
            caption=preview_text,
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
    elif broadcast_type == "video" and media_file_id:
        await message.answer_video(
            video=media_file_id,
            caption=preview_text,
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
    else:
        await message.answer(
            preview_text,
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )

@router.callback_query(F.data == "broadcast_confirm")
async def handle_broadcast_confirm(callback: CallbackQuery, state: FSMContext):
    """Admin: Broadcast xabarni yuborish (matn, rasm, video, audio)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    broadcast_text = data.get('broadcast_text', '')
    broadcast_type = data.get('broadcast_type', 'text')
    media_file_id = data.get('media_file_id')
    
    await safe_edit_text(callback, "ðŸ“¢ <b>Xabar yuborilmoqda...</b>", parse_mode=ParseMode.HTML)
    
    # Barcha foydalanuvchilarga yuborish
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('SELECT user_id FROM users')
            users = await cursor.fetchall()
        except Exception as e:
            logger.error(f"Foydalanuvchilarni olish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
    
    sent_count = 0
    failed_count = 0
    
    caption = f"ðŸ“¢ <b>YANGILIK</b>\n\n{broadcast_text}" if broadcast_text else "ðŸ“¢ <b>YANGILIK</b>"
    
    for user_row in users:
        try:
            target_user_id = user_row[0]
            
            # Media turiga qarab yuborish
            if broadcast_type == "photo" and media_file_id:
                await bot.send_photo(
                    chat_id=target_user_id,
                    photo=media_file_id,
                    caption=caption,
                    parse_mode=ParseMode.HTML
                )
            elif broadcast_type == "video" and media_file_id:
                await bot.send_video(
                    chat_id=target_user_id,
                    video=media_file_id,
                    caption=caption,
                    parse_mode=ParseMode.HTML
                )
            elif broadcast_type == "audio" and media_file_id:
                await bot.send_audio(
                    chat_id=target_user_id,
                    audio=media_file_id,
                    caption=caption,
                    parse_mode=ParseMode.HTML
                )
            elif broadcast_type == "document" and media_file_id:
                await bot.send_document(
                    chat_id=target_user_id,
                    document=media_file_id,
                    caption=caption,
                    parse_mode=ParseMode.HTML
                )
            elif broadcast_type == "voice" and media_file_id:
                await bot.send_voice(
                    chat_id=target_user_id,
                    voice=media_file_id,
                    caption=caption,
                    parse_mode=ParseMode.HTML
                )
            elif broadcast_type == "video_note" and media_file_id:
                await bot.send_video_note(
                    chat_id=target_user_id,
                    video_note=media_file_id
                )
                if broadcast_text:
                    await bot.send_message(
                        chat_id=target_user_id,
                        text=caption,
                        parse_mode=ParseMode.HTML
                    )
            else:
                # Faqat matn
                await bot.send_message(
                    chat_id=target_user_id,
                    text=caption,
                    parse_mode=ParseMode.HTML
                )
            
            sent_count += 1
            await asyncio.sleep(0.05)  # Rate limit uchun
        except Exception as e:
            failed_count += 1
            logger.error(f"Broadcast xatosi {user_row[0]}: {e}")
    
    # Bazaga saqlash
    async with db.connect() as conn:
        await conn.execute('''
            INSERT INTO broadcast_messages (sent_by, message_text, sent_count, failed_count)
            VALUES (?, ?, ?, ?)
        ''', (user_id, f"{broadcast_type}: {broadcast_text}", sent_count, failed_count))
        await conn.commit()
    
    type_names = {
        "text": "Matn",
        "photo": "Rasm",
        "video": "Video",
        "audio": "Audio",
        "document": "Hujjat",
        "voice": "Ovoz",
        "video_note": "Video xabar"
    }
    
    await safe_edit_text(callback,
        f"âœ… <b>BROADCAST YAKUNLANDI!</b>\n\n"
        f"ðŸ“ <b>Tur:</b> {type_names.get(broadcast_type, 'Matn')}\n"
        f"âœ… <b>Yuborildi:</b> {sent_count:,}\n"
        f"âŒ <b>Xatolik:</b> {failed_count:,}\n"
        f"ðŸ“Š <b>Jami:</b> {len(users):,}",
        reply_markup=Keyboards.back_button("admin_menu")
    )
    await state.clear()
    await callback.answer()

@router.callback_query(F.data.startswith("admin_reply_ticket_"))
async def handle_admin_reply_ticket(callback: CallbackQuery, state: FSMContext):
    """Admin: Ticket ga javob berish (tugma orqali)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_user_id = int(callback.data.replace("admin_reply_ticket_", ""))
    
    # Foydalanuvchi ma'lumotlarini olish
    target_user = await db.get_user(target_user_id)
    if not target_user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    await state.update_data(target_user_id=target_user_id, action="ticket_reply")
    
    await safe_edit_text(callback,
        f"ðŸ’¬ <b>TICKET GA JAVOB</b>\n\n"
        f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
        f"ðŸ†” <b>User ID:</b> <code>{target_user_id}</code>\n\n"
        f"ðŸ“ Javob matnini kiriting (multimedia qo'shishingiz mumkin):\n\n"
        f"âŒ Bekor qilish uchun /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    
    await state.set_state(AdminStates.waiting_reply_text)
    await callback.answer()

@router.callback_query(F.data == "admin_tickets")
async def handle_admin_tickets(callback: CallbackQuery):
    """Admin: Barcha ticketlar ro'yxati"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        # Kutilayotgan ticketlar
        cursor = await conn.execute('''
            SELECT t.id, t.user_id, t.category, t.message, t.created_date, u.full_name
            FROM support_tickets t
            LEFT JOIN users u ON t.user_id = u.user_id
            WHERE t.status = 'open'
            ORDER BY t.created_date DESC
            LIMIT 20
        ''')
        open_tickets = await cursor.fetchall()
        
        # Barcha ticketlar statistikasi
        cursor = await conn.execute('''
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN status = 'open' THEN 1 ELSE 0 END) as open_count,
                SUM(CASE WHEN status = 'closed' THEN 1 ELSE 0 END) as closed_count
            FROM support_tickets
        ''')
        stats = await cursor.fetchone()
    
    text = f"ðŸ“‹ <b>SUPPORT TICKETLAR</b>\n\n"
    text += f"ðŸ“Š <b>Statistika:</b>\n"
    text += f"  ðŸ“ Jami: {stats[0] or 0} ta\n"
    text += f"  â³ Kutilayotgan: {stats[1] or 0} ta\n"
    text += f"  âœ… Yopilgan: {stats[2] or 0} ta\n\n"
    
    if open_tickets:
        text += f"â³ <b>KUTILAYOTGAN TICKETLAR ({len(open_tickets)} ta):</b>\n\n"
        for i, ticket in enumerate(open_tickets[:10], 1):
            text += f"{i}. ðŸŽ« <b>#{ticket[0]}</b>\n"
            text += f"   ðŸ‘¤ {ticket[5] or 'Noma\'lum'} (ID: {ticket[1]})\n"
            text += f"   ðŸ“‚ {ticket[2] or 'Noma\'lum'}\n"
            text += f"   ðŸ“ {ticket[3][:50] if ticket[3] else 'Noma\'lum'}...\n"
            text += f"   ðŸ“… {ticket[4][:10] if ticket[4] else 'N/A'}\n\n"
    else:
        text += "âœ… Kutilayotgan ticketlar yo'q.\n"
    
    builder = InlineKeyboardBuilder()
    if open_tickets:
        for ticket in open_tickets[:5]:
            builder.button(text=f"ðŸ’¬ #{ticket[0]}", callback_data=f"admin_reply_ticket_{ticket[1]}")
    builder.button(text="ðŸ”„ Yangilash", callback_data="admin_tickets")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_reply_user")
async def handle_admin_reply_user(callback: CallbackQuery, state: FSMContext):
    """Admin: Foydalanuvchiga javob (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ’¬ <b>FOYDALANUVCHIGA JAVOB</b>\n\n"
        "Javob yuborish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_menu"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_id_for_reply)
    await callback.answer("âœ… Javob yuborish rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_reply)
async def handle_admin_reply_user_id(message: Message, state: FSMContext):
    """Admin: Javob yuborish - foydalanuvchi ID"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        target_user_id = int(message.text.strip())
        target_user = await db.get_user(target_user_id)
        
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_menu"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        await state.update_data(target_user_id=target_user_id)
        await message.answer(
            f"âœ… <b>Foydalanuvchi topildi!</b>\n\n"
            f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}\n\n"
            f"Javob matnini yozing:",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_reply_text)
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.message(AdminStates.waiting_reply_text)
async def handle_admin_reply_text(message: Message, state: FSMContext):
    """Admin: Javob matnini qabul qilish va yuborish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    target_user_id = data.get('target_user_id')
    reply_text = message.text or message.caption or ""
    
    if not reply_text:
        await message.answer(
            "âŒ <b>Javob matni bo'sh!</b>\n\n"
            "Javob matnini yozing:",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
        return
    
    target_user = await db.get_user(target_user_id)
    
    # Javobni yuborish
    try:
        if message.photo:
            await bot.send_photo(
                target_user_id,
                message.photo[-1].file_id,
                caption=f"ðŸ’¬ <b>Admin javobi</b>\n\n{reply_text}",
                parse_mode=ParseMode.HTML
            )
        elif message.video:
            await bot.send_video(
                target_user_id,
                message.video.file_id,
                caption=f"ðŸ’¬ <b>Admin javobi</b>\n\n{reply_text}",
                parse_mode=ParseMode.HTML
            )
        elif message.document:
            await bot.send_document(
                target_user_id,
                message.document.file_id,
                caption=f"ðŸ’¬ <b>Admin javobi</b>\n\n{reply_text}",
                parse_mode=ParseMode.HTML
            )
        else:
            await bot.send_message(
                target_user_id,
                f"ðŸ’¬ <b>Admin javobi</b>\n\n{reply_text}",
                parse_mode=ParseMode.HTML
            )
        
        await message.answer(
            f"âœ… <b>Javob yuborildi!</b>\n\n"
            f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        await message.answer(
            f"âŒ <b>Javob yuborilmadi!</b>\n\n"
            f"Xatolik: {str(e)}",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
    
    await state.clear()

@router.callback_query(F.data == "admin_admins")
async def handle_admin_admins(callback: CallbackQuery):
    """Admin: Adminlar ro'yxati"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT au.*, u.full_name, u.username 
            FROM admin_users au
            LEFT JOIN users u ON au.user_id = u.user_id
            ORDER BY au.added_date DESC
        ''')
        admins = await cursor.fetchall()
    
    # Config'dan adminlar
    config_admins = Config.ADMIN_IDS
    
    text = "ðŸ‘‘ <b>ADMINLAR RO'YXATI</b>\n\n"
    text += f"ðŸ“Š Jami: {len(admins) + len(config_admins)} ta admin\n\n"
    
    builder = InlineKeyboardBuilder()
    
    # Config adminlar
    for admin_id in config_admins[:5]:
        user = await db.get_user(admin_id)
        name = user.get('full_name', 'Noma\'lum') if user else 'Noma\'lum'
        text += f"ðŸ‘‘ {name} (ID: {admin_id}) [Config]\n"
    
    # Database adminlar
    for admin in admins[:10]:
        admin_id = admin[1]
        name = admin[2] or admin[3] or f"ID: {admin_id}"
        text += f"ðŸ‘‘ {name} (ID: {admin_id})\n"
        builder.button(text=f"ðŸ—‘ï¸ {name[:20]}", callback_data=f"admin_remove_{admin_id}")
    
    builder.button(text="âž• Admin qo'shish", callback_data="admin_add_admin")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "admin_add_admin")
async def handle_admin_add_admin(callback: CallbackQuery, state: FSMContext):
    """Admin: Admin qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "âž• <b>ADMIN QO'SHISH</b>\n\n"
        "Yangi admin foydalanuvchi ID ni kiriting:",
        reply_markup=Keyboards.back_button("admin_admins"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_add_admin)
    await callback.answer()

@router.message(AdminStates.waiting_add_admin)
async def handle_add_admin_id(message: Message, state: FSMContext):
    """Admin: Admin ID ni qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        new_admin_id = int(message.text.strip())
        
        # Foydalanuvchi mavjudligini tekshirish
        target_user = await db.get_user(new_admin_id)
        if not target_user:
            await message.answer("âŒ Foydalanuvchi topilmadi! Qayta kiriting:")
            return
        
        # Admin mavjudligini tekshirish
        async with db.connect() as conn:
            try:
                cursor = await conn.execute('SELECT 1 FROM admin_users WHERE user_id = ?', (new_admin_id,))
                if await cursor.fetchone():
                    await message.answer("Bu foydalanuvchi allaqachon admin!")
                    await state.clear()
                    return
                
                # Admin qo'shish
                await conn.execute('''
                    INSERT INTO admin_users (user_id, added_by)
                    VALUES (?, ?)
                ''', (new_admin_id, user_id))
                await conn.commit()
            except Exception as e:
                logger.error(f"Admin qo'shish xatosi: {e}")
                await message.answer("Xatolik yuz berdi! Qayta urinib ko'ring.")
                await state.clear()
                return
        
        await message.answer(
            f"âœ… <b>Admin qo'shildi!</b>\n\n"
            f"ðŸ‘¤ Foydalanuvchi: {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” ID: {new_admin_id}",
            reply_markup=Keyboards.back_button("admin_admins"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except ValueError:
        await message.answer("âŒ Noto'g'ri format! Raqam kiriting.")

@router.callback_query(F.data.regexp(r"^admin_remove_\d+$"))
async def handle_admin_remove(callback: CallbackQuery):
    """Admin: Adminni olib tashlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_admin_id = int(callback.data.replace("admin_remove_", ""))
    
    # O'zini o'chirib bo'lmaydi
    if target_admin_id == user_id:
        await callback.answer("âŒ O'zingizni o'chirib bo'lmaydi!", show_alert=True)
        return
    
    # Config adminlarni o'chirib bo'lmaydi
    if target_admin_id in Config.ADMIN_IDS:
        await callback.answer("âŒ Config adminlarni o'chirib bo'lmaydi!", show_alert=True)
        return
    
    # Eng katta admin (Config.ADMIN_IDS ichidagi birinchi admin) qo'shilgan adminni o'chira olmasligi
    async with db.connect() as conn:
        try:
            # Qaysi admin qo'shganini tekshirish
            cursor = await conn.execute(
                'SELECT added_by FROM admin_users WHERE user_id = ?', 
                (target_admin_id,)
            )
            result = await cursor.fetchone()
            
            if result:
                added_by = result[0]
                # Eng katta admin (Config.ADMIN_IDS ichidagi birinchi admin)
                if Config.ADMIN_IDS and added_by == Config.ADMIN_IDS[0]:
                    await callback.answer(
                        "âŒ Eng katta admin qo'shilgan adminni o'chirib bo'lmaydi!", 
                        show_alert=True
                    )
                    return
        except Exception as e:
            logger.error(f"Admin o'chirish tekshiruvi xatosi: {e}")
    
    async with db.connect() as conn:
        try:
            await conn.execute('DELETE FROM admin_users WHERE user_id = ?', (target_admin_id,))
            await conn.commit()
        except Exception as e:
            logger.error(f"Admin o'chirish xatosi: {e}")
            await callback.answer("Xatolik yuz berdi!", show_alert=True)
            return
    
    await callback.message.edit_text(
        f"âœ… <b>Admin olib tashlandi!</b>\n\n"
        f"ðŸ†” ID: {target_admin_id}",
        reply_markup=Keyboards.back_button("admin_admins"),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "admin_cards")
async def handle_admin_cards(callback: CallbackQuery):
    """Admin: Kartalar"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    text = "<b>TO'LOV KARTALARI</b>\n\n"
    text += f"To'lov kartasi ma'lumotlari:\n\n"
    text += f"ðŸ’³ <b>Karta raqami:</b> {Config.PAYMENT_CARD_NUMBER}\n"
    text += f"ðŸ‘¤ <b>Karta egasi:</b> {Config.PAYMENT_CARD_NAME}\n\n"
    text += "Bu karta ma'lumotlari foydalanuvchilarga to'lov qilish uchun ko'rsatiladi."
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_menu"))
    await callback.answer()

@router.callback_query(F.data == "admin_add_card")
async def handle_admin_add_card(callback: CallbackQuery):
    """Admin: Karta qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    text = "<b>KARTA QO'SHISH</b>\n\n"
    text += "Karta ma'lumotlarini o'zgartirish uchun kod ichidagi Config.PAYMENT_CARD_NUMBER va Config.PAYMENT_CARD_NAME o'zgaruvchilarini yangilang.\n\n"
    text += f"Hozirgi karta: {Config.PAYMENT_CARD_NUMBER}"
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_menu"))
    await callback.answer()

@router.callback_query(F.data == "admin_user_courses")
async def handle_admin_user_courses(callback: CallbackQuery):
    """Admin: Foydalanuvchi kurslari"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM user_courses
            ''')
            total = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT uc.id, uc.user_id, uc.course_id, c.title, uc.purchased_date, uc.status
                FROM user_courses uc
                LEFT JOIN courses c ON uc.course_id = c.id
                ORDER BY uc.purchased_date DESC
                LIMIT 20
            ''')
            user_courses = await cursor.fetchall()
        except Exception as e:
            logger.error(f"Foydalanuvchi kurslarini olish xatosi: {e}")
            user_courses = []
            total = 0
    
    text = f"<b>FOYDALANUVCHI KURSLARI</b>\n\n"
    text += f"ðŸ“Š Jami: {total} ta\n\n"
    
    if user_courses:
        text += "<b>Oxirgi sotib olingan kurslar:</b>\n\n"
        for i, uc in enumerate(user_courses[:15], 1):
            course_title = uc[3] or "Noma'lum"
            user_id_val = uc[1]
            status = uc[5] or "active"
            purchase_date = uc[4] or "N/A"
            text += f"{i}. <b>{course_title}</b>\n"
            text += f"   ðŸ‘¤ Foydalanuvchi ID: {user_id_val}\n"
            text += f"   ðŸ“… Sana: {purchase_date}\n"
            text += f"   âœ… Status: {status}\n\n"
    else:
        text += "Hozircha sotib olingan kurslar yo'q."
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_menu"))
    await callback.answer()

@router.callback_query(F.data == "admin_course_payments")
async def handle_admin_course_payments(callback: CallbackQuery):
    """Admin: Kurs to'lovlari"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('''
                SELECT p.id, p.user_id, p.amount, p.status, p.created_date, p.description
                FROM payments p
                WHERE p.description LIKE '%kurs%' OR p.description LIKE '%course%'
                ORDER BY p.created_date DESC
                LIMIT 30
            ''')
            payments = await cursor.fetchall()
            
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments
                WHERE (description LIKE '%kurs%' OR description LIKE '%course%')
                AND status = 'approved'
            ''')
            total_revenue = (await cursor.fetchone())[0] or 0
        except Exception as e:
            logger.error(f"Kurs to'lovlarini olish xatosi: {e}")
            payments = []
            total_revenue = 0
    
    text = f"<b>KURS TO'LOVLARI</b>\n\n"
    text += f"ðŸ’° Jami daromad: {total_revenue:,} so'm\n\n"
    
    if payments:
        text += "<b>Oxirgi to'lovlar:</b>\n\n"
        for i, payment in enumerate(payments[:15], 1):
            amount = payment[2] or 0
            status = payment[3] or "pending"
            user_id_val = payment[1]
            date = payment[4] or "N/A"
            desc = payment[5] or "Kurs to'lovi"
            
            status_icon = "âœ…" if status == "approved" else "â³" if status == "pending" else "âŒ"
            text += f"{i}. {status_icon} <b>{amount:,} so'm</b>\n"
            text += f"   ðŸ‘¤ Foydalanuvchi ID: {user_id_val}\n"
            text += f"   ðŸ“… Sana: {date}\n"
            text += f"   ðŸ“ {desc}\n\n"
    else:
        text += "Hozircha kurs to'lovlari yo'q."
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_menu"))
    await callback.answer()

@router.callback_query(F.data == "admin_leagues")
async def handle_admin_leagues(callback: CallbackQuery):
    """Admin: Liga boshqaruvi"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    text = "<b>LIGA BOSHQARUVI</b>\n\n"
    text += "XP ligalari tizimi foydalanuvchilarni XP baliga qarab guruhlash uchun ishlatiladi.\n\n"
    text += "Liga ma'lumotlari 'leagues' jadvalida saqlanadi.\n\n"
    text += "Hozircha ligalar tizimi ishlab chiqilmoqda. Ma'lumotlarni Excel export orqali ko'rishingiz mumkin."
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_menu"))
    await callback.answer()

@router.callback_query(F.data == "admin_free_course")
async def handle_admin_free_course(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs bepul qilish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "<b>KURS BEPUL QILISH</b>\n\n"
        "Kurs ID ni yoki nomini kiriting (narx 0 ga o'zgaradi):",
        reply_markup=Keyboards.back_button("admin_menu"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_for_price)
    await callback.answer()

@router.message(AdminStates.waiting_course_for_price)
async def handle_admin_free_course_input(message: Message, state: FSMContext):
    """Admin: Kurs bepul qilish - kurs qidirish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    course_input = message.text.strip()
    
    if course_input == "/cancel":
        await state.clear()
        await message.answer("Bekor qilindi.", reply_markup=Keyboards.back_button("admin_menu"))
        return
    
    # Kursni qidirish (ID yoki nom bo'yicha)
    course = None
    try:
        # ID bo'lsa
        if course_input.isdigit():
            course_id = int(course_input)
            course = await db.get_course(course_id)
        else:
            # Nom bo'yicha qidirish
            async with db.connect() as conn:
                cursor = await conn.execute('''
                    SELECT * FROM courses WHERE title LIKE ? AND is_active = 1 LIMIT 1
                ''', (f'%{course_input}%',))
                row = await cursor.fetchone()
                if row:
                    course = dict(row)
    except Exception as e:
        logger.error(f"Kurs qidirish xatosi: {e}")
    
    if not course:
        await message.answer(
            "Kurs topilmadi! Kurs ID yoki nomini to'g'ri kiriting:",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        return
    
    # Kurs narxini 0 ga o'zgartirish
    try:
        async with db.connect() as conn:
            await conn.execute('UPDATE courses SET price = 0 WHERE id = ?', (course['id'],))
            await conn.commit()
        
        await message.answer(
            f"âœ… Kurs bepul qilindi!\n\n"
            f"ðŸ“š Kurs: {course.get('title', 'Noma\'lum')}\n"
            f"ðŸ’° Yangi narx: 0 so'm",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except Exception as e:
        logger.error(f"Kurs narxini o'zgartirish xatosi: {e}")
        await message.answer("Xatolik yuz berdi! Qayta urinib ko'ring.")
        await state.clear()

@router.callback_query(F.data == "admin_change_course_price")
async def handle_admin_change_course_price(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs narxini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "<b>KURS NARXINI O'ZGARTIRISH</b>\n\n"
        "Kurs ID ni yoki nomini kiriting:",
        reply_markup=Keyboards.back_button("admin_menu"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_for_price_change)
    await callback.answer()

@router.message(AdminStates.waiting_course_for_price_change)
async def handle_admin_course_price_change_input(message: Message, state: FSMContext):
    """Admin: Kurs narxini o'zgartirish - kurs qidirish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    # Bot tugmalari uchun check
    if message.text in ["Admin Panel", "Admin panel", "Kutubxona", "Kinoteatr", "Kurslar", "Podcastlar", "Profil", "Premium", "Yangi funksiyalar", "AI Mentor", "Asosiy menyu", "Gamification", "ðŸŽ® Gamification"]:
        await state.clear()
        return
    
    course_input = message.text.strip()
    
    if course_input == "/cancel":
        await state.clear()
        await message.answer("Bekor qilindi.", reply_markup=Keyboards.back_button("admin_menu"))
        return
    
    # Kursni qidirish (ID yoki nom bo'yicha)
    course = None
    try:
        # ID bo'lsa
        if course_input.isdigit():
            course_id = int(course_input)
            course = await db.get_course(course_id)
        else:
            # Nom bo'yicha qidirish
            async with db.connect() as conn:
                cursor = await conn.execute('''
                    SELECT * FROM courses WHERE title LIKE ? AND is_active = 1 LIMIT 1
                ''', (f'%{course_input}%',))
                row = await cursor.fetchone()
                if row:
                    course = dict(row)
    except Exception as e:
        logger.error(f"Kurs qidirish xatosi: {e}")
    
    if not course:
        await message.answer(
            "Kurs topilmadi! Kurs ID yoki nomini to'g'ri kiriting:\n\n"
            "âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        return
    
    # Kurs ma'lumotlarini saqlash
    await state.update_data(course_id=course.get('id'), course_title=course.get('title', 'Noma\'lum'))
    current_price = course.get('price', 0) or 0
    
    await message.answer(
        f"âœ… <b>Kurs topildi!</b>\n\n"
        f"ðŸ“š <b>Kurs:</b> {course.get('title', 'Noma\'lum')}\n"
        f"ðŸ’° <b>Joriy narx:</b> {current_price:,} so'm\n\n"
        f"ðŸ’µ <b>Yangi narxni kiriting (so'm):</b>\n\n"
        f"âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.back_button("admin_menu"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_new_price)

@router.message(AdminStates.waiting_course_new_price)
async def handle_admin_course_new_price_input(message: Message, state: FSMContext):
    """Admin: Kurs yangi narxini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    # Bot tugmalari uchun check
    if message.text in ["Admin Panel", "Admin panel", "Kutubxona", "Kinoteatr", "Kurslar", "Podcastlar", "Profil", "Premium", "Yangi funksiyalar", "AI Mentor", "Asosiy menyu", "Gamification", "ðŸŽ® Gamification"]:
        await state.clear()
        return
    
    price_input = message.text.strip()
    
    if price_input == "/cancel":
        await state.clear()
        await message.answer("Bekor qilindi.", reply_markup=Keyboards.back_button("admin_menu"))
        return
    
    # Narxni tekshirish
    try:
        # Faqat raqamlar va nuqta/vergul
        price_input_clean = price_input.replace(',', '').replace(' ', '').replace('so\'m', '').replace('soÐ¼', '').strip()
        new_price = int(float(price_input_clean))
        
        if new_price < 0:
            await message.answer(
                "âŒ Narx manfiy bo'lishi mumkin emas!\n\n"
                "ðŸ’µ Yangi narxni kiriting (so'm):\n\n"
                "âŒ Bekor qilish: /cancel",
                reply_markup=Keyboards.back_button("admin_menu")
            )
            return
    except (ValueError, AttributeError):
        await message.answer(
            "âŒ Noto'g'ri format! Faqat raqam kiriting.\n\n"
            "ðŸ’µ Yangi narxni kiriting (so'm):\n\n"
            "âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        return
    
    # Kurs narxini yangilash
    data = await state.get_data()
    course_id = data.get('course_id')
    course_title = data.get('course_title', 'Noma\'lum')
    
    try:
        async with db.connect() as conn:
            await conn.execute('UPDATE courses SET price = ? WHERE id = ?', (new_price, course_id))
            await conn.commit()
        
        await message.answer(
            f"âœ… <b>KURS NARXI YANGILANDI!</b>\n\n"
            f"ðŸ“š <b>Kurs:</b> {course_title}\n"
            f"ðŸ’° <b>Yangi narx:</b> {new_price:,} so'm\n\n"
            f"âœ… Kurs narxi muvaffaqiyatli o'zgartirildi.",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except Exception as e:
        logger.error(f"Kurs narxini o'zgartirish xatosi: {e}")
        await message.answer(
            "âŒ Xatolik yuz berdi! Qayta urinib ko'ring.\n\n"
            "ðŸ’µ Yangi narxni kiriting (so'm):\n\n"
            "âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.back_button("admin_menu")
        )

@router.callback_query(F.data == "admin_export")
async def handle_admin_export(callback: CallbackQuery):
    """Admin: Excel export - barcha ma'lumotlarni ajralib-ajralib (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text("<b>EXCEL EXPORT</b>\n\nMa'lumotlar tayyorlanmoqda. Bu bir necha daqiqa davom etishi mumkin.", parse_mode=ParseMode.HTML)
    
    try:
        # OpenPyXL mavjudligini tekshirish
        if not OPENPYXL_AVAILABLE:
            await callback.message.edit_text(
                "<b>Xatolik</b>\n\n"
                "OpenPyXL paketi o'rnatilmagan.\n"
                "Quyidagi buyruqni bajaring:\n"
                "<code>pip install openpyxl</code>",
                reply_markup=Keyboards.back_button("admin_menu"),
                parse_mode=ParseMode.HTML
            )
            await callback.answer()
            return
        
        import openpyxl
        from openpyxl import Workbook
        from openpyxl.styles import Font, PatternFill, Alignment
        from datetime import datetime
        from io import BytesIO
        
        wb = Workbook()
        
        # ========== FOYDALANUVCHILAR ==========
        ws_users = wb.active
        ws_users.title = "Foydalanuvchilar"
        
        headers_users = ['ID', 'Ism', 'Username', 'Qo\'shilgan sana', 'Status', 'XP', 'Yuklamalar', 'Referallar', 'AI Limit', 'Premium muddati']
        for col, header in enumerate(headers_users, 1):
            cell = ws_users.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT user_id, full_name, username, joined_date, subscription_type, xp, 
                       total_downloads, referral_count, ai_limit, subscription_end
                FROM users
                ORDER BY user_id
            ''')
            users = await cursor.fetchall()
            
            for row_idx, user in enumerate(users, 2):
                ws_users.cell(row=row_idx, column=1, value=user[0])
                ws_users.cell(row=row_idx, column=2, value=user[1] or '')
                ws_users.cell(row=row_idx, column=3, value=user[2] or '')
                ws_users.cell(row=row_idx, column=4, value=user[3] or '')
                ws_users.cell(row=row_idx, column=5, value=DatabaseManager.get_subscription_name(user[4] or 0))
                ws_users.cell(row=row_idx, column=6, value=user[5] or 0)
                ws_users.cell(row=row_idx, column=7, value=user[6] or 0)
                ws_users.cell(row=row_idx, column=8, value=user[7] or 0)
                ws_users.cell(row=row_idx, column=9, value=user[8] or 0)
                ws_users.cell(row=row_idx, column=10, value=user[9] or '')
        
        # ========== KITOBLAR ==========
        ws_books = wb.create_sheet("Kitoblar")
        
        headers_books = ['Kod', 'Nomi', 'Muallif', 'Janr', 'Yuklashlar', 'Reyting', 'Baho soni', 'Premium', 'Status']
        for col, header in enumerate(headers_books, 1):
            cell = ws_books.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="70AD47", end_color="70AD47", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # Books jadvalida mavjud ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(books)')
            books_columns = await cursor.fetchall()
            books_column_names = [col[1] for col in books_columns]
            
            # is_premium ustuni mavjudligini tekshirish
            if 'is_premium' in books_column_names:
                cursor = await conn.execute('''
                    SELECT code, caption, author, genre, downloads, rating, rating_count, is_premium, status
                    FROM books
                    ORDER BY downloads DESC
                ''')
            else:
                # is_premium yo'q bo'lsa, 0 qiymat bilan
                cursor = await conn.execute('''
                    SELECT code, caption, author, genre, 
                           COALESCE(downloads, 0) as downloads,
                           COALESCE(rating, 0) as rating,
                           COALESCE(rating_count, 0) as rating_count,
                           0 as is_premium,
                           COALESCE(status, 'approved') as status
                    FROM books
                    ORDER BY downloads DESC
                ''')
            books = await cursor.fetchall()
            
            for row_idx, book in enumerate(books, 2):
                ws_books.cell(row=row_idx, column=1, value=book[0] or '')
                ws_books.cell(row=row_idx, column=2, value=book[1] or '')
                ws_books.cell(row=row_idx, column=3, value=book[2] or '')
                ws_books.cell(row=row_idx, column=4, value=book[3] or '')
                ws_books.cell(row=row_idx, column=5, value=book[4] or 0)
                ws_books.cell(row=row_idx, column=6, value=book[5] or 0)
                ws_books.cell(row=row_idx, column=7, value=book[6] or 0)
                ws_books.cell(row=row_idx, column=8, value='Ha' if (book[7] if len(book) > 7 else 0) else 'Yo\'q')
                ws_books.cell(row=row_idx, column=9, value=(book[8] if len(book) > 8 else 'approved') or '')
        
        # ========== FILMLAR ==========
        ws_movies = wb.create_sheet("Filmlar")
        
        headers_movies = ['ID', 'Nomi', 'Janr', 'Sifat', 'Ko\'rishlar', 'Reyting', 'Baho soni', 'Premium', 'Status']
        for col, header in enumerate(headers_movies, 1):
            cell = ws_movies.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="C00000", end_color="C00000", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # Movies jadvalida mavjud ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(movies)')
            movies_columns = await cursor.fetchall()
            movies_column_names = [col[1] for col in movies_columns]
            
            # is_premium ustuni mavjudligini tekshirish
            if 'is_premium' in movies_column_names:
                cursor = await conn.execute('''
                    SELECT id, caption, genre, quality, views, rating, rating_count, is_premium, status
                    FROM movies
                    ORDER BY views DESC
                ''')
            else:
                # is_premium yo'q bo'lsa, 0 qiymat bilan
                cursor = await conn.execute('''
                    SELECT id, caption, genre, 
                           COALESCE(quality, '720p') as quality,
                           COALESCE(views, 0) as views,
                           COALESCE(rating, 0) as rating,
                           COALESCE(rating_count, 0) as rating_count,
                           0 as is_premium,
                           COALESCE(status, 'approved') as status
                    FROM movies
                    ORDER BY views DESC
                ''')
            movies = await cursor.fetchall()
            
            for row_idx, movie in enumerate(movies, 2):
                ws_movies.cell(row=row_idx, column=1, value=movie[0] or 0)
                ws_movies.cell(row=row_idx, column=2, value=movie[1] or '')
                ws_movies.cell(row=row_idx, column=3, value=movie[2] or '')
                ws_movies.cell(row=row_idx, column=4, value=movie[3] or '')
                ws_movies.cell(row=row_idx, column=5, value=movie[4] or 0)
                ws_movies.cell(row=row_idx, column=6, value=movie[5] or 0)
                ws_movies.cell(row=row_idx, column=7, value=movie[6] or 0)
                ws_movies.cell(row=row_idx, column=8, value='Ha' if (movie[7] if len(movie) > 7 else 0) else 'Yo\'q')
                ws_movies.cell(row=row_idx, column=9, value=(movie[8] if len(movie) > 8 else 'approved') or '')
        
        # ========== KURSLAR ==========
        ws_courses = wb.create_sheet("Kurslar")
        
        headers_courses = ['ID', 'Nomi', 'Kategoriya', 'Narx', 'Chegirma', 'Talabalar', 'Reyting', 'Baho soni', 'Status']
        for col, header in enumerate(headers_courses, 1):
            cell = ws_courses.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="FFC000", end_color="FFC000", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # Courses jadvalida mavjud ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(courses)')
            courses_columns = await cursor.fetchall()
            courses_column_names = [col[1] for col in courses_columns]
            
            # Barcha kerakli ustunlar mavjudligini tekshirish
            select_fields = ['id', 'title', 'category']
            
            # price ustuni
            if 'price' in courses_column_names:
                select_fields.append('price')
            else:
                select_fields.append('0 as price')
            
            # discount_price ustuni
            if 'discount_price' in courses_column_names:
                select_fields.append('discount_price')
            else:
                select_fields.append('0 as discount_price')
            
            # students_count ustuni
            if 'students_count' in courses_column_names:
                select_fields.append('students_count')
            else:
                select_fields.append('0 as students_count')
            
            # rating ustuni
            if 'rating' in courses_column_names:
                select_fields.append('rating')
            else:
                select_fields.append('0 as rating')
            
            # rating_count ustuni
            if 'rating_count' in courses_column_names:
                select_fields.append('rating_count')
            else:
                select_fields.append('0 as rating_count')
            
            # status ustuni
            if 'status' in courses_column_names:
                select_fields.append('status')
            else:
                select_fields.append('\'approved\' as status')
            
            query = f'''
                SELECT {', '.join(select_fields)}
                FROM courses
                ORDER BY students_count DESC
            '''
            cursor = await conn.execute(query)
            courses = await cursor.fetchall()
            
            for row_idx, course in enumerate(courses, 2):
                ws_courses.cell(row=row_idx, column=1, value=course[0] or 0)
                ws_courses.cell(row=row_idx, column=2, value=course[1] or '')
                ws_courses.cell(row=row_idx, column=3, value=course[2] or '')
                ws_courses.cell(row=row_idx, column=4, value=course[3] if len(course) > 3 else 0)
                ws_courses.cell(row=row_idx, column=5, value=course[4] if len(course) > 4 else 0)
                ws_courses.cell(row=row_idx, column=6, value=course[5] if len(course) > 5 else 0)
                ws_courses.cell(row=row_idx, column=7, value=course[6] if len(course) > 6 else 0)
                ws_courses.cell(row=row_idx, column=8, value=course[7] if len(course) > 7 else 0)
                ws_courses.cell(row=row_idx, column=9, value=course[8] if len(course) > 8 else 'approved')
        
        # ========== TO'LOVLAR ==========
        ws_payments = wb.create_sheet("To'lovlar")
        
        headers_payments = ['ID', 'Foydalanuvchi ID', 'Ism', 'Summa', 'Status', 'Turi', 'Sana', 'Tavsif']
        for col, header in enumerate(headers_payments, 1):
            cell = ws_payments.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="7030A0", end_color="7030A0", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # Payments jadvalida mavjud ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(payments)')
            payments_columns = await cursor.fetchall()
            payments_column_names = [col[1] for col in payments_columns]
            
            # payment_type ustuni mavjudligini tekshirish
            select_fields = ['p.id', 'p.user_id', 'u.full_name', 'p.amount', 'p.status']
            
            if 'payment_type' in payments_column_names:
                select_fields.append('p.payment_type')
            else:
                select_fields.append("'premium' as payment_type")
            
            select_fields.extend(['p.created_date', 'p.description'])
            
            query = f'''
                SELECT {', '.join(select_fields)}
                FROM payments p
                LEFT JOIN users u ON p.user_id = u.user_id
                ORDER BY p.created_date DESC
            '''
            cursor = await conn.execute(query)
            payments = await cursor.fetchall()
            
            for row_idx, payment in enumerate(payments, 2):
                ws_payments.cell(row=row_idx, column=1, value=payment[0] or 0)
                ws_payments.cell(row=row_idx, column=2, value=payment[1] or 0)
                ws_payments.cell(row=row_idx, column=3, value=payment[2] or '')
                ws_payments.cell(row=row_idx, column=4, value=payment[3] or 0)
                ws_payments.cell(row=row_idx, column=5, value=payment[4] or '')
                ws_payments.cell(row=row_idx, column=6, value=payment[5] if len(payment) > 5 else 'premium')
                ws_payments.cell(row=row_idx, column=7, value=payment[6] if len(payment) > 6 else '')
                ws_payments.cell(row=row_idx, column=8, value=payment[7] if len(payment) > 7 else '')
        
        # ========== YUKLASH TARIXI ==========
        ws_downloads = wb.create_sheet("Yuklash tarixi")
        
        headers_downloads = ['ID', 'Foydalanuvchi ID', 'Kontent turi', 'Kontent ID', 'Sana']
        for col, header in enumerate(headers_downloads, 1):
            cell = ws_downloads.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="0070C0", end_color="0070C0", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # download_history jadvalidagi ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(download_history)')
            download_columns = await cursor.fetchall()
            download_column_names = [col[1] for col in download_columns]
            
            # created_date yoki download_date ustunini aniqlash
            if 'created_date' in download_column_names:
                date_column = 'created_date'
            elif 'download_date' in download_column_names:
                date_column = 'download_date'
            else:
                date_column = None
            
            if date_column:
                cursor = await conn.execute(f'''
                    SELECT id, user_id, item_type, item_id, {date_column}
                    FROM download_history
                    ORDER BY {date_column} DESC
                    LIMIT 10000
                ''')
            else:
                cursor = await conn.execute('''
                    SELECT id, user_id, item_type, item_id, NULL
                    FROM download_history
                    LIMIT 10000
                ''')
            downloads = await cursor.fetchall()
            
            for row_idx, download in enumerate(downloads, 2):
                ws_downloads.cell(row=row_idx, column=1, value=download[0] or 0)
                ws_downloads.cell(row=row_idx, column=2, value=download[1] or 0)
                ws_downloads.cell(row=row_idx, column=3, value=download[2] or '')
                ws_downloads.cell(row=row_idx, column=4, value=download[3] or 0)
                ws_downloads.cell(row=row_idx, column=5, value=download[4] or '' if len(download) > 4 else '')
        
        # ========== REFERALLAR ==========
        ws_referrals = wb.create_sheet("Referallar")
        
        headers_referrals = ['ID', 'Referrer ID', 'Referred ID', 'Sana']
        for col, header in enumerate(headers_referrals, 1):
            cell = ws_referrals.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="00B050", end_color="00B050", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # referrals jadvalidagi ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(referrals)')
            referral_columns = await cursor.fetchall()
            referral_column_names = [col[1] for col in referral_columns]
            
            # created_date yoki date ustunini tekshirish
            if 'created_date' in referral_column_names:
                date_col = 'created_date'
            elif 'date' in referral_column_names:
                date_col = 'date'
            else:
                date_col = None
            
            if date_col:
                cursor = await conn.execute(f'''
                    SELECT id, referrer_id, referred_id, {date_col}
                    FROM referrals
                    ORDER BY {date_col} DESC
                ''')
            else:
                cursor = await conn.execute('''
                    SELECT id, referrer_id, referred_id, NULL
                    FROM referrals
                ''')
            referrals = await cursor.fetchall()
            
            for row_idx, referral in enumerate(referrals, 2):
                ws_referrals.cell(row=row_idx, column=1, value=referral[0] or 0)
                ws_referrals.cell(row=row_idx, column=2, value=referral[1] or 0)
                ws_referrals.cell(row=row_idx, column=3, value=referral[2] or 0)
                ws_referrals.cell(row=row_idx, column=4, value=referral[3] or '' if len(referral) > 3 else '')
        
        # ========== PROMO KODLAR ==========
        ws_promos = wb.create_sheet("Promo kodlar")
        
        headers_promos = ['Kod', 'Chegirma %', 'Chegirma so\'m', 'Maksimal', 'Ishlatilgan', 'Muddati', 'Status']
        for col, header in enumerate(headers_promos, 1):
            cell = ws_promos.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # promo_codes jadvalidagi ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(promo_codes)')
            promo_columns = await cursor.fetchall()
            promo_column_names = [col[1] for col in promo_columns]
            
            # expiry_date yoki valid_until ustunini tekshirish
            if 'expiry_date' in promo_column_names:
                expiry_col = 'expiry_date'
            elif 'valid_until' in promo_column_names:
                expiry_col = 'valid_until'
            else:
                expiry_col = None
            
            # created_date ustunini tekshirish
            order_by = ''
            if 'created_date' in promo_column_names:
                order_by = 'ORDER BY created_date DESC'
            
            if expiry_col:
                cursor = await conn.execute(f'''
                    SELECT code, discount_percent, discount_amount, max_uses, used_count, {expiry_col}, is_active
                    FROM promo_codes
                    {order_by}
                ''')
            else:
                cursor = await conn.execute(f'''
                    SELECT code, discount_percent, discount_amount, max_uses, used_count, NULL, is_active
                    FROM promo_codes
                    {order_by}
                ''')
            promos = await cursor.fetchall()
            
            for row_idx, promo in enumerate(promos, 2):
                ws_promos.cell(row=row_idx, column=1, value=promo[0] or '')
                ws_promos.cell(row=row_idx, column=2, value=promo[1] or 0)
                ws_promos.cell(row=row_idx, column=3, value=promo[2] or 0)
                ws_promos.cell(row=row_idx, column=4, value=promo[3] or 0)
                ws_promos.cell(row=row_idx, column=5, value=promo[4] or 0)
                ws_promos.cell(row=row_idx, column=6, value=promo[5] or '')
                ws_promos.cell(row=row_idx, column=7, value='Faol' if promo[6] else 'Nofaol')
        
        # ========== XP TRANSAKTSIYALAR ==========
        ws_xp = wb.create_sheet("XP transaksiyalar")
        
        headers_xp = ['ID', 'Foydalanuvchi ID', 'Summa', 'Turi', 'Tavsif', 'Sana']
        for col, header in enumerate(headers_xp, 1):
            cell = ws_xp.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="FF9900", end_color="FF9900", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # xp_transactions jadvalidagi ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(xp_transactions)')
            xp_columns = await cursor.fetchall()
            xp_column_names = [col[1] for col in xp_columns]
            
            # transaction_type ustunini tekshirish
            if 'transaction_type' in xp_column_names:
                tx_type_col = 'transaction_type'
            else:
                tx_type_col = 'NULL as transaction_type'
            
            # created_date ustunini tekshirish
            if 'created_date' in xp_column_names:
                date_col = 'created_date'
                order_by = 'ORDER BY created_date DESC'
            elif 'date' in xp_column_names:
                date_col = 'date'
                order_by = 'ORDER BY date DESC'
            else:
                date_col = 'NULL as created_date'
                order_by = ''
            
            cursor = await conn.execute(f'''
                SELECT id, user_id, amount, {tx_type_col}, description, {date_col}
                FROM xp_transactions
                {order_by}
                LIMIT 50000
            ''')
            xp_transactions = await cursor.fetchall()
            
            for row_idx, xp_tx in enumerate(xp_transactions, 2):
                ws_xp.cell(row=row_idx, column=1, value=xp_tx[0] or 0)
                ws_xp.cell(row=row_idx, column=2, value=xp_tx[1] or 0)
                ws_xp.cell(row=row_idx, column=3, value=xp_tx[2] or 0)
                ws_xp.cell(row=row_idx, column=4, value=xp_tx[3] or '')
                ws_xp.cell(row=row_idx, column=5, value=xp_tx[4] or '')
                ws_xp.cell(row=row_idx, column=6, value=xp_tx[5] or '')
        
        # ========== FOYDALANUVCHI KURSLARI ==========
        ws_user_courses = wb.create_sheet("Foydalanuvchi kurslari")
        
        headers_user_courses = ['ID', 'Foydalanuvchi ID', 'Kurs ID', 'Kurs nomi', 'Sotib olingan sana', 'Status']
        for col, header in enumerate(headers_user_courses, 1):
            cell = ws_user_courses.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # user_courses jadvalidagi ustunlarni tekshirish
            cursor = await conn.execute('PRAGMA table_info(user_courses)')
            uc_columns = await cursor.fetchall()
            uc_column_names = [col[1] for col in uc_columns]
            
            # purchased_date yoki purchase_date ustunini tekshirish
            if 'purchased_date' in uc_column_names:
                purchase_date_col = 'uc.purchased_date'
            elif 'purchase_date' in uc_column_names:
                purchase_date_col = 'uc.purchase_date'
            else:
                purchase_date_col = 'NULL as purchased_date'
            
            # status ustunini tekshirish
            if 'status' in uc_column_names:
                status_col = 'uc.status'
            else:
                status_col = 'NULL as status'
            
            cursor = await conn.execute(f'''
                SELECT uc.id, uc.user_id, uc.course_id, c.title, {purchase_date_col}, {status_col}
                FROM user_courses uc
                LEFT JOIN courses c ON uc.course_id = c.id
                ORDER BY {purchase_date_col} DESC
            ''')
            user_courses_list = await cursor.fetchall()
            
            for row_idx, uc in enumerate(user_courses_list, 2):
                ws_user_courses.cell(row=row_idx, column=1, value=uc[0] or 0)
                ws_user_courses.cell(row=row_idx, column=2, value=uc[1] or 0)
                ws_user_courses.cell(row=row_idx, column=3, value=uc[2] or 0)
                ws_user_courses.cell(row=row_idx, column=4, value=uc[3] or '')
                ws_user_courses.cell(row=row_idx, column=5, value=uc[4] or '')
                ws_user_courses.cell(row=row_idx, column=6, value=uc[5] or '')
        
        # ========== KITOB REYTINGLARI ==========
        ws_book_ratings = wb.create_sheet("Kitob reytinglari")
        
        headers_book_ratings = ['ID', 'Foydalanuvchi ID', 'Kitob kodi', 'Reyting', 'Sana']
        for col, header in enumerate(headers_book_ratings, 1):
            cell = ws_book_ratings.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="92D050", end_color="92D050", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            # book_ratings jadvalidagi ustunlarni tekshirish
            try:
                cursor = await conn.execute('PRAGMA table_info(book_ratings)')
                br_columns = await cursor.fetchall()
                br_column_names = [col[1] for col in br_columns]
                
                # created_at yoki created_date ustunini tekshirish
                if 'created_at' in br_column_names:
                    date_col = 'created_at'
                elif 'created_date' in br_column_names:
                    date_col = 'created_date'
                else:
                    date_col = 'NULL as created_at'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, book_code, rating, {date_col}
                    FROM book_ratings
                    ORDER BY {date_col} DESC
                ''')
                book_ratings_list = await cursor.fetchall()
            except Exception as e:
                logger.error(f"book_ratings export xatosi: {e}")
                book_ratings_list = []
            
            for row_idx, br in enumerate(book_ratings_list, 2):
                ws_book_ratings.cell(row=row_idx, column=1, value=br[0] or 0)
                ws_book_ratings.cell(row=row_idx, column=2, value=br[1] or 0)
                ws_book_ratings.cell(row=row_idx, column=3, value=br[2] or '')
                ws_book_ratings.cell(row=row_idx, column=4, value=br[3] or 0)
                ws_book_ratings.cell(row=row_idx, column=5, value=br[4] or '')
        
        # ========== SUPPORT TICKETLAR ==========
        ws_support = wb.create_sheet("Support ticketlar")
        
        headers_support = ['ID', 'Foydalanuvchi ID', 'Mavzu', 'Status', 'Yaratilgan sana', 'Yechilgan sana']
        for col, header in enumerate(headers_support, 1):
            cell = ws_support.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="E74C3C", end_color="E74C3C", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            try:
                # support_tickets jadvalidagi ustunlarni tekshirish
                cursor = await conn.execute('PRAGMA table_info(support_tickets)')
                st_columns = await cursor.fetchall()
                st_column_names = [col[1] for col in st_columns] if st_columns else []
                
                # subject yoki message ustunini tekshirish
                if 'subject' in st_column_names:
                    subject_col = 'subject'
                elif 'message' in st_column_names:
                    subject_col = 'message'
                else:
                    subject_col = 'NULL as subject'
                
                # created_date ustunini tekshirish
                date_col = 'created_date' if 'created_date' in st_column_names else 'NULL as created_date'
                
                # resolved_date ustunini tekshirish
                resolved_col = 'resolved_date' if 'resolved_date' in st_column_names else 'NULL as resolved_date'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, {subject_col}, status, {date_col}, {resolved_col}
                    FROM support_tickets
                    ORDER BY {date_col} DESC
                ''')
                support_tickets_list = await cursor.fetchall()
            except Exception as e:
                logger.error(f"support_tickets export xatosi: {e}")
                support_tickets_list = []
            
            for row_idx, st in enumerate(support_tickets_list, 2):
                ws_support.cell(row=row_idx, column=1, value=st[0] or 0)
                ws_support.cell(row=row_idx, column=2, value=st[1] or 0)
                ws_support.cell(row=row_idx, column=3, value=st[2] or '')
                ws_support.cell(row=row_idx, column=4, value=st[3] or '')
                ws_support.cell(row=row_idx, column=5, value=st[4] or '')
                ws_support.cell(row=row_idx, column=6, value=st[5] or '')
        
        # ========== SEVIMLILAR ==========
        ws_favorites = wb.create_sheet("Sevimlilar")
        
        headers_favorites = ['ID', 'Foydalanuvchi ID', 'Kontent turi', 'Kontent ID', 'Sana']
        for col, header in enumerate(headers_favorites, 1):
            cell = ws_favorites.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="9B59B6", end_color="9B59B6", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            try:
                # favorites jadvalidagi ustunlarni tekshirish
                cursor = await conn.execute('PRAGMA table_info(favorites)')
                fav_columns = await cursor.fetchall()
                fav_column_names = [col[1] for col in fav_columns] if fav_columns else []
                
                # created_date ustunini tekshirish
                date_col = 'created_date' if 'created_date' in fav_column_names else 'NULL as created_date'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, item_type, item_id, {date_col}
                    FROM favorites
                    ORDER BY {date_col} DESC
                ''')
                favorites_list = await cursor.fetchall()
            except Exception as e:
                logger.error(f"favorites export xatosi: {e}")
                favorites_list = []
            
            for row_idx, fav in enumerate(favorites_list, 2):
                ws_favorites.cell(row=row_idx, column=1, value=fav[0] or 0)
                ws_favorites.cell(row=row_idx, column=2, value=fav[1] or 0)
                ws_favorites.cell(row=row_idx, column=3, value=fav[2] or '')
                ws_favorites.cell(row=row_idx, column=4, value=fav[3] or 0)
                ws_favorites.cell(row=row_idx, column=5, value=fav[4] or '')
        
        # ========== AI SUHATLAR ==========
        ws_ai_conversations = wb.create_sheet("AI suhbatlar")
        
        headers_ai = ['ID', 'Foydalanuvchi ID', 'Savol', 'Javob', 'Sana']
        for col, header in enumerate(headers_ai, 1):
            cell = ws_ai_conversations.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="3498DB", end_color="3498DB", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            try:
                # ai_conversations jadvalidagi ustunlarni tekshirish
                cursor = await conn.execute('PRAGMA table_info(ai_conversations)')
                ai_columns = await cursor.fetchall()
                ai_column_names = [col[1] for col in ai_columns] if ai_columns else []
                
                # created_date yoki timestamp ustunini tekshirish
                if 'created_date' in ai_column_names:
                    date_col = 'created_date'
                elif 'timestamp' in ai_column_names:
                    date_col = 'timestamp'
                else:
                    date_col = 'NULL as created_date'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, message, response, {date_col}
                    FROM ai_conversations
                    ORDER BY {date_col} DESC
                    LIMIT 10000
                ''')
                ai_conversations_list = await cursor.fetchall()
            except Exception as e:
                logger.error(f"ai_conversations export xatosi: {e}")
                ai_conversations_list = []
            
            for row_idx, ai_conv in enumerate(ai_conversations_list, 2):
                ws_ai_conversations.cell(row=row_idx, column=1, value=ai_conv[0] or 0)
                ws_ai_conversations.cell(row=row_idx, column=2, value=ai_conv[1] or 0)
                ws_ai_conversations.cell(row=row_idx, column=3, value=(ai_conv[2] or '')[:500])  # Matn uzunligini cheklash
                ws_ai_conversations.cell(row=row_idx, column=4, value=(ai_conv[3] or '')[:500])
                ws_ai_conversations.cell(row=row_idx, column=5, value=ai_conv[4] or '')
        
        # ========== FOYDALANUVCHI FAOLIYAT LOGI ==========
        ws_activity = wb.create_sheet("Faoliyat logi")
        
        headers_activity = ['ID', 'Foydalanuvchi ID', 'Harakat turi', 'Tavsif', 'Sana']
        for col, header in enumerate(headers_activity, 1):
            cell = ws_activity.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="1ABC9C", end_color="1ABC9C", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            try:
                # user_activity_log jadvalidagi ustunlarni tekshirish
                cursor = await conn.execute('PRAGMA table_info(user_activity_log)')
                al_columns = await cursor.fetchall()
                al_column_names = [col[1] for col in al_columns] if al_columns else []
                
                # timestamp yoki created_date ustunini tekshirish
                if 'timestamp' in al_column_names:
                    date_col = 'timestamp'
                elif 'created_date' in al_column_names:
                    date_col = 'created_date'
                else:
                    date_col = 'NULL as created_date'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, activity_type, details, {date_col}
                    FROM user_activity_log
                    ORDER BY {date_col} DESC
                    LIMIT 20000
                ''')
                activity_logs = await cursor.fetchall()
            except Exception as e:
                logger.error(f"user_activity_log export xatosi: {e}")
                activity_logs = []
            
            for row_idx, activity in enumerate(activity_logs, 2):
                ws_activity.cell(row=row_idx, column=1, value=activity[0] or 0)
                ws_activity.cell(row=row_idx, column=2, value=activity[1] or 0)
                ws_activity.cell(row=row_idx, column=3, value=activity[2] or '')
                ws_activity.cell(row=row_idx, column=4, value=(activity[3] or '')[:200])
                ws_activity.cell(row=row_idx, column=5, value=activity[4] or '')
        
        # ========== SHARHLAR ==========
        ws_reviews = wb.create_sheet("Sharhlar")
        
        headers_reviews = ['ID', 'Foydalanuvchi ID', 'Kontent turi', 'Kontent ID', 'Reyting', 'Sharh', 'Sana']
        for col, header in enumerate(headers_reviews, 1):
            cell = ws_reviews.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="F39C12", end_color="F39C12", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            try:
                # reviews jadvalidagi ustunlarni tekshirish
                cursor = await conn.execute('PRAGMA table_info(reviews)')
                rev_columns = await cursor.fetchall()
                rev_column_names = [col[1] for col in rev_columns] if rev_columns else []
                
                # created_date ustunini tekshirish
                date_col = 'created_date' if 'created_date' in rev_column_names else 'NULL as created_date'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, item_type, item_id, rating, comment, {date_col}
                    FROM reviews
                    ORDER BY {date_col} DESC
                    LIMIT 5000
                ''')
                reviews_list = await cursor.fetchall()
            except Exception as e:
                logger.error(f"reviews export xatosi: {e}")
                reviews_list = []
            
            for row_idx, review in enumerate(reviews_list, 2):
                ws_reviews.cell(row=row_idx, column=1, value=review[0] or 0)
                ws_reviews.cell(row=row_idx, column=2, value=review[1] or 0)
                ws_reviews.cell(row=row_idx, column=3, value=review[2] or '')
                ws_reviews.cell(row=row_idx, column=4, value=review[3] or 0)
                ws_reviews.cell(row=row_idx, column=5, value=review[4] or 0)
                ws_reviews.cell(row=row_idx, column=6, value=(review[5] or '')[:500])
                ws_reviews.cell(row=row_idx, column=7, value=review[6] or '')
        
        # ========== BONUSLAR ==========
        ws_bonuses = wb.create_sheet("Bonuslar")
        
        headers_bonuses = ['ID', 'Foydalanuvchi ID', 'Summa', 'Turi', 'Tavsif', 'Sana']
        for col, header in enumerate(headers_bonuses, 1):
            cell = ws_bonuses.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="16A085", end_color="16A085", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            try:
                # bonuses jadvalidagi ustunlarni tekshirish
                cursor = await conn.execute('PRAGMA table_info(bonuses)')
                bon_columns = await cursor.fetchall()
                bon_column_names = [col[1] for col in bon_columns] if bon_columns else []
                
                # created_date ustunini tekshirish
                date_col = 'created_date' if 'created_date' in bon_column_names else 'NULL as created_date'
                
                cursor = await conn.execute(f'''
                    SELECT id, user_id, amount, bonus_type, description, {date_col}
                    FROM bonuses
                    ORDER BY {date_col} DESC
                ''')
                bonuses_list = await cursor.fetchall()
            except Exception as e:
                logger.error(f"bonuses export xatosi: {e}")
                bonuses_list = []
            
            for row_idx, bonus in enumerate(bonuses_list, 2):
                ws_bonuses.cell(row=row_idx, column=1, value=bonus[0] or 0)
                ws_bonuses.cell(row=row_idx, column=2, value=bonus[1] or 0)
                ws_bonuses.cell(row=row_idx, column=3, value=bonus[2] or 0)
                ws_bonuses.cell(row=row_idx, column=4, value=bonus[3] or '')
                ws_bonuses.cell(row=row_idx, column=5, value=bonus[4] or '')
                ws_bonuses.cell(row=row_idx, column=6, value=bonus[5] or '')
        
        # ========== ADMINLAR ==========
        ws_admins = wb.create_sheet("Adminlar")
        
        headers_admins = ['ID', 'Foydalanuvchi ID', 'Ism', 'Username', 'Qo\'shgan admin ID', 'Sana']
        for col, header in enumerate(headers_admins, 1):
            cell = ws_admins.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="E67E22", end_color="E67E22", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT au.id, au.user_id, u.full_name, u.username, au.added_by, au.added_date
                FROM admin_users au
                LEFT JOIN users u ON au.user_id = u.user_id
                ORDER BY au.added_date DESC
            ''')
            admins_list = await cursor.fetchall()
            
            for row_idx, admin in enumerate(admins_list, 2):
                ws_admins.cell(row=row_idx, column=1, value=admin[0] or 0)
                ws_admins.cell(row=row_idx, column=2, value=admin[1] or 0)
                ws_admins.cell(row=row_idx, column=3, value=admin[2] or '')
                ws_admins.cell(row=row_idx, column=4, value=admin[3] or '')
                ws_admins.cell(row=row_idx, column=5, value=admin[4] or 0)
                ws_admins.cell(row=row_idx, column=6, value=admin[5] or '')
        
        # ========== STATISTIKA SAHIFASI ==========
        ws_stats = wb.create_sheet("Statistika")
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT COUNT(*) FROM users')
            total_users = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1')
            total_books = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1')
            total_movies = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1')
            total_courses = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT SUM(amount) FROM payments WHERE status = "approved"')
            total_revenue = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM xp_transactions')
            total_xp_transactions = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM user_courses')
            total_user_courses = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM support_tickets')
            total_support_tickets = (await cursor.fetchone())[0] or 0
        
        ws_stats.cell(row=1, column=1, value="Statistika").font = Font(bold=True, size=14)
        ws_stats.cell(row=2, column=1, value="Foydalanuvchilar").font = Font(bold=True)
        ws_stats.cell(row=2, column=2, value=total_users)
        ws_stats.cell(row=3, column=1, value="Kitoblar").font = Font(bold=True)
        ws_stats.cell(row=3, column=2, value=total_books)
        ws_stats.cell(row=4, column=1, value="Filmlar").font = Font(bold=True)
        ws_stats.cell(row=4, column=2, value=total_movies)
        ws_stats.cell(row=5, column=1, value="Kurslar").font = Font(bold=True)
        ws_stats.cell(row=5, column=2, value=total_courses)
        ws_stats.cell(row=6, column=1, value="Jami daromad").font = Font(bold=True)
        ws_stats.cell(row=6, column=2, value=f"{total_revenue:,} so'm")
        ws_stats.cell(row=7, column=1, value="XP transaksiyalar").font = Font(bold=True)
        ws_stats.cell(row=7, column=2, value=total_xp_transactions)
        ws_stats.cell(row=8, column=1, value="Foydalanuvchi kurslari").font = Font(bold=True)
        ws_stats.cell(row=8, column=2, value=total_user_courses)
        ws_stats.cell(row=9, column=1, value="Support ticketlar").font = Font(bold=True)
        ws_stats.cell(row=9, column=2, value=total_support_tickets)
        ws_stats.cell(row=10, column=1, value="Eksport sanasi").font = Font(bold=True)
        ws_stats.cell(row=10, column=2, value=datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
        
        # Excel papkasini yaratish (faylni saqlashdan oldin)
        excel_dir = os.path.join(Config.DATA_DIR, "excel")
        os.makedirs(excel_dir, exist_ok=True)
        
        # Eski export fayllarni o'chirish (10 kundan eski)
        try:
            current_time = time.time()
            for file in os.listdir(excel_dir):
                if file.startswith('nexus_media_export_') and file.endswith('.xlsx'):
                    file_path = os.path.join(excel_dir, file)
                    file_time = os.path.getmtime(file_path)
                    # 10 kun = 10 * 24 * 3600 sekund
                    if (current_time - file_time) > 10 * 24 * 3600:
                        try:
                            os.remove(file_path)
                            logger.info(f"Eski export fayl o'chirildi: {file}")
                        except Exception as e:
                            logger.warning(f"Eski export faylni o'chirishda xatolik: {e}")
        except Exception as e:
            logger.warning(f"Eski export fayllarni o'chirishda xatolik: {e}")
        
        # Faylni saqlash
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"nexus_media_export_{timestamp}.xlsx"
        filepath = os.path.join(excel_dir, filename)
        
        # Faylni saqlash
        try:
            wb.save(filepath)
            logger.info(f"Excel export fayl yaratildi: {filepath}")
        except Exception as e:
            logger.error(f"Excel faylni saqlashda xatolik: {e}")
            raise
        
        if os.path.exists(filepath):
            from aiogram.types import FSInputFile
            excel_file = FSInputFile(filepath, filename=filename)
            
            await bot.send_document(
                chat_id=user_id,
                document=excel_file,
                caption=f"<b>NEXUS MEDIA TO'LIQ EKSPORTI</b>\n\n"
                       f"<b>Asosiy ma'lumotlar:</b>\n"
                       f"Foydalanuvchilar: {len(users):,}\n"
                       f"Kitoblar: {len(books):,}\n"
                       f"Filmlar: {len(movies):,}\n"
                       f"Kurslar: {len(courses):,}\n"
                       f"To'lovlar: {len(payments):,}\n"
                       f"Yuklashlar: {len(downloads):,}\n"
                       f"Referallar: {len(referrals):,}\n"
                       f"Promo kodlar: {len(promos):,}\n\n"
                       f"<b>Qo'shimcha jadvallar:</b>\n"
                       f"XP transaksiyalar: {len(xp_transactions):,}\n"
                       f"Foydalanuvchi kurslari: {len(user_courses_list):,}\n"
                       f"Kitob reytinglari: {len(book_ratings_list):,}\n"
                       f"Support ticketlar: {len(support_tickets_list):,}\n"
                       f"Sevimlilar: {len(favorites_list):,}\n"
                       f"AI suhbatlar: {len(ai_conversations_list):,}\n"
                       f"Faoliyat logi: {len(activity_logs):,}\n"
                       f"Sharhlar: {len(reviews_list):,}\n"
                       f"Bonuslar: {len(bonuses_list):,}\n"
                       f"Adminlar: {len(admins_list):,}\n\n"
                       f"Sana: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                       f"Admin: {callback.from_user.full_name}",
                parse_mode=ParseMode.HTML
            )
            
            await callback.message.edit_text(
                "<b>Eksport muvaffaqiyatli yakunlandi</b>\n\n"
                f"<b>Asosiy ma'lumotlar:</b>\n"
                f"Foydalanuvchilar: {len(users):,}\n"
                f"Kitoblar: {len(books):,}\n"
                f"Filmlar: {len(movies):,}\n"
                f"Kurslar: {len(courses):,}\n"
                f"To'lovlar: {len(payments):,}\n"
                f"Yuklashlar: {len(downloads):,}\n"
                f"Referallar: {len(referrals):,}\n"
                f"Promo kodlar: {len(promos):,}\n\n"
                f"<b>Qo'shimcha jadvallar:</b>\n"
                f"XP transaksiyalar: {len(xp_transactions):,}\n"
                f"Foydalanuvchi kurslari: {len(user_courses_list):,}\n"
                f"Kitob reytinglari: {len(book_ratings_list):,}\n"
                f"Support ticketlar: {len(support_tickets_list):,}\n"
                f"Sevimlilar: {len(favorites_list):,}\n"
                f"AI suhbatlar: {len(ai_conversations_list):,}\n"
                f"Faoliyat logi: {len(activity_logs):,}\n"
                f"Sharhlar: {len(reviews_list):,}\n"
                f"Bonuslar: {len(bonuses_list):,}\n"
                f"Adminlar: {len(admins_list):,}\n\n"
                f"<b>Excel fayl yuklab olindi</b>\n"
                f"Jami {len(wb.sheetnames)} ta sahifa mavjud.",
                reply_markup=Keyboards.back_button("admin_menu"),
                parse_mode=ParseMode.HTML
            )
        else:
            await callback.message.edit_text(
                "<b>Fayl yaratishda xatolik</b>",
                reply_markup=Keyboards.back_button("admin_menu"),
                parse_mode=ParseMode.HTML
            )
    except Exception as e:
        logger.error(f"Export xatosi: {e}", exc_info=True)
        error_message = str(e)
        if len(error_message) > 500:
            error_message = error_message[:500] + "..."
        
        await callback.message.edit_text(
            f"<b>Xatolik yuz berdi</b>\n\n"
            f"Xatolik: {error_message}\n\n"
            f"Log faylga qarang: <code>data/bot.log</code>",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
    
    await callback.answer()

@router.callback_query(F.data == "admin_backup")
async def handle_admin_backup(callback: CallbackQuery):
    """Admin: Database backup"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text("ðŸ’¾ <b>BACKUP</b>\n\nDatabase yedeklanmoqda...", parse_mode=ParseMode.HTML)
    
    try:
        import shutil
        from datetime import datetime
        
        # Backup fayl nomi
        backup_name = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
        backup_path = os.path.join(Config.DATA_DIR, backup_name)
        
        # Database nusxasini olish
        shutil.copy2(db.db_path, backup_path)
        
        # Backup faylni yuborish
        from aiogram.types import FSInputFile
        backup_file = FSInputFile(backup_path, filename=backup_name)
        
        await callback.message.answer_document(
            document=backup_file,
            caption=f"ðŸ’¾ <b>DATABASE BACKUP</b>\n\n"
                   f"âœ… Backup muvaffaqiyatli yaratildi!\n"
                   f"ðŸ“… Sana: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            parse_mode=ParseMode.HTML
        )
        
        await callback.message.edit_text(
            "âœ… <b>BACKUP YAKUNLANDI!</b>\n\n"
            f"ðŸ’¾ Backup fayl yuklab olindi!\n"
            f"ðŸ“ Fayl: {backup_name}",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
        
        # Eski backup'larni o'chirish (30 kundan eski)
        try:
            for file in os.listdir(Config.DATA_DIR):
                if file.startswith('backup_') and file.endswith('.db'):
                    file_path = os.path.join(Config.DATA_DIR, file)
                    file_time = os.path.getmtime(file_path)
                    if (time.time() - file_time) > 30 * 24 * 3600:  # 30 kun
                        os.remove(file_path)
        except Exception:
            pass
            
    except Exception as e:
        logger.error(f"Backup xatosi: {e}", exc_info=True)
        await callback.message.edit_text(
            f"âŒ <b>Xatolik yuz berdi!</b>\n\n{str(e)}",
            reply_markup=Keyboards.back_button("admin_menu"),
            parse_mode=ParseMode.HTML
        )
    
    await callback.answer()

@router.callback_query(F.data == "admin_auto_send")
async def handle_admin_auto_send(callback: CallbackQuery, state: FSMContext):
    """Admin: Avtomatik yuborish"""
    global auto_send_running, auto_send_task, auto_send_target_user_id
    
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    if auto_send_running:
        await callback.answer("âš ï¸ Avtomatik yuborish allaqachon ishlamoqda!", show_alert=True)
        return
    
    await callback.message.edit_text(
        "ðŸš€ <b>AVTOMATIK YUBORISH</b>\n\n"
        "Qaysi foydalanuvchiga yuborish kerak?\n"
        "Foydalanuvchi ID ni kiriting:",
        reply_markup=Keyboards.back_button("admin_menu"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_auto_send_user)
    await callback.answer()

@router.message(AdminStates.waiting_auto_send_user)
async def handle_auto_send_user_input(message: Message, state: FSMContext):
    """Admin: Avtomatik yuborish uchun foydalanuvchi ID ni qabul qilish"""
    global auto_send_running, auto_send_task, auto_send_target_user_id, bot, db
    
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        target_user_id = int(message.text.strip())
        
        # Foydalanuvchi mavjudligini tekshirish
        target_user = await db.get_user(target_user_id)
        if not target_user:
            await message.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        # Avtomatik yuborishni ishga tushirish
        auto_send_target_user_id = target_user_id
        auto_send_running = True
        auto_send_task = asyncio.create_task(auto_send_worker())
        
        await message.answer(
            f"âœ… <b>AVTOMATIK YUBORISH ISHGA TUSHDI!</b>\n\n"
            f"ðŸ‘¤ Foydalanuvchi: {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” ID: {target_user_id}\n\n"
            f"ðŸ“Š Bazadagi barcha fayllar avtomatik yuboriladi.\n"
            f"â¸ï¸ To'xtatish uchun /admin_stop_auto_send buyrug'ini ishlating.",
            parse_mode=ParseMode.HTML
        )
        await state.clear()
        
    except ValueError:
        await message.answer("âŒ Noto'g'ri ID! Faqat raqam kiriting.")
    except Exception as e:
        logger.error(f"Avtomatik yuborishni ishga tushirishda xatolik: {e}")
        await message.answer("âŒ Xatolik yuz berdi!")

@router.callback_query(F.data == "admin_stop_auto_send")
async def handle_admin_stop_auto_send(callback: CallbackQuery):
    """Admin: Yuborishni to'xtatish"""
    global auto_send_running, auto_send_task
    
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    if not auto_send_running:
        await callback.answer("âš ï¸ Avtomatik yuborish ishlamayapti!", show_alert=True)
        return
    
    # Avtomatik yuborishni to'xtatish
    auto_send_running = False
    if auto_send_task:
        auto_send_task.cancel()
        try:
            await auto_send_task
        except asyncio.CancelledError:
            pass
        auto_send_task = None
    
    await safe_edit_text(callback,
        "â¸ï¸ <b>AVTOMATIK YUBORISH TO'XTATILDI</b>\n\n"
        "Avtomatik yuborish muvaffaqiyatli to'xtatildi.",
        reply_markup=Keyboards.back_button("admin_menu")
    )
    await callback.answer("âœ… Avtomatik yuborish to'xtatildi!")

@router.callback_query(F.data == "admin_delete_all_books")
async def handle_admin_delete_all_books(callback: CallbackQuery):
    """Admin: Barcha kitoblarni o'chirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âœ… Ha, barchasini o'chirish", callback_data="admin_confirm_delete_all_books")
    builder.button(text="âŒ Yo'q, bekor qilish", callback_data="admin_books")
    builder.adjust(1, 1)
    
    async with db.connect() as conn:
        cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1')
        books_count = (await cursor.fetchone())[0] or 0
    
    await safe_edit_text(callback,
        f"ðŸ—‘ï¸ <b>BARCHA KITOBNI O'CHIRISH</b>\n\n"
        f"âš ï¸ <b>Ehtiyot bo'ling!</b>\n\n"
        f"ðŸ“š <b>Jami kitoblar:</b> {books_count:,} ta\n\n"
        f"Barcha kitoblarni o'chirishni tasdiqlaysizmi?\n"
        f"Bu amalni qaytarib bo'lmaydi!",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "admin_confirm_delete_all_books")
async def handle_admin_confirm_delete_all_books(callback: CallbackQuery):
    """Admin: Barcha kitoblarni o'chirishni tasdiqlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        await conn.execute('UPDATE books SET is_active = 0')
        await conn.commit()
        cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 0')
        deleted_count = (await cursor.fetchone())[0] or 0
    
    await safe_edit_text(callback,
        f"âœ… <b>Barcha kitoblar o'chirildi!</b>\n\n"
        f"ðŸ“š <b>O'chirilgan:</b> {deleted_count:,} ta kitob",
        reply_markup=Keyboards.back_button("admin_books")
    )
    await callback.answer("âœ… Barcha kitoblar o'chirildi!")

@router.callback_query(F.data == "admin_media_diagnostic")
async def handle_admin_media_diagnostic(callback: CallbackQuery):
    """Admin: Media diagnostika"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        # Kitoblar
        cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1 AND file_id IS NOT NULL')
        books_with_files = (await cursor.fetchone())[0] or 0
        
        cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1 AND (file_id IS NULL OR file_id = "")')
        books_without_files = (await cursor.fetchone())[0] or 0
        
        # Filmlar
        cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1 AND file_id IS NOT NULL')
        movies_with_files = (await cursor.fetchone())[0] or 0
        
        cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1 AND (file_id IS NULL OR file_id = "")')
        movies_without_files = (await cursor.fetchone())[0] or 0
        
        # Kurslar
        cursor = await conn.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1 AND file_id IS NOT NULL')
        courses_with_files = (await cursor.fetchone())[0] or 0
        
        cursor = await conn.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1 AND (file_id IS NULL OR file_id = "")')
        courses_without_files = (await cursor.fetchone())[0] or 0
    
    text = f"""
ðŸ” <b>MEDIA DIAGNOSTIKA</b>

ðŸ“š <b>KITOBLAR:</b>
âœ… Fayl bilan: {books_with_files:,} ta
âŒ Fayl yo'q: {books_without_files:,} ta

ðŸŽ¬ <b>FILMLAR:</b>
âœ… Fayl bilan: {movies_with_files:,} ta
âŒ Fayl yo'q: {movies_without_files:,} ta

ðŸŽ“ <b>KURSLAR:</b>
âœ… Fayl bilan: {courses_with_files:,} ta
âŒ Fayl yo'q: {courses_without_files:,} ta

ðŸ“Š <b>JAMI:</b>
âœ… Fayl bilan: {books_with_files + movies_with_files + courses_with_files:,} ta
âŒ Fayl yo'q: {books_without_files + movies_without_files + courses_without_files:,} ta
    """
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_menu"))
    await callback.answer()

@router.callback_query(F.data == "admin_settings")
async def handle_admin_settings(callback: CallbackQuery):
    """Admin: Sozlamalar"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    welcome_video_status = "âœ… Qo'shilgan" if Config.WELCOME_VIDEO_FILE_ID else "âŒ Qo'shilmagan"
    premium_video_status = "âœ… Qo'shilgan" if Config.PREMIUM_VIDEO_FILE_ID else "âŒ Qo'shilmagan"
    
    text = f"""
âš™ï¸ <b>ADMIN SOZLAMALARI</b>

ðŸ“¹ <b>VIDEO SOZLAMALARI:</b>

1. ðŸ“¹ <b>Welcome video:</b> {welcome_video_status}
   â€¢ Welcome xabar uchun video
   â€¢ Yangi foydalanuvchilarga yuboriladi

2. ðŸ’Ž <b>Premium video:</b> {premium_video_status}
   â€¢ Premium bo'limi uchun video
   â€¢ Premium tariflar haqida ma'lumot

ðŸ”§ <b>Boshqa sozlamalar:</b>
â€¢ ðŸ“Š Statistika yangilanishi: Real-time
â€¢ ðŸ”” Bildirishnomalar: Yoqilgan
â€¢ ðŸ“¤ Export format: Excel
â€¢ ðŸ’¾ Backup: Avtomatik
â€¢ ðŸ›¡ï¸ Xavfsizlik: Faol

ðŸ’¡ <b>Video qo'shish:</b>
â€¢ Quyidagi tugmalardan birini bosing
â€¢ Botga video faylini yuboring
â€¢ Bot sizga file_id ni ko'rsatadi
â€¢ file_id ni Config'ga qo'ying

ðŸ“ <b>Hozirgi file_id'lar:</b>
Welcome: <code>{Config.WELCOME_VIDEO_FILE_ID or "None"}</code>
Premium: <code>{Config.PREMIUM_VIDEO_FILE_ID or "None"}</code>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“¹ Welcome video qo'shish", callback_data="admin_set_welcome_video")
    builder.button(text="ðŸ’Ž Premium video qo'shish", callback_data="admin_set_premium_video")
    builder.button(text="ðŸ“Š Statistika", callback_data="admin_stats")
    builder.button(text="ðŸ’¾ Backup", callback_data="admin_backup")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_set_welcome_video")
async def handle_admin_set_welcome_video(callback: CallbackQuery, state: FSMContext):
    """Admin: Welcome video qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ“¹ <b>WELCOME VIDEO QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Google Veo 3 da video yarating\n"
        "2. Video faylini botga yuboring\n"
        "3. Bot sizga file_id ni ko'rsatadi\n"
        "4. file_id ni Config.WELCOME_VIDEO_FILE_ID ga qo'ying\n\n"
        "ðŸ“Ž <b>Video faylni yuboring:</b>\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_welcome_video)
    await callback.answer("âœ… Welcome video qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_welcome_video, F.video)
async def handle_admin_welcome_video(message: Message, state: FSMContext):
    """Admin: Welcome video faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if not message.video:
        await message.answer("âŒ Video topilmadi! Video fayl yuboring yoki /cancel tugmasini bosing.")
        return
    
    file_id = message.video.file_id
    file_size = message.video.file_size or 0
    duration = message.video.duration or 0
    
    text = f"""
âœ… <b>VIDEO QABUL QILINDI!</b>

ðŸ“¹ <b>Video ma'lumotlari:</b>
â€¢ File ID: <code>{file_id}</code>
â€¢ Hajmi: {file_size / 1024 / 1024:.2f} MB
â€¢ Davomiyligi: {duration} soniya

ðŸ“ <b>Keyingi qadamlar:</b>
1. Yuqoridagi File ID ni ko'chiring
2. MegaBook_Simple.py faylini oching (yoki Nexus_Media.py)
3. Config class'ida WELCOME_VIDEO_FILE_ID ni toping
4. Quyidagi qatorni o'zgartiring:

<code>WELCOME_VIDEO_FILE_ID = "{file_id}"</code>

5. Botni qayta ishga tushiring

ðŸ’¡ <b>Eslatma:</b> Video file_id ni saqlab qo'ying, keyin Config'ga qo'yishingiz kerak!
    """
    
    await message.answer(text, parse_mode=ParseMode.HTML)
    await state.clear()
    
    # Video preview yuborish
    try:
        await bot.send_video(
            chat_id=user_id,
            video=file_id,
            caption="ðŸ“¹ <b>Welcome video preview</b>\n\nBu video yangi foydalanuvchilarga yuboriladi.",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Video preview yuborishda xatolik: {e}")

@router.message(AdminStates.waiting_welcome_video, F.text == "/cancel")
async def handle_admin_welcome_video_cancel(message: Message, state: FSMContext):
    """Admin: Welcome video qo'shishni bekor qilish"""
    await state.clear()
    await message.answer("âŒ Welcome video qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())

@router.callback_query(F.data == "admin_set_premium_video")
async def handle_admin_set_premium_video(callback: CallbackQuery, state: FSMContext):
    """Admin: Premium video qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ’Ž <b>PREMIUM VIDEO QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Google Veo 3 da Premium bo'limi uchun video yarating\n"
        "2. Video faylini botga yuboring\n"
        "3. Bot sizga file_id ni ko'rsatadi\n"
        "4. file_id ni Config.PREMIUM_VIDEO_FILE_ID ga qo'ying\n\n"
        "ðŸ“Ž <b>Video faylni yuboring:</b>\n"
        "(yoki /cancel tugmasini bosing)",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_premium_video)
    await callback.answer("âœ… Premium video qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_premium_video, F.video)
async def handle_admin_premium_video(message: Message, state: FSMContext):
    """Admin: Premium video faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if not message.video:
        await message.answer("âŒ Video topilmadi! Video fayl yuboring yoki /cancel tugmasini bosing.")
        return
    
    file_id = message.video.file_id
    file_size = message.video.file_size or 0
    duration = message.video.duration or 0
    
    text = f"""
âœ… <b>PREMIUM VIDEO QABUL QILINDI!</b>

ðŸ“¹ <b>Video ma'lumotlari:</b>
â€¢ File ID: <code>{file_id}</code>
â€¢ Hajmi: {file_size / 1024 / 1024:.2f} MB
â€¢ Davomiyligi: {duration} soniya

ðŸ“ <b>Keyingi qadamlar:</b>
1. Yuqoridagi File ID ni ko'chiring
2. MegaBook_Simple.py faylini oching (yoki Nexus_Media.py)
3. Config class'ida PREMIUM_VIDEO_FILE_ID ni toping
4. Quyidagi qatorni o'zgartiring:

<code>PREMIUM_VIDEO_FILE_ID = "{file_id}"</code>

5. Botni qayta ishga tushiring

ðŸ’¡ <b>Eslatma:</b> Video file_id ni saqlab qo'ying, keyin Config'ga qo'yishingiz kerak!
    """
    
    await message.answer(text, parse_mode=ParseMode.HTML)
    await state.clear()
    
    # Video preview yuborish
    try:
        await bot.send_video(
            chat_id=user_id,
            video=file_id,
            caption="ðŸ’Ž <b>Premium video preview</b>\n\nBu video Premium bo'limida ko'rsatiladi.",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Premium video preview yuborishda xatolik: {e}")

@router.message(AdminStates.waiting_premium_video, F.text == "/cancel")
async def handle_admin_premium_video_cancel(message: Message, state: FSMContext):
    """Admin: Premium video qo'shishni bekor qilish"""
    await state.clear()
    await message.answer("âŒ Premium video qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())

@router.callback_query(F.data == "admin_add_audio_book")
async def handle_admin_add_audio_book(callback: CallbackQuery, state: FSMContext):
    """Admin: Audio kitob qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽµ <b>AUDIO KITOB QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Audio kitob nomini yozing\n"
        "2. Keyin audio faylni yuboring\n"
        "3. Avtomatik bazaga saqlanadi\n"
        "4. Jarayonni to'xtatish uchun /cancel\n\n"
        "ðŸ“ <b>Audio kitob nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_add_audio_book)
    await callback.answer("âœ… Audio kitob qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_add_audio_book)
async def handle_admin_audio_book_name(message: Message, state: FSMContext):
    """Admin: Audio kitob nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Audio kitob qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    audio_book_name = message.text.strip()
    if not audio_book_name:
        await message.answer("âŒ Audio kitob nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(audio_book_name=audio_book_name)
    
    await message.answer(
        f"âœ… <b>Audio kitob nomi qabul qilindi!</b>\n\n"
        f"ðŸŽµ <b>Nomi:</b> {audio_book_name}\n\n"
        f"ðŸ“Ž <b>Endi audio faylni yuboring:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )

@router.message(AdminStates.waiting_add_audio_book, F.audio)
async def handle_admin_audio_book_file(message: Message, state: FSMContext):
    """Admin: Audio kitob faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if not message.audio:
        await message.answer("âŒ Audio topilmadi! Audio fayl yuboring yoki /cancel tugmasini bosing.")
        return
    
    data = await state.get_data()
    audio_book_name = data.get('audio_book_name', 'Audio kitob')
    file_id = message.audio.file_id
    
    try:
        # Audio kitobni bazaga qo'shish (books jadvaliga audio sifatida)
        # Kitob kodini generatsiya qilish
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT MAX(order_number) FROM books WHERE is_active = 1')
            row = await cursor.fetchone()
            max_order = row[0] if row[0] is not None else 0
            next_order = max_order + 1
            book_code = str(next_order)
        
        success = await db.add_book(
            code=book_code,
            file_id=file_id,
            caption=audio_book_name,
            author="Noma'lum",
            genre="Audio kitob"
        )
        
        if success:
            await message.answer(
                f"âœ… <b>Audio kitob muvaffaqiyatli qo'shildi!</b>\n\n"
                f"ðŸŽµ <b>Nomi:</b> {audio_book_name}\n\n"
                f"ðŸ’¡ <b>Yana audio kitob qo'shish uchun /admin_add_audio_book yoki /cancel tugmasini bosing.</b>",
                reply_markup=Keyboards.cancel_button(),
                parse_mode=ParseMode.HTML
            )
            logger.info(f"Admin {user_id} audio kitob qo'shdi: {audio_book_name}")
        else:
            await message.answer("âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.")
    except Exception as e:
        logger.error(f"Add audio book error: {e}")
        await message.answer("âŒ Xatolik yuz berdi!")
    
    await state.clear()

@router.callback_query(F.data == "admin_search_book")
async def handle_admin_search_book(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitob qidirish (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ” <b>KITOB QIDIRISH</b>\n\n"
        "Kitob kod, nom, muallif yoki janr bo'yicha qidiring:",
        reply_markup=Keyboards.back_button("admin_books"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_book_search)
    await callback.answer("âœ… Qidiruv rejimi yoqildi!")

@router.message(AdminStates.waiting_book_search)
async def handle_admin_book_search_result(message: Message, state: FSMContext):
    """Admin: Kitob qidiruv natijalari"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    query = message.text.strip()
    books = await db.search_books(query, limit=20)
    
    if not books:
        await message.answer(
            f"âŒ <b>Natija topilmadi</b>\n\n"
            f"'{query}' bo'yicha kitob topilmadi.",
            reply_markup=Keyboards.back_button("admin_books"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
        return
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(books)} ta kitob\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, book in enumerate(books[:15], 1):
        book_title = book.get('caption', 'Nomsiz')[:30]
        book_code = book.get('code', 'N/A')
        text += f"{i}. <b>{book_title}</b>\n"
        text += f"   ðŸ”‘ Kod: {book_code}\n"
        if book.get('author'):
            text += f"   âœï¸ Muallif: {book.get('author')}\n"
        if book.get('genre'):
            text += f"   ðŸ“‚ Janr: {book.get('genre')}\n"
        text += "\n"
        
        builder.button(text=f"ðŸ“š {i}. {book_title[:20]}", callback_data=f"admin_view_book_{book_code}")
    
    builder.button(text="ðŸ”™ Kitoblar", callback_data="admin_books")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await state.clear()

@router.callback_query(F.data == "admin_book_stats")
async def handle_admin_book_stats(callback: CallbackQuery):
    """Admin: Kitob statistikasi (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        # Jami kitoblar
        cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1')
        total_books = (await cursor.fetchone())[0] or 0
        
        # Premium kitoblar
        cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1 AND is_premium = 1')
        premium_books = (await cursor.fetchone())[0] or 0
        
        # Eng ko'p yuklangan kitoblar
        cursor = await conn.execute('''
            SELECT code, caption, downloads, rating, rating_count
            FROM books
            WHERE is_active = 1
            ORDER BY downloads DESC
            LIMIT 10
        ''')
        top_downloaded = await cursor.fetchall()
        
        # Eng yaxshi baholangan kitoblar
        cursor = await conn.execute('''
            SELECT code, caption, rating, rating_count, downloads
            FROM books
            WHERE is_active = 1 AND rating_count > 0
            ORDER BY rating DESC
            LIMIT 10
        ''')
        top_rated = await cursor.fetchall()
        
        # Jami yuklashlar
        cursor = await conn.execute('SELECT SUM(downloads) FROM books WHERE is_active = 1')
        total_downloads = (await cursor.fetchone())[0] or 0
    
    text = f"ðŸ“Š <b>KITOB STATISTIKASI</b>\n\n"
    text += f"ðŸ“š <b>Jami kitoblar:</b> {total_books:,}\n"
    text += f"ðŸ’Ž <b>Premium kitoblar:</b> {premium_books:,}\n"
    text += f"ðŸ“¥ <b>Jami yuklashlar:</b> {total_downloads:,}\n\n"
    
    text += f"ðŸ”¥ <b>Eng ko'p yuklangan (Top 5):</b>\n"
    for i, book in enumerate(top_downloaded[:5], 1):
        text += f"{i}. {book[1][:30]}\n"
        text += f"   ðŸ“¥ {book[2] or 0} yuklash\n"
        text += f"   â­ {book[3] or 0:.1f}/5.0 ({book[4] or 0} baho)\n\n"
    
    text += f"â­ <b>Eng yaxshi baholangan (Top 5):</b>\n"
    for i, book in enumerate(top_rated[:5], 1):
        text += f"{i}. {book[1][:30]}\n"
        text += f"   â­ {book[2] or 0:.1f}/5.0 ({book[3] or 0} baho)\n"
        text += f"   ðŸ“¥ {book[4] or 0} yuklash\n\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Kitoblar", callback_data="admin_books")
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_edit_book")
async def handle_admin_edit_book(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitobni tahrirlash (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "âœï¸ <b>KITOBNI TAHRIRLASH</b>\n\n"
        "Tahrirlash uchun kitob kodini yozing:",
        reply_markup=Keyboards.back_button("admin_books"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_book_code_search)
    await callback.answer("âœ… Tahrirlash rejimi yoqildi!")

@router.message(AdminStates.waiting_book_code_search)
async def handle_admin_edit_book_code(message: Message, state: FSMContext):
    """Admin: Kitob kodini qabul qilish va tahrirlash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    book_code = message.text.strip()
    book = await db.get_book(book_code)
    
    if not book:
        await message.answer(
            f"âŒ <b>Kitob topilmadi!</b>\n\n"
            f"Kod: <code>{book_code}</code>\n\n"
            f"Qayta urinib ko'ring:",
            reply_markup=Keyboards.back_button("admin_books"),
            parse_mode=ParseMode.HTML
        )
        return
    
    await state.update_data(book_code=book_code)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“ Nomni o'zgartirish", callback_data="admin_edit_book_name")
    builder.button(text="âœï¸ Muallifni o'zgartirish", callback_data="admin_edit_book_author")
    builder.button(text="ðŸ“‚ Janrni o'zgartirish", callback_data="admin_edit_book_genre")
    builder.button(text="ðŸ’Ž Premium/Standart", callback_data="admin_edit_book_premium")
    builder.button(text="ðŸ”™ Kitoblar", callback_data="admin_books")
    builder.adjust(1, 1, 1, 1, 1)
    
    await message.answer(
        f"âœï¸ <b>KITOB TAHRIRLASH</b>\n\n"
        f"ðŸ“š <b>Nomi:</b> {book.get('caption', 'Nomsiz')}\n"
        f"ðŸ”‘ <b>Kod:</b> {book_code}\n"
        f"âœï¸ <b>Muallif:</b> {book.get('author', 'Noma\'lum')}\n"
        f"ðŸ“‚ <b>Janr:</b> {book.get('genre', 'Noma\'lum')}\n"
        f"ðŸ’Ž <b>Premium:</b> {'Ha' if book.get('is_premium') else 'Yo\'q'}\n\n"
        f"Nimani tahrirlashni xohlaysiz?",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    await state.clear()

@router.callback_query(F.data == "admin_delete_book")
async def handle_admin_delete_book(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitobni o'chirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ—‘ï¸ <b>Kitobni o'chirish</b>\n\n"
        "Kitob kodini yozing:",
        reply_markup=Keyboards.back_button("admin_books"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_book_code_for_delete)
    await callback.answer()

@router.message(AdminStates.waiting_book_code_for_delete)
async def handle_admin_delete_book_code(message: Message, state: FSMContext):
    """Admin: Kitobni o'chirish (kod bo'yicha)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    book_code = message.text.strip()
    
    async with db.connect() as conn:
        await conn.execute('UPDATE books SET is_active = 0 WHERE code = ?', (book_code,))
        await conn.commit()
    
    await message.answer(
        f"âœ… <b>Kitob o'chirildi!</b>\n\n"
        f"ðŸ“– Kod: <code>{book_code}</code>",
        reply_markup=Keyboards.back_button("admin_books"),
        parse_mode=ParseMode.HTML
    )
    await state.clear()

@router.callback_query(F.data == "admin_search_movie")
async def handle_admin_search_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Film qidirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ” <b>Film qidirish</b>\n\n"
        "Film nomi, janr yoki tartib raqamini yozing:",
        reply_markup=Keyboards.back_button("admin_movies"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_movie_id_search)
    await callback.answer()

@router.message(AdminStates.waiting_movie_id_search)
async def handle_admin_movie_search_result(message: Message, state: FSMContext):
    """Admin: Film qidiruv natijalari"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    query = message.text.strip()
    movies = await db.search_movies(query, limit=20)
    
    if not movies:
        await message.answer(
            f"âŒ <b>Natija topilmadi</b>\n\n"
            f"'{query}' bo'yicha film topilmadi.",
            reply_markup=Keyboards.back_button("admin_movies"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
        return
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(movies)} ta film\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, movie in enumerate(movies[:15], 1):
        movie_title = movie.get('caption', 'Nomsiz')[:30]
        text += f"{i}. <b>{movie_title}</b>\n"
        if movie.get('quality'):
            text += f"   ðŸ“º Sifat: {movie.get('quality')}\n"
        if movie.get('id'):
            text += f"   ðŸ†” ID: {movie.get('id')}\n"
        text += "\n"
        
        builder.button(text=f"ðŸŽ¬ {i}. {movie_title[:20]}", callback_data=f"admin_view_movie_{movie.get('id', 0)}")
    
    builder.button(text="ðŸ”™ Filmlar", callback_data="admin_movies")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await state.clear()

@router.callback_query(F.data == "admin_movie_stats")
async def handle_admin_movie_stats(callback: CallbackQuery):
    """Admin: Film statistikasi (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        # Jami filmlar
        cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1')
        total_movies = (await cursor.fetchone())[0] or 0
        
        # Eng ko'p ko'rilgan filmlar
        cursor = await conn.execute('''
            SELECT id, caption, views, rating, rating_count, quality
            FROM movies
            WHERE is_active = 1
            ORDER BY views DESC
            LIMIT 10
        ''')
        top_viewed = await cursor.fetchall()
        
        # Eng yaxshi baholangan filmlar
        cursor = await conn.execute('''
            SELECT id, caption, rating, rating_count, views, quality
            FROM movies
            WHERE is_active = 1 AND rating_count > 0
            ORDER BY rating DESC
            LIMIT 10
        ''')
        top_rated = await cursor.fetchall()
        
        # Jami ko'rishlar
        cursor = await conn.execute('SELECT SUM(views) FROM movies WHERE is_active = 1')
        total_views = (await cursor.fetchone())[0] or 0
    
    text = f"ðŸ“Š <b>FILM STATISTIKASI</b>\n\n"
    text += f"ðŸŽ¬ <b>Jami filmlar:</b> {total_movies:,}\n"
    text += f"ðŸ‘ï¸ <b>Jami ko'rishlar:</b> {total_views:,}\n\n"
    
    text += f"ðŸ”¥ <b>Eng ko'p ko'rilgan (Top 5):</b>\n"
    for i, movie in enumerate(top_viewed[:5], 1):
        text += f"{i}. {movie[1][:30]}\n"
        text += f"   ðŸ‘ï¸ {movie[2] or 0} ko'rish\n"
        text += f"   â­ {movie[3] or 0:.1f}/5.0 ({movie[4] or 0} baho)\n"
        if movie[5]:
            text += f"   ðŸ“º {movie[5]}\n"
        text += "\n"
    
    text += f"â­ <b>Eng yaxshi baholangan (Top 5):</b>\n"
    for i, movie in enumerate(top_rated[:5], 1):
        text += f"{i}. {movie[1][:30]}\n"
        text += f"   â­ {movie[2] or 0:.1f}/5.0 ({movie[3] or 0} baho)\n"
        text += f"   ðŸ‘ï¸ {movie[4] or 0} ko'rish\n\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Filmlar", callback_data="admin_movies")
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_preload_all_movies")
async def handle_admin_preload_all_movies(callback: CallbackQuery):
    """Admin: Barcha kinolarni yuklash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    text = "<b>KINOLARNI YUKLASH</b>\n\n"
    text += "Bu funksiya barcha kinolarni cache'ga yuklash uchun ishlatiladi.\n\n"
    text += "Hozircha bu funksiya ishlab chiqilmoqda. Kinolarni alohida-alohida yuklash mumkin."
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_movies"))
    await callback.answer()

@router.callback_query(F.data == "admin_delete_all_movies")
async def handle_admin_delete_all_movies(callback: CallbackQuery, state: FSMContext):
    """Admin: Barcha kinolarni o'chirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    builder = InlineKeyboardBuilder()
    builder.button(text="Ha, o'chirish", callback_data="admin_confirm_delete_all_movies")
    builder.button(text="Bekor qilish", callback_data="admin_movies")
    builder.adjust(1, 1)
    
    text = "<b>BARCHA KINOLARNI O'CHIRISH</b>\n\n"
    text += "âš ï¸ <b>DIQQAT!</b> Bu amal barcha kinolarni bazadan o'chiradi.\n\n"
    text += "Bu amalni qaytarib bo'lmaydi. O'chirishni tasdiqlaysizmi?"
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_confirm_delete_all_movies")
async def handle_admin_confirm_delete_all_movies(callback: CallbackQuery):
    """Admin: Barcha kinolarni o'chirishni tasdiqlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        try:
            await conn.execute('UPDATE movies SET is_active = 0')
            await conn.commit()
            
            cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 0')
            deleted_count = (await cursor.fetchone())[0] or 0
            
            text = f"<b>KINOLAR O'CHIRILDI</b>\n\n"
            text += f"âœ… Jami {deleted_count} ta kino o'chirildi (is_active = 0).\n\n"
            text += "Ma'lumotlar saqlanib qoldi, lekin foydalanuvchilar uchun ko'rinmaydi."
        except Exception as e:
            logger.error(f"Kinolarni o'chirish xatosi: {e}")
            text = "Xatolik yuz berdi. Qayta urinib ko'ring."
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("admin_movies"))
    await callback.answer()

@router.callback_query(F.data == "admin_edit_movie")
async def handle_admin_edit_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Filmini tahrirlash (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "âœï¸ <b>FILMNI TAHRIRLASH</b>\n\n"
        "Tahrirlash uchun film ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_movies"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_movie_id_search)
    await callback.answer("âœ… Tahrirlash rejimi yoqildi!")

@router.callback_query(F.data.startswith("admin_view_movie_"))
async def handle_admin_view_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Filmini ko'rish va tahrirlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    movie_id = int(callback.data.replace("admin_view_movie_", ""))
    movie = await db.get_movie(movie_id)
    
    if not movie:
        await callback.answer("âŒ Film topilmadi!", show_alert=True)
        return
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“ Nomni o'zgartirish", callback_data=f"admin_edit_movie_name_{movie_id}")
    builder.button(text="ðŸ“‚ Janrni o'zgartirish", callback_data=f"admin_edit_movie_genre_{movie_id}")
    builder.button(text="ðŸ“º Sifatni o'zgartirish", callback_data=f"admin_edit_movie_quality_{movie_id}")
    builder.button(text="ðŸ”™ Filmlar", callback_data="admin_movies")
    builder.adjust(1, 1, 1, 1)
    
    await safe_edit_text(callback,
        f"ðŸŽ¬ <b>FILM MA'LUMOTLARI</b>\n\n"
        f"ðŸ“ <b>Nomi:</b> {movie.get('caption', 'Nomsiz')}\n"
        f"ðŸ†” <b>ID:</b> {movie_id}\n"
        f"ðŸ“‚ <b>Janr:</b> {movie.get('genre', 'Noma\'lum')}\n"
        f"ðŸ“º <b>Sifat:</b> {movie.get('quality', '720p')}\n"
        f"ðŸ‘ï¸ <b>Ko'rishlar:</b> {movie.get('views', 0)}\n"
        f"â­ <b>Baho:</b> {movie.get('rating', 0):.1f}/5.0 ({movie.get('rating_count', 0)} baho)\n\n"
        f"Nimani tahrirlashni xohlaysiz?",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "admin_delete_movie")
async def handle_admin_delete_movie(callback: CallbackQuery, state: FSMContext):
    """Admin: Filmini o'chirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ—‘ï¸ <b>Filmini o'chirish</b>\n\n"
        "Film ID yoki tartib raqamini yozing:",
        reply_markup=Keyboards.back_button("admin_movies"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_movie_id_delete)
    await callback.answer()

@router.message(AdminStates.waiting_movie_id_delete)
async def handle_admin_delete_movie_id(message: Message, state: FSMContext):
    """Admin: Filmini o'chirish (ID bo'yicha)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    movie_id = message.text.strip()
    
    try:
        movie_id_int = int(movie_id)
        async with db.connect() as conn:
            await conn.execute('UPDATE movies SET is_active = 0 WHERE id = ?', (movie_id_int,))
            await conn.commit()
        
        await message.answer(
            f"âœ… <b>Film o'chirildi!</b>\n\n"
            f"ðŸŽ¬ ID: <code>{movie_id_int}</code>",
            reply_markup=Keyboards.back_button("admin_movies"),
            parse_mode=ParseMode.HTML
        )
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Film ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_movies"),
            parse_mode=ParseMode.HTML
        )
    
    await state.clear()

@router.callback_query(F.data == "admin_search_course")
async def handle_admin_search_course(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs qidirish (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ” <b>KURS QIDIRISH</b>\n\n"
        "Kurs nomi yoki kategoriya bo'yicha qidiring:",
        reply_markup=Keyboards.back_button("admin_courses"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_search)
    await callback.answer("âœ… Qidiruv rejimi yoqildi!")

@router.message(AdminStates.waiting_course_search)
async def handle_admin_course_search_result(message: Message, state: FSMContext):
    """Admin: Kurs qidiruv natijalari"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    query = message.text.strip()
    courses = await db.search_courses(query, limit=20)
    
    if not courses:
        await message.answer(
            f"âŒ <b>Natija topilmadi</b>\n\n"
            f"'{query}' bo'yicha kurs topilmadi.",
            reply_markup=Keyboards.back_button("admin_courses"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
        return
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(courses)} ta kurs\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, course in enumerate(courses[:15], 1):
        course_title = course.get('title', 'Nomsiz')[:30]
        course_id = course.get('id', 0)
        price = course.get('price', 19990)
        text += f"{i}. <b>{course_title}</b>\n"
        text += f"   ðŸ†” ID: {course_id}\n"
        text += f"   ðŸ’° Narx: {price:,} so'm\n"
        if course.get('students_count'):
            text += f"   ðŸ‘¥ Talabalar: {course.get('students_count')}\n"
        text += "\n"
        
        builder.button(text=f"ðŸŽ“ {i}. {course_title[:20]}", callback_data=f"admin_view_course_{course_id}")
    
    builder.button(text="ðŸ”™ Kurslar", callback_data="admin_courses")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await state.clear()

@router.callback_query(F.data == "admin_course_stats")
async def handle_admin_course_stats(callback: CallbackQuery):
    """Admin: Kurs statistikasi (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        # Jami kurslar
        cursor = await conn.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1')
        total_courses = (await cursor.fetchone())[0] or 0
        
        # Eng ko'p sotilgan kurslar
        cursor = await conn.execute('''
            SELECT c.id, c.title, c.price, 
                   COUNT(uc.id) as purchase_count,
                   c.students_count, c.rating, c.rating_count
            FROM courses c
            LEFT JOIN user_courses uc ON c.id = uc.course_id
            WHERE c.is_active = 1
            GROUP BY c.id
            ORDER BY purchase_count DESC, c.students_count DESC
            LIMIT 10
        ''')
        top_purchased = await cursor.fetchall()
        
        # Eng yaxshi baholangan kurslar
        cursor = await conn.execute('''
            SELECT id, title, rating, rating_count, students_count, price
            FROM courses
            WHERE is_active = 1 AND rating_count > 0
            ORDER BY rating DESC
            LIMIT 10
        ''')
        top_rated = await cursor.fetchall()
        
        # Jami talabalar
        cursor = await conn.execute('SELECT SUM(students_count) FROM courses WHERE is_active = 1')
        total_students = (await cursor.fetchone())[0] or 0
        
        # Jami sotuvlar
        cursor = await conn.execute('SELECT COUNT(*) FROM user_courses')
        total_purchases = (await cursor.fetchone())[0] or 0
    
    text = f"ðŸ“Š <b>KURS STATISTIKASI</b>\n\n"
    text += f"ðŸŽ“ <b>Jami kurslar:</b> {total_courses:,}\n"
    text += f"ðŸ‘¥ <b>Jami talabalar:</b> {total_students:,}\n"
    text += f"ðŸ’° <b>Jami sotuvlar:</b> {total_purchases:,}\n\n"
    
    text += f"ðŸ”¥ <b>Eng ko'p sotilgan (Top 5):</b>\n"
    for i, course in enumerate(top_purchased[:5], 1):
        text += f"{i}. {course[1][:30]}\n"
        text += f"   ðŸ’° {course[4] or 0} talaba, {course[3] or 0} sotuv\n"
        text += f"   ðŸ’µ {course[2]:,} so'm\n"
        text += f"   â­ {course[5] or 0:.1f}/5.0\n\n"
    
    text += f"â­ <b>Eng yaxshi baholangan (Top 5):</b>\n"
    for i, course in enumerate(top_rated[:5], 1):
        text += f"{i}. {course[1][:30]}\n"
        text += f"   â­ {course[2] or 0:.1f}/5.0 ({course[3] or 0} baho)\n"
        text += f"   ðŸ‘¥ {course[4] or 0} talaba\n\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Kurslar", callback_data="admin_courses")
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_edit_course")
async def handle_admin_edit_course(callback: CallbackQuery, state: FSMContext):
    """Admin: Kursni tahrirlash (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "âœï¸ <b>KURSNI TAHRIRLASH</b>\n\n"
        "Tahrirlash uchun kurs ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_courses"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_id)
    await callback.answer("âœ… Tahrirlash rejimi yoqildi!")

@router.message(AdminStates.waiting_course_id)
async def handle_admin_edit_course_id(message: Message, state: FSMContext):
    """Admin: Kurs ID ni qabul qilish va tahrirlash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        course_id = int(message.text.strip())
        course = await db.get_course(course_id)
        
        if not course:
            await message.answer(
                f"âŒ <b>Kurs topilmadi!</b>\n\n"
                f"ID: <code>{course_id}</code>\n\n"
                f"Qayta urinib ko'ring:",
                reply_markup=Keyboards.back_button("admin_courses"),
                parse_mode=ParseMode.HTML
            )
            return
        
        await state.update_data(course_id=course_id)
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“ Nomni o'zgartirish", callback_data="admin_edit_course_title")
        builder.button(text="ðŸ’° Narxni o'zgartirish", callback_data="admin_edit_course_price")
        builder.button(text="ðŸ“‚ Kategoriyani o'zgartirish", callback_data="admin_edit_course_category")
        builder.button(text="ðŸ“ Tavsifni o'zgartirish", callback_data="admin_edit_course_description")
        builder.button(text="ðŸ”™ Kurslar", callback_data="admin_courses")
        builder.adjust(1, 1, 1, 1, 1)
        
        await message.answer(
            f"âœï¸ <b>KURS TAHRIRLASH</b>\n\n"
            f"ðŸŽ“ <b>Nomi:</b> {course.get('title', 'Nomsiz')}\n"
            f"ðŸ†” <b>ID:</b> {course_id}\n"
            f"ðŸ’° <b>Narx:</b> {course.get('price', 19990):,} so'm\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {course.get('category', 'Noma\'lum')}\n"
            f"ðŸ‘¥ <b>Talabalar:</b> {course.get('students_count', 0)}\n\n"
            f"Nimani tahrirlashni xohlaysiz?",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Kurs ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_courses"),
            parse_mode=ParseMode.HTML
        )

@router.callback_query(F.data == "admin_delete_course")
async def handle_admin_delete_course(callback: CallbackQuery, state: FSMContext):
    """Admin: Kursni o'chirish (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ—‘ï¸ <b>KURSNI O'CHIRISH</b>\n\n"
        "O'chirish uchun kurs ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_courses"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_id_for_delete)
    await callback.answer("âœ… O'chirish rejimi yoqildi!")

@router.message(AdminStates.waiting_course_id_for_delete)
async def handle_admin_delete_course_id(message: Message, state: FSMContext):
    """Admin: Kursni o'chirish (ID bo'yicha)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        course_id = int(message.text.strip())
        course = await db.get_course(course_id)
        
        if not course:
            await message.answer(
                f"âŒ <b>Kurs topilmadi!</b>\n\n"
                f"ID: <code>{course_id}</code>",
                reply_markup=Keyboards.back_button("admin_courses"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # Tasdiqlash
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Ha, o'chirish", callback_data=f"admin_confirm_delete_course_{course_id}")
        builder.button(text="âŒ Yo'q, bekor qilish", callback_data="admin_courses")
        builder.adjust(1, 1)
        
        await message.answer(
            f"âš ï¸ <b>DIQQAT!</b>\n\n"
            f"Kurs o'chiriladi:\n"
            f"ðŸŽ“ <b>Nomi:</b> {course.get('title', 'Nomsiz')}\n"
            f"ðŸ†” <b>ID:</b> {course_id}\n"
            f"ðŸ‘¥ <b>Talabalar:</b> {course.get('students_count', 0)}\n\n"
            f"Bu amalni qaytarib bo'lmaydi!\n\n"
            f"Haqiqatan ham o'chirmoqchimisiz?",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Kurs ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_courses"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.callback_query(F.data.startswith("admin_confirm_delete_course_"))
async def handle_admin_confirm_delete_course(callback: CallbackQuery):
    """Admin: Kursni o'chirishni tasdiqlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    course_id = int(callback.data.replace("admin_confirm_delete_course_", ""))
    
    async with db.connect() as conn:
        await conn.execute('UPDATE courses SET is_active = 0 WHERE id = ?', (course_id,))
        await conn.commit()
    
    await safe_edit_text(callback,
        f"âœ… <b>Kurs o'chirildi!</b>\n\n"
        f"ðŸ†” ID: <code>{course_id}</code>",
        reply_markup=Keyboards.back_button("admin_courses")
    )
    await callback.answer("âœ… Kurs o'chirildi!")

@router.callback_query(F.data == "admin_search_user")
async def handle_admin_search_user(callback: CallbackQuery, state: FSMContext):
    """Admin: Foydalanuvchi qidirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ” <b>Foydalanuvchi qidirish</b>\n\n"
        "Foydalanuvchi ID, username yoki ismini yozing:",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_search)
    await callback.answer()

@router.message(AdminStates.waiting_user_search)
async def handle_admin_user_search_result(message: Message, state: FSMContext):
    """Admin: Foydalanuvchi qidiruv natijalari"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    query = message.text.strip()
    
    # ID bo'yicha qidirish
    if query.isdigit():
        target_user_id = int(query)
        user = await db.get_user(target_user_id)
        if user:
            text = f"ðŸ‘¤ <b>FOYDALANUVCHI MA'LUMOTLARI</b>\n\n"
            text += f"ðŸ†” ID: {target_user_id}\n"
            text += f"ðŸ‘¤ Ism: {user.get('full_name', 'Noma\'lum')}\n"
            text += f"ðŸ“± Username: @{user.get('username', 'yo\'q')}\n"
            text += f"ðŸ‘‘ Status: {DatabaseManager.get_subscription_name(user.get('subscription_type', 0))}\n"
            text += f"â­ XP: {user.get('xp', 0):,}\n"
            text += f"ðŸ“… Ro'yxatdan o'tgan: {user.get('joined_date', 'N/A')}\n"
            
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸŽ XP berish", callback_data=f"admin_give_xp_{target_user_id}")
            builder.button(text="ðŸ‘‘ Premium berish", callback_data=f"admin_give_premium_{target_user_id}")
            builder.button(text="â›” Bloklash", callback_data=f"admin_ban_{target_user_id}")
            builder.button(text="ðŸ“ Xabar yuborish", callback_data=f"admin_send_msg_{target_user_id}")
            builder.button(text="ðŸ”™ Foydalanuvchilar", callback_data="admin_users")
            builder.adjust(2, 2, 1)
            
            await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            await state.clear()
            return
    
    await message.answer(
        "âŒ <b>Foydalanuvchi topilmadi</b>\n\n"
        "Foydalanuvchi ID ni kiriting (raqam).",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.clear()

@router.callback_query(F.data == "admin_user_stats")
async def handle_admin_user_stats(callback: CallbackQuery, state: FSMContext):
    """Admin: Foydalanuvchi statistikasi (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ“Š <b>FOYDALANUVCHI STATISTIKASI</b>\n\n"
        "Statistikasini ko'rish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_id_for_stats)
    await callback.answer("âœ… Statistika rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_stats)
async def handle_admin_user_stats_id(message: Message, state: FSMContext):
    """Admin: Foydalanuvchi statistikasini ko'rsatish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        target_user_id = int(message.text.strip())
        target_user = await db.get_user(target_user_id)
        
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # Statistika ma'lumotlarini olish
        async with db.connect() as conn:
            # Yuklashlar
            cursor = await conn.execute('SELECT COUNT(*) FROM download_history WHERE user_id = ?', (target_user_id,))
            total_downloads = (await cursor.fetchone())[0] or 0
            
            # AI savollar
            cursor = await conn.execute('SELECT COUNT(*) FROM ai_conversations WHERE user_id = ?', (target_user_id,))
            ai_questions = (await cursor.fetchone())[0] or 0
            
            # Kurslar
            cursor = await conn.execute('SELECT COUNT(*) FROM user_courses WHERE user_id = ?', (target_user_id,))
            courses_count = (await cursor.fetchone())[0] or 0
            
            # Referrallar
            cursor = await conn.execute('SELECT COUNT(*) FROM referrals WHERE referrer_id = ?', (target_user_id,))
            referrals_count = (await cursor.fetchone())[0] or 0
        
        subscription_name = DatabaseManager.get_subscription_name(target_user.get('subscription_type', 0))
        
        text = f"ðŸ“Š <b>FOYDALANUVCHI STATISTIKASI</b>\n\n"
        text += f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
        text += f"ðŸ†” <b>ID:</b> {target_user_id}\n"
        text += f"ðŸ‘‘ <b>Status:</b> {subscription_name}\n"
        text += f"ðŸ’° <b>XP:</b> {target_user.get('xp', 0):,}\n"
        text += f"ðŸ“… <b>Ro'yxatdan o'tgan:</b> {target_user.get('joined_date', 'Noma\'lum')}\n\n"
        
        text += f"ðŸ“ˆ <b>FAOLLIK:</b>\n"
        text += f"ðŸ“¥ <b>Yuklashlar:</b> {total_downloads}\n"
        text += f"ðŸ¤– <b>AI savollar:</b> {ai_questions}\n"
        text += f"ðŸŽ“ <b>Kurslar:</b> {courses_count}\n"
        text += f"ðŸ‘¥ <b>Referrallar:</b> {referrals_count}\n"
        text += f"ðŸ”¥ <b>Streak:</b> {target_user.get('streak_count', 0)} kun\n"
        text += f"ðŸ’µ <b>Sarflangan:</b> {target_user.get('total_spent', 0):,} so'm\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ XP berish", callback_data=f"admin_give_xp_{target_user_id}")
        builder.button(text="ðŸ‘‘ Premium berish", callback_data=f"admin_give_premium_{target_user_id}")
        builder.button(text="ðŸ“ Xabar yuborish", callback_data=f"admin_send_message_{target_user_id}")
        builder.button(text="ðŸ”™ Foydalanuvchilar", callback_data="admin_users")
        builder.adjust(1, 1, 1, 1)
        
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.callback_query(F.data == "admin_give_xp")
async def handle_admin_give_xp(callback: CallbackQuery, state: FSMContext):
    """Admin: XP berish (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸŽ <b>XP BERISH</b>\n\n"
        "XP berish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_id_xp)
    await callback.answer("âœ… XP berish rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_xp)
async def handle_admin_give_xp_user(message: Message, state: FSMContext):
    """Admin: XP berish - XP miqdorini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    target_user_id = data.get('target_user_id')
    
    if not target_user_id:
        # Agar target_user_id yo'q bo'lsa, bu foydalanuvchi ID
        try:
            target_user_id = int(message.text.strip())
            target_user = await db.get_user(target_user_id)
            
            if not target_user:
                await message.answer(
                    f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                    f"ID: <code>{target_user_id}</code>",
                    reply_markup=Keyboards.back_button("admin_users"),
                    parse_mode=ParseMode.HTML
                )
                await state.clear()
                return
            
            await state.update_data(target_user_id=target_user_id)
            await message.answer(
                f"âœ… <b>Foydalanuvchi topildi!</b>\n\n"
                f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
                f"ðŸ’° <b>Hozirgi XP:</b> {target_user.get('xp', 0):,}\n\n"
                f"Qancha XP berishni xohlaysiz? (Raqam kiriting):",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            return
        except ValueError:
            await message.answer(
                "âŒ <b>Noto'g'ri ID!</b>\n\n"
                "Foydalanuvchi ID raqam bo'lishi kerak.",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
    
    # XP miqdorini qabul qilish
    try:
        xp_amount = int(message.text.strip())
        
        if xp_amount <= 0:
            await message.answer(
                "âŒ <b>Noto'g'ri miqdor!</b>\n\n"
                "XP miqdori 0 dan katta bo'lishi kerak.",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            return
        
        target_user = await db.get_user(target_user_id)
        if not target_user:
            await message.answer(
                "âŒ <b>Foydalanuvchi topilmadi!</b>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # XP qo'shish
        new_xp = target_user.get('xp', 0) + xp_amount
        await db.add_xp(target_user_id, xp_amount, "admin_gift", user_id)
        
        await message.answer(
            f"âœ… <b>XP berildi!</b>\n\n"
            f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ’° <b>Berilgan XP:</b> {xp_amount:,}\n"
            f"ðŸ’Ž <b>Eski XP:</b> {target_user.get('xp', 0):,}\n"
            f"ðŸŽ¯ <b>Yangi XP:</b> {new_xp:,}",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        
        # Foydalanuvchiga xabar
        try:
            await bot.send_message(
                target_user_id,
                f"ðŸŽ <b>Tabriklaymiz!</b>\n\n"
                f"Sizga admin tomonidan {xp_amount:,} XP berildi!\n"
                f"ðŸ’° <b>Yangi XP:</b> {new_xp:,}",
                parse_mode=ParseMode.HTML
            )
        except Exception:
            pass
        
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri miqdor!</b>\n\n"
            "XP miqdori raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )

@router.callback_query(F.data.startswith("admin_give_xp_"))
async def handle_admin_give_xp_direct(callback: CallbackQuery, state: FSMContext):
    """Admin: XP berish (to'g'ridan-to'g'ri)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_user_id = int(callback.data.replace("admin_give_xp_", ""))
    target_user = await db.get_user(target_user_id)
    
    if not target_user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    await state.update_data(target_user_id=target_user_id)
    await callback.message.edit_text(
        f"ðŸŽ <b>XP BERISH</b>\n\n"
        f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
        f"ðŸ’° <b>Hozirgi XP:</b> {target_user.get('xp', 0):,}\n\n"
        f"Qancha XP berishni xohlaysiz? (Raqam kiriting):",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_id_xp)
    await callback.answer()

@router.callback_query(F.data == "admin_give_premium")
async def handle_admin_give_premium_menu(callback: CallbackQuery, state: FSMContext):
    """Admin: Premium berish menyusi"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ‘‘ <b>PREMIUM BERISH</b>\n\n"
        "Premium berish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users")
    )
    await state.set_state(AdminStates.waiting_user_id_for_premium)
    await callback.answer("âœ… Premium berish rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_premium)
async def handle_admin_give_premium_user_id(message: Message, state: FSMContext):
    """Admin: Premium berish - foydalanuvchi ID"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Premium berish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    try:
        target_user_id = int(message.text.strip())
        target_user = await db.get_user(target_user_id)
        
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        await state.update_data(target_user_id=target_user_id)
        
        # Premium turini tanlash
        builder = InlineKeyboardBuilder()
        builder.button(text="â­ Premium (1 oy)", callback_data=f"admin_premium_{target_user_id}_1_30")
        builder.button(text="ðŸ”¥ PRO (1 oy)", callback_data=f"admin_premium_{target_user_id}_2_30")
        builder.button(text="ðŸ’Ž Exclusive (1 oy)", callback_data=f"admin_premium_{target_user_id}_3_30")
        builder.button(text="ðŸ† Exclusive Pro+ (1 oy)", callback_data=f"admin_premium_{target_user_id}_4_30")
        builder.button(text="âŒ Bekor qilish", callback_data="admin_users")
        builder.adjust(1, 1, 1, 1, 1)
        
        await message.answer(
            f"âœ… <b>Foydalanuvchi topildi!</b>\n\n"
            f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ‘‘ <b>Hozirgi Premium:</b> {['Yo\'q', 'Premium', 'PRO', 'Exclusive', 'Exclusive Pro+'][target_user.get('subscription_type', 0)]}\n\n"
            f"Premium turini tanlang:",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.callback_query(F.data.startswith("admin_give_premium_"))
async def handle_admin_give_premium(callback: CallbackQuery, state: FSMContext):
    """Admin: Premium berish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_user_id = int(callback.data.replace("admin_give_premium_", ""))
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’Ž Premium (30 kun)", callback_data=f"admin_premium_{target_user_id}_2_30")
    builder.button(text="ðŸ† Exclusive (30 kun)", callback_data=f"admin_premium_{target_user_id}_3_30")
    builder.button(text="ðŸ”™ Orqaga", callback_data="admin_users")
    builder.adjust(1)
    
    await callback.message.edit_text(
        f"ðŸ‘‘ <b>Premium berish</b>\n\n"
        f"Foydalanuvchi ID: {target_user_id}\n\n"
        f"Premium turini tanlang:",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_premium_"))
async def handle_admin_premium_activate(callback: CallbackQuery):
    """Admin: Premium aktivlashtirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    parts = callback.data.replace("admin_premium_", "").split("_")
    target_user_id = int(parts[0])
    sub_type = int(parts[1])
    days = int(parts[2])
    
    success = await db.activate_premium(target_user_id, days, sub_type)
    
    if success:
        await callback.message.edit_text(
            f"âœ… <b>Premium aktivlashtirildi!</b>\n\n"
            f"ðŸ‘¤ Foydalanuvchi ID: {target_user_id}\n"
            f"ðŸ‘‘ Tur: {DatabaseManager.get_subscription_name(sub_type)}\n"
            f"ðŸ“… Muddati: {days} kun",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        
        # Foydalanuvchiga xabar
        try:
            await bot.send_message(
                target_user_id,
                f"ðŸŽ‰ <b>Tabriklaymiz!</b>\n\n"
                f"Sizga Premium obuna berildi!\n"
                f"ðŸ‘‘ Tur: {DatabaseManager.get_subscription_name(sub_type)}\n"
                f"ðŸ“… Muddati: {days} kun",
                parse_mode=ParseMode.HTML
            )
        except Exception:
            pass
    else:
        await callback.message.edit_text(
            "âŒ <b>Xatolik yuz berdi!</b>",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
    
    await callback.answer()

@router.callback_query(F.data == "admin_remove_premium")
async def handle_admin_remove_premium_menu(callback: CallbackQuery, state: FSMContext):
    """Admin: Premium olish menyusi"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "âŒ <b>PREMIUM OLISH</b>\n\n"
        "Premium olish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users")
    )
    await state.set_state(AdminStates.waiting_user_id_for_remove_premium)
    await callback.answer("âœ… Premium olish rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_remove_premium)
async def handle_admin_remove_premium_user_id(message: Message, state: FSMContext):
    """Admin: Premium olish - foydalanuvchi ID"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        target_user_id = int(message.text.strip())
        target_user = await db.get_user(target_user_id)
        
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        current_sub = target_user.get('subscription_type', 0)
        if current_sub == 0:
            await message.answer(
                f"âŒ <b>Bu foydalanuvchida Premium yo'q!</b>\n\n"
                f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
                f"ðŸ‘‘ <b>Status:</b> Standard",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # Premium olish
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE users 
                SET subscription_type = 0, subscription_end = NULL
                WHERE user_id = ?
            ''', (target_user_id,))
            await conn.commit()
        
        await message.answer(
            f"âœ… <b>Premium olindi!</b>\n\n"
            f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}\n"
            f"ðŸ‘‘ <b>Eski status:</b> {DatabaseManager.get_subscription_name(current_sub)}\n\n"
            f"Premium obuna bekor qilindi.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        
        # Foydalanuvchiga xabar
        try:
            await bot.send_message(
                target_user_id,
                f"âŒ <b>DIQQAT!</b>\n\n"
                f"Sizning Premium obunangiz bekor qilindi.\n\n"
                f"Savollar bo'lsa, support ga murojaat qiling.",
                parse_mode=ParseMode.HTML
            )
        except Exception:
            pass
        
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.callback_query(F.data.startswith("admin_remove_premium_"))
async def handle_admin_remove_premium(callback: CallbackQuery):
    """Admin: Premium olish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_user_id = int(callback.data.replace("admin_remove_premium_", ""))
    target_user = await db.get_user(target_user_id)
    
    if not target_user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    # Premium olish
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE users 
            SET subscription_type = 0, subscription_end = NULL
            WHERE user_id = ?
        ''', (target_user_id,))
        await conn.commit()
    
    await callback.message.edit_text(
        f"âœ… <b>Premium olindi!</b>\n\n"
        f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
        f"ðŸ†” <b>ID:</b> {target_user_id}\n\n"
        f"Premium obuna bekor qilindi.",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    
    # Foydalanuvchiga xabar
    try:
        await bot.send_message(
            target_user_id,
            f"âŒ <b>DIQQAT!</b>\n\n"
            f"Sizning Premium obunangiz bekor qilindi.\n\n"
            f"Savollar bo'lsa, support ga murojaat qiling.",
            parse_mode=ParseMode.HTML
        )
    except Exception:
        pass
    
    await callback.answer("âœ… Premium olindi!")

@router.callback_query(F.data == "admin_ban_user")
async def handle_admin_ban_user(callback: CallbackQuery, state: FSMContext):
    """Admin: Bloklash (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "â›” <b>FOYDALANUVCHINI BLOKLASH</b>\n\n"
        "Bloklash uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_id_for_ban)
    await callback.answer("âœ… Bloklash rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_ban)
async def handle_admin_ban_user_id(message: Message, state: FSMContext):
    """Admin: Foydalanuvchini bloklash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        target_user_id = int(message.text.strip())
        
        # O'zini bloklashni oldini olish
        if target_user_id == user_id:
            await message.answer(
                "âŒ <b>Xatolik!</b>\n\n"
                "O'zingizni bloklab bo'lmaydi!",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        target_user = await db.get_user(target_user_id)
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # Bloklash sababini so'rash
        await state.update_data(target_user_id=target_user_id)
        await message.answer(
            f"â›” <b>BLOKLASH</b>\n\n"
            f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}\n\n"
            f"Bloklash sababini yozing:",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_ban_reason)
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.message(AdminStates.waiting_ban_reason)
async def handle_admin_ban_reason(message: Message, state: FSMContext):
    """Admin: Bloklash sababini qabul qilish va bloklash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    target_user_id = data.get('target_user_id')
    ban_reason = message.text.strip() or "Sabab ko'rsatilmagan"
    
    # Bloklash
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE users 
            SET is_banned = 1, ban_reason = ?, ban_end = NULL
            WHERE user_id = ?
        ''', (ban_reason, target_user_id))
        await conn.commit()
    
    target_user = await db.get_user(target_user_id)
    
    await message.answer(
        f"âœ… <b>Foydalanuvchi bloklandi!</b>\n\n"
        f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
        f"ðŸ†” <b>ID:</b> {target_user_id}\n"
        f"ðŸ“ <b>Sabab:</b> {ban_reason}",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    
    # Foydalanuvchiga xabar
    try:
        await bot.send_message(
            target_user_id,
            f"â›” <b>DIQQAT!</b>\n\n"
            f"Sizning akkauntingiz bloklandi.\n"
            f"ðŸ“ <b>Sabab:</b> {ban_reason}\n\n"
            f"Savollar bo'lsa, support ga murojaat qiling.",
            parse_mode=ParseMode.HTML
        )
    except Exception:
        pass
    
    await state.clear()

@router.callback_query(F.data == "admin_unban_user")
async def handle_admin_unban_user_menu(callback: CallbackQuery, state: FSMContext):
    """Admin: Blokdan chiqarish menyusi"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "âœ… <b>BLOKDAN CHIQARISH</b>\n\n"
        "Blokdan chiqarish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users")
    )
    await state.set_state(AdminStates.waiting_user_id_for_unban)
    await callback.answer("âœ… Blokdan chiqarish rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_unban)
async def handle_admin_unban_user_id(message: Message, state: FSMContext):
    """Admin: Blokdan chiqarish - foydalanuvchi ID"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Blokdan chiqarish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    try:
        target_user_id = int(message.text.strip())
        target_user = await db.get_user(target_user_id)
        
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # Blokdan chiqarish
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE users 
                SET is_banned = 0, ban_reason = NULL, ban_end = NULL
                WHERE user_id = ?
            ''', (target_user_id,))
            await conn.commit()
        
        await message.answer(
            f"âœ… <b>Foydalanuvchi blokdan chiqarildi!</b>\n\n"
            f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.callback_query(F.data.startswith("admin_unban_"))
async def handle_admin_unban_user(callback: CallbackQuery):
    """Admin: Blokdan chiqarish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_user_id = int(callback.data.replace("admin_unban_", ""))
    
    async with db.connect() as conn:
        await conn.execute('DELETE FROM banned_users WHERE user_id = ?', (target_user_id,))
        await conn.commit()
    
    await callback.message.edit_text(
        f"âœ… <b>Blokdan chiqarildi!</b>\n\n"
        f"ðŸ‘¤ ID: {target_user_id}",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "admin_send_message")
async def handle_admin_send_message(callback: CallbackQuery, state: FSMContext):
    """Admin: Xabar yuborish (professional va tizimli)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ“ <b>XABAR YUBORISH</b>\n\n"
        "Xabar yuborish uchun foydalanuvchi ID ni yozing:",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_user_id_for_message)
    await callback.answer("âœ… Xabar yuborish rejimi yoqildi!")

@router.message(AdminStates.waiting_user_id_for_message)
async def handle_admin_send_message_user(message: Message, state: FSMContext):
    """Admin: Xabar yuborish - foydalanuvchi ID"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    try:
        target_user_id = int(message.text.strip())
        target_user = await db.get_user(target_user_id)
        
        if not target_user:
            await message.answer(
                f"âŒ <b>Foydalanuvchi topilmadi!</b>\n\n"
                f"ID: <code>{target_user_id}</code>",
                reply_markup=Keyboards.back_button("admin_users"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        await state.update_data(target_user_id=target_user_id)
        await message.answer(
            f"âœ… <b>Foydalanuvchi topildi!</b>\n\n"
            f"ðŸ‘¤ <b>Ism:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}\n\n"
            f"Yubormoqchi bo'lgan xabarni yozing:",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_message_text)
    except ValueError:
        await message.answer(
            "âŒ <b>Noto'g'ri ID!</b>\n\n"
            "Foydalanuvchi ID raqam bo'lishi kerak.",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()

@router.message(AdminStates.waiting_message_text)
async def handle_admin_send_message_text(message: Message, state: FSMContext):
    """Admin: Xabar matnini qabul qilish va yuborish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    target_user_id = data.get('target_user_id')
    message_text = message.text or message.caption or ""
    
    if not message_text:
        await message.answer(
            "âŒ <b>Xabar matni bo'sh!</b>\n\n"
            "Xabar matnini yozing:",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
        return
    
    target_user = await db.get_user(target_user_id)
    
    # Xabarni yuborish
    try:
        if message.photo:
            await bot.send_photo(
                target_user_id,
                message.photo[-1].file_id,
                caption=message_text,
                parse_mode=ParseMode.HTML
            )
        elif message.video:
            await bot.send_video(
                target_user_id,
                message.video.file_id,
                caption=message_text,
                parse_mode=ParseMode.HTML
            )
        elif message.document:
            await bot.send_document(
                target_user_id,
                message.document.file_id,
                caption=message_text,
                parse_mode=ParseMode.HTML
            )
        else:
            await bot.send_message(
                target_user_id,
                f"ðŸ“¨ <b>Admin xabari</b>\n\n{message_text}",
                parse_mode=ParseMode.HTML
            )
        
        await message.answer(
            f"âœ… <b>Xabar yuborildi!</b>\n\n"
            f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
            f"ðŸ†” <b>ID:</b> {target_user_id}",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        await message.answer(
            f"âŒ <b>Xabar yuborilmadi!</b>\n\n"
            f"Xatolik: {str(e)}",
            reply_markup=Keyboards.back_button("admin_users"),
            parse_mode=ParseMode.HTML
        )
    
    await state.clear()

@router.callback_query(F.data.startswith("admin_send_message_"))
async def handle_admin_send_message_direct(callback: CallbackQuery, state: FSMContext):
    """Admin: Xabar yuborish (to'g'ridan-to'g'ri)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    target_user_id = int(callback.data.replace("admin_send_message_", ""))
    target_user = await db.get_user(target_user_id)
    
    if not target_user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    await state.update_data(target_user_id=target_user_id)
    await callback.message.edit_text(
        f"ðŸ“ <b>XABAR YUBORISH</b>\n\n"
        f"ðŸ‘¤ <b>Foydalanuvchi:</b> {target_user.get('full_name', 'Noma\'lum')}\n"
        f"ðŸ†” <b>ID:</b> {target_user_id}\n\n"
        f"Yubormoqchi bo'lgan xabarni yozing:",
        reply_markup=Keyboards.back_button("admin_users"),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_message_text)
    await callback.answer()

@router.callback_query(F.data == "main_menu")
async def handle_main_menu(callback: CallbackQuery):
    """Asosiy menyuga qaytish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi!")
        return
    
    try:
        await safe_edit_text(callback,
            "ðŸ  <b>Asosiy menyu</b>\n\nQuyidagi bo'limlardan birini tanlang:",
            reply_markup=Keyboards.main_menu(user_id)
        )
    except Exception:
        # Agar edit qilishda xatolik bo'lsa, yangi xabar yuboramiz
        await callback.message.answer(
            "ðŸ  <b>Asosiy menyu</b>\n\nQuyidagi bo'limlardan birini tanlang:",
            reply_markup=Keyboards.main_menu(user_id),
            parse_mode=ParseMode.HTML
        )
    await callback.answer()

@router.callback_query(F.data == "library_menu")
async def handle_library_menu(callback: CallbackQuery):
    """Kutubxona menyusi (Premium funksiyalar bilan)"""
    await callback.answer()
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    subscription_type = user.get('subscription_type', 0) if user else 0
    
    await callback.message.edit_text(
        "ðŸ“š <b>Kutubxona</b>\n\nBo'limlardan birini tanlang:",
        reply_markup=Keyboards.library_menu(subscription_type),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data == "premium_books")
async def handle_premium_books(callback: CallbackQuery):
    """Premium kitoblar (Premium foydalanuvchilar uchun)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Premium tekshiruvi
    if subscription_type < 2:
        await callback.answer(
            "âŒ Bu bo'lim faqat Premium foydalanuvchilar uchun!\n\n"
            "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    premium_books = await db.get_premium_books(limit=50)
    
    if not premium_books:
        await callback.message.edit_text(
            "ðŸ’Ž <b>PREMIUM KITOÐ‘LAR</b>\n\n"
            "âŒ Hozircha Premium kitoblar mavjud emas.\n\n"
            "ðŸ“¤ Premium kitob yuklash uchun admin bilan bog'laning.",
            reply_markup=Keyboards.back_button("library_menu"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    text = f"ðŸ’Ž <b>PREMIUM KITOÐ‘LAR</b>\n\n"
    text += f"ðŸ“Š Jami: {len(premium_books)} ta Premium kitob\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, book in enumerate(premium_books[:20], 1):
        book_title = book.get('caption', 'Nomsiz')[:35] + "..." if len(book.get('caption', '')) > 35 else book.get('caption', 'Nomsiz')
        text += f"{i}. <b>{book_title}</b>\n"
        if book.get('author'):
            text += f"   ðŸ‘¤ {book.get('author')}\n"
        if book.get('code'):
            text += f"   ðŸ“– Kod: <code>{book.get('code')}</code>\n"
        text += "\n"
        
        if book.get('code'):
            builder.button(text=f"ðŸ“¥ {i}. {book_title[:25]}", callback_data=f"download_book_{book.get('code')}")
    
    if len(premium_books) > 20:
        text += f"\n... va yana {len(premium_books) - 20} ta Premium kitob\n"
    
    builder.button(text="Kutubxona", callback_data="library_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(premium_books) <= 10:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "audio_books")
async def handle_audio_books(callback: CallbackQuery):
    """Audio kitoblar (Premium foydalanuvchilar uchun)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Premium tekshiruvi
    if subscription_type < 2:
        await callback.answer(
            "âŒ Bu bo'lim faqat Premium foydalanuvchilar uchun!\n\n"
            "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    audio_books = await db.get_audio_books(is_premium=None, limit=50)
    
    if not audio_books:
        await callback.message.edit_text(
            "ðŸŽµ <b>AUDIO KITOÐ‘LAR</b>\n\n"
            "âŒ Hozircha audio kitoblar mavjud emas.\n\n"
            "ðŸ“¤ Audio kitob yuklash uchun admin bilan bog'laning.",
            reply_markup=Keyboards.back_button("library_menu"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    # Audio kitoblarni book_code bo'yicha guruhlash
    books_dict = {}
    for audio in audio_books:
        book_code = audio.get('book_code', 'UNKNOWN')
        if book_code not in books_dict:
            books_dict[book_code] = []
        books_dict[book_code].append(audio)
    
    text = f"ðŸŽµ <b>AUDIO KITOÐ‘LAR</b>\n\n"
    text += f"ðŸ“Š Jami: {len(books_dict)} ta audio kitob\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, (book_code, audios) in enumerate(list(books_dict.items())[:20], 1):
        audio_count = len(audios)
        book_name = audios[0].get('file_name', f'Audio {book_code}')[:35] + "..." if len(audios[0].get('file_name', '')) > 35 else audios[0].get('file_name', f'Audio {book_code}')
        text += f"{i}. <b>{book_name}</b>\n"
        text += f"   ðŸŽµ {audio_count} ta audio fayl\n"
        text += f"   ðŸ“– Kod: <code>{book_code}</code>\n\n"
        
        builder.button(text=f"ðŸŽµ {i}. {book_name[:25]}", callback_data=f"view_audio_book_{book_code}")
    
    if len(books_dict) > 20:
        text += f"\n... va yana {len(books_dict) - 20} ta audio kitob\n"
    
    builder.button(text="Kutubxona", callback_data="library_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(books_dict) <= 10:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.startswith("view_audio_book_"))
async def handle_view_audio_book(callback: CallbackQuery):
    """Audio kitobni ko'rish va yuklab olish"""
    book_code = callback.data.replace("view_audio_book_", "")
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Premium tekshiruvi
    if subscription_type < 2:
        await callback.answer("âŒ Bu bo'lim faqat Premium foydalanuvchilar uchun!", show_alert=True)
        return
    
    audio_files = await db.get_audio_books(book_code=book_code, limit=100)
    
    if not audio_files:
        await callback.answer("âŒ Audio kitob topilmadi!", show_alert=True)
        return
    
    text = f"ðŸŽµ <b>AUDIO KITOÐ‘: {book_code}</b>\n\n"
    text += f"ðŸ“Š Jami {len(audio_files)} ta audio fayl\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, audio in enumerate(audio_files, 1):
        file_name = audio.get('file_name', f'Audio {i}')
        text += f"{i}. {file_name}\n"
        
        builder.button(text=f"ðŸŽµ {i}. {file_name[:30]}", callback_data=f"download_audio_{audio.get('id', 0)}")
    
    builder.button(text="ðŸ”™ Audio kitoblar", callback_data="audio_books")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    if len(audio_files) <= 10:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.startswith("download_audio_"))
async def handle_download_audio(callback: CallbackQuery):
    """Audio kitobni yuklab olish"""
    audio_id = int(callback.data.replace("download_audio_", ""))
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    
    # Audio faylni olish
    async with db.connect() as conn:
        cursor = await conn.execute('SELECT * FROM book_audios WHERE id = ? AND is_active = 1', (audio_id,))
        row = await cursor.fetchone()
        if not row:
            await callback.answer("âŒ Audio fayl topilmadi!", show_alert=True)
            return
        
        audio = dict(row)
        
        # Premium audio fayl tekshiruvi
        is_premium_audio = audio.get('is_premium', 0)
        if is_premium_audio and subscription_type < 2:
            await callback.answer(
                "âŒ Bu audio kitob faqat Premium foydalanuvchilar uchun!\n\n"
                "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
                show_alert=True
            )
            return
        
        file_id = audio.get('file_id')
        file_name = audio.get('file_name', 'Audio')
    
    if not file_id:
        await callback.answer("âŒ File ID topilmadi!", show_alert=True)
        return
    
    try:
        await bot.send_audio(
            chat_id=callback.from_user.id,
            audio=file_id,
            caption=f"ðŸŽµ {file_name}\nðŸ“– Kod: {audio.get('book_code', 'N/A')}"
        )
        await callback.answer("âœ… Audio kitob yuborildi!")
    except Exception as e:
        logger.error(f"Download audio error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data == "search_books")
async def handle_search_books(callback: CallbackQuery, state: FSMContext):
    """Kitob qidirish"""
    await callback.answer()
    await callback.message.edit_text("ðŸ” <b>Kitob qidirish</b>\n\nKitob nomini yoki muallifini yozing:", parse_mode=ParseMode.HTML)
    await state.set_state(UserStates.waiting_book_upload)  # Reuse state

@router.message(UserStates.waiting_book_upload)
async def handle_search_query(message: Message, state: FSMContext):
    """Qidiruv natijalari (YUKLAB OLISH FUNKSIYASI BILAN)"""
    query = message.text.strip()
    
    if query == "/cancel":
        await state.clear()
        await message.answer("âŒ Qidiruv bekor qilindi.", reply_markup=Keyboards.main_menu(message.from_user.id))
        return
    
    if len(query) < 2:
        await message.answer("âŒ Qidiruv so'zi juda qisqa! Kamida 2 belgi bo'lishi kerak.")
        return
    
    books = await db.search_books(query, limit=100)  # Barcha natijalarni olish
    
    # Pagination - 10 tadan ko'rsatish
    page = 0
    items_per_page = 10
    total_pages = (len(books) + items_per_page - 1) // items_per_page if books else 0
    
    if books:
        text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
        text += f"ðŸ“Š Topilgan: {len(books)} ta\n"
        text += f"ðŸ“„ Sahifa: {page + 1}/{total_pages}\n\n"
        
        # Faqat joriy sahifadagi natijalarni ko'rsatish
        start_idx = page * items_per_page
        end_idx = start_idx + items_per_page
        current_books = books[start_idx:end_idx]
        
        builder = InlineKeyboardBuilder()
        for i, book in enumerate(current_books, start_idx + 1):
            book_title = book.get('caption', 'Nomsiz')[:40] + "..." if len(book.get('caption', '')) > 40 else book.get('caption', 'Nomsiz')
            text += f"{i}. <b>{book_title}</b>\n"
            if book.get('author'):
                text += f"   ðŸ‘¤ {book.get('author')}\n"
            if book.get('code'):
                text += f"   ðŸ“– Kod: <code>{book.get('code')}</code>\n"
            text += "\n"
            
            # Har bir kitob uchun yuklab olish tugmasi
            if book.get('code'):
                builder.button(text=f"ðŸ“¥ {book_title[:25]}", callback_data=f"download_book_{book.get('code')}")
        
        # Pagination tugmalari
        if total_pages > 1:
            pagination_buttons = []
            if page > 0:
                pagination_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Orqaga", callback_data=f"search_page_books_{page - 1}"))
            if page < total_pages - 1:
                pagination_buttons.append(InlineKeyboardButton(text="âž¡ï¸ Keyingi", callback_data=f"search_page_books_{page + 1}"))
            if pagination_buttons:
                builder.row(*pagination_buttons)
        
        # State'ga saqlash
        await state.update_data(
            search_query=query,
            search_results=books,
            search_type="books",
            current_page=page
        )
        
        builder.button(text="ðŸ” Qayta qidirish", callback_data="search_books")
        builder.button(text="ðŸ”™ Kutubxona", callback_data="library_menu")
        builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
        
        if len(current_books) <= 5:
            builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
        else:
            builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
        
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    else:
        await message.answer(
            f"âŒ '{query}' bo'yicha kitob topilmadi.\n\n"
            "ðŸ’¡ <b>Maslahat:</b>\n"
            "â€¢ Kitob nomini to'liq yozing\n"
            "â€¢ Muallif nomini yozib ko'ring\n"
            "â€¢ Kitob kodini yozib ko'ring",
            reply_markup=Keyboards.back_button("library_menu"),
            parse_mode=ParseMode.HTML
        )
    
    await state.clear()

# ========== PAGINATION HANDLERS - QIDIRUV NATIJALARI ==========

@router.callback_query(F.data.startswith("search_page_books_"))
async def handle_search_page_books(callback: CallbackQuery, state: FSMContext):
    """Kitoblar qidiruv pagination"""
    user_id = callback.from_user.id
    page = int(callback.data.replace("search_page_books_", ""))
    
    data = await state.get_data()
    query = data.get('search_query', '')
    books = data.get('search_results', [])
    
    if not books:
        await callback.answer("âŒ Qidiruv natijalari topilmadi!")
        return
    
    items_per_page = 10
    total_pages = (len(books) + items_per_page - 1) // items_per_page
    
    if page < 0 or page >= total_pages:
        await callback.answer("âŒ Noto'g'ri sahifa!")
        return
    
    await state.update_data(current_page=page)
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(books)} ta\n"
    text += f"ðŸ“„ Sahifa: {page + 1}/{total_pages}\n\n"
    
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_books = books[start_idx:end_idx]
    
    for i, book in enumerate(current_books, start_idx + 1):
        book_title = book.get('caption', 'Nomsiz')[:40] + "..." if len(book.get('caption', '')) > 40 else book.get('caption', 'Nomsiz')
        text += f"{i}. <b>{book_title}</b>\n"
        if book.get('author'):
            text += f"   ðŸ‘¤ {book.get('author')}\n"
        if book.get('code'):
            text += f"   ðŸ“– Kod: <code>{book.get('code')}</code>\n"
        text += "\n"
    
    builder = InlineKeyboardBuilder()
    for book in current_books:
        book_title = book.get('caption', 'Nomsiz')[:25]
        if book.get('code'):
            builder.button(text=f"ðŸ“¥ {book_title}", callback_data=f"download_book_{book.get('code')}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_buttons = []
        if page > 0:
            pagination_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Orqaga", callback_data=f"search_page_books_{page - 1}"))
        if page < total_pages - 1:
            pagination_buttons.append(InlineKeyboardButton(text="âž¡ï¸ Keyingi", callback_data=f"search_page_books_{page + 1}"))
        if pagination_buttons:
            builder.row(*pagination_buttons)
    
    builder.button(text="ðŸ” Qayta qidirish", callback_data="search_books")
    builder.button(text="Kutubxona", callback_data="library_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(current_books) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("search_page_courses_"))
async def handle_search_page_courses(callback: CallbackQuery, state: FSMContext):
    """Kurslar qidiruv pagination"""
    user_id = callback.from_user.id
    page = int(callback.data.replace("search_page_courses_", ""))
    
    data = await state.get_data()
    query = data.get('search_query', '')
    courses = data.get('search_results', [])
    
    if not courses:
        await callback.answer("âŒ Qidiruv natijalari topilmadi!")
        return
    
    items_per_page = 10
    total_pages = (len(courses) + items_per_page - 1) // items_per_page
    
    if page < 0 or page >= total_pages:
        await callback.answer("âŒ Noto'g'ri sahifa!")
        return
    
    await state.update_data(current_page=page)
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(courses)} ta\n"
    text += f"ðŸ“„ Sahifa: {page + 1}/{total_pages}\n\n"
    
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_courses = courses[start_idx:end_idx]
    
    for i, course in enumerate(current_courses, start_idx + 1):
        course_title = course.get('title', 'Nomsiz')[:40] + "..." if len(course.get('title', '')) > 40 else course.get('title', 'Nomsiz')
        text += f"{i}. <b>{course_title}</b>\n"
        if course.get('instructor'):
            text += f"   ðŸ‘¨â€ðŸ« {course.get('instructor')}\n"
        if course.get('price'):
            text += f"   ðŸ’° {course.get('price', 19990):,} so'm\n"
        text += "\n"
    
    builder = InlineKeyboardBuilder()
    for course in current_courses:
        course_title = course.get('title', 'Nomsiz')[:25]
        builder.button(text=f"ðŸ“š {course_title}", callback_data=f"view_course_{course.get('id')}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_buttons = []
        if page > 0:
            pagination_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Orqaga", callback_data=f"search_page_courses_{page - 1}"))
        if page < total_pages - 1:
            pagination_buttons.append(InlineKeyboardButton(text="âž¡ï¸ Keyingi", callback_data=f"search_page_courses_{page + 1}"))
        if pagination_buttons:
            builder.row(*pagination_buttons)
    
    builder.button(text="ðŸ” Qayta qidirish", callback_data="search_courses")
    builder.button(text="Kurslar", callback_data="courses_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    
    if len(current_courses) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("view_book_"))
async def handle_view_book(callback: CallbackQuery):
    """Kitobni ko'rish"""
    user_id = callback.from_user.id
    book_code = callback.data.replace("view_book_", "")
    
    book = await db.get_book(book_code)
    if not book:
        await callback.answer("âŒ Kitob topilmadi!", show_alert=True)
        return
    
    # Favoritelarni tekshirish
    is_favorite = False
    try:
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT 1 FROM favorites 
                WHERE user_id = ? AND item_type = 'book' AND item_id = ?
            ''', (user_id, book_code))
            is_favorite = await cursor.fetchone() is not None
    except:
        pass
    
    book_text = (
        f"ðŸ“– <b>{book.get('caption', 'Noma\'lum kitob')}</b>\n\n"
        f"ðŸ‘¤ <b>Muallif:</b> {book.get('author', 'Noma\'lum')}\n"
        f"ðŸ“š <b>Janr:</b> {book.get('genre', 'Noma\'lum')}\n"
        f"ðŸ“Š <b>Yuklashlar:</b> {book.get('downloads', 0)}\n"
        f"â­ <b>Reyting:</b> {book.get('rating', 0):.1f}/5.0 ({book.get('rating_count', 0)} ta baholash)\n\n"
    )
    
    if book.get('description'):
        book_text += f"ðŸ“ {book.get('description', '')[:300]}...\n\n"
    
    await safe_edit_text(callback, book_text, 
        reply_markup=Keyboards.book_actions(book_code, is_favorite=is_favorite, can_download=True))
    await callback.answer()

@router.callback_query(F.data.startswith("add_favorite_book_"))
async def handle_add_favorite_book(callback: CallbackQuery):
    """Kitobni favoritelarga qo'shish"""
    user_id = callback.from_user.id
    book_code = callback.data.replace("add_favorite_book_", "")
    
    book = await db.get_book(book_code)
    if not book:
        await callback.answer("âŒ Kitob topilmadi!", show_alert=True)
        return
    
    # Favoritelarga qo'shish
    try:
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT * FROM favorites 
                WHERE user_id = ? AND item_type = 'book' AND item_id = ?
            ''', (user_id, book_code))
            existing = await cursor.fetchone()
            
            if existing:
                await callback.answer("âŒ Bu kitob allaqachon favoritelarda!", show_alert=True)
                return
            
            await conn.execute('''
                INSERT INTO favorites (user_id, item_type, item_id, item_name)
                VALUES (?, 'book', ?, ?)
            ''', (user_id, book_code, book.get('caption', 'Kitob')))
            await conn.commit()
        
        await callback.answer("âœ… Kitob favoritelarga qo'shildi!")
        
        # Kitob sahifasini yangilash
        book = await db.get_book(book_code)
        if book:
            book_text = (
                f"ðŸ“– <b>{book.get('caption', 'Noma\'lum kitob')}</b>\n\n"
                f"ðŸ‘¤ <b>Muallif:</b> {book.get('author', 'Noma\'lum')}\n"
                f"ðŸ“š <b>Janr:</b> {book.get('genre', 'Noma\'lum')}\n"
                f"ðŸ“Š <b>Yuklashlar:</b> {book.get('downloads', 0)}\n"
                f"â­ <b>Reyting:</b> {book.get('rating', 0):.1f}/5.0 ({book.get('rating_count', 0)} ta baholash)\n\n"
            )
            
            if book.get('description'):
                book_text += f"ðŸ“ {book.get('description', '')[:300]}...\n\n"
            
            await safe_edit_text(callback, book_text, 
                reply_markup=Keyboards.book_actions(book_code, is_favorite=True, can_download=True))
    except Exception as e:
        logger.error(f"Add favorite error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data.startswith("remove_favorite_book_"))
async def handle_remove_favorite_book(callback: CallbackQuery):
    """Kitobni favoritelardan olib tashlash"""
    user_id = callback.from_user.id
    book_code = callback.data.replace("remove_favorite_book_", "")
    
    book = await db.get_book(book_code)
    if not book:
        await callback.answer("âŒ Kitob topilmadi!", show_alert=True)
        return
    
    # Favoritelardan olib tashlash
    try:
        async with db.connect() as conn:
            await conn.execute('''
                DELETE FROM favorites 
                WHERE user_id = ? AND item_type = 'book' AND item_id = ?
            ''', (user_id, book_code))
            await conn.commit()
        
        await callback.answer("âœ… Kitob favoritelardan olib tashlandi!")
        
        # Kitob sahifasini yangilash
        book = await db.get_book(book_code)
        if book:
            book_text = (
                f"ðŸ“– <b>{book.get('caption', 'Noma\'lum kitob')}</b>\n\n"
                f"ðŸ‘¤ <b>Muallif:</b> {book.get('author', 'Noma\'lum')}\n"
                f"ðŸ“š <b>Janr:</b> {book.get('genre', 'Noma\'lum')}\n"
                f"ðŸ“Š <b>Yuklashlar:</b> {book.get('downloads', 0)}\n"
                f"â­ <b>Reyting:</b> {book.get('rating', 0):.1f}/5.0 ({book.get('rating_count', 0)} ta baholash)\n\n"
            )
            
            if book.get('description'):
                book_text += f"ðŸ“ {book.get('description', '')[:300]}...\n\n"
            
            await safe_edit_text(callback, book_text, 
                reply_markup=Keyboards.book_actions(book_code, is_favorite=False, can_download=True))
    except Exception as e:
        logger.error(f"Remove favorite error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data.startswith("review_book_"))
async def handle_review_book(callback: CallbackQuery, state: FSMContext):
    """Kitobga sharh qoldirish"""
    user_id = callback.from_user.id
    book_code = callback.data.replace("review_book_", "")
    
    book = await db.get_book(book_code)
    if not book:
        await callback.answer("âŒ Kitob topilmadi!", show_alert=True)
        return
    
    await state.update_data(review_book_code=book_code)
    
    await safe_edit_text(callback,
        f"â­ <b>SHARH QOLDIRISH</b>\n\n"
        f"ðŸ“– <b>{book.get('caption', 'Noma\'lum kitob')}</b>\n\n"
        f"ðŸ“ <b>Sharhingizni yozing:</b>\n\n"
        f"âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(UserStates.waiting_review_text)
    await callback.answer()

@router.message(UserStates.waiting_review_text)
async def handle_review_text(message: Message, state: FSMContext):
    """Sharh matnini qabul qilish"""
    user_id = message.from_user.id
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Sharh qoldirish bekor qilindi.")
        return
    
    review_text = message.text.strip()
    if len(review_text) < 10:
        await message.answer("âŒ Sharh kamida 10 ta belgidan iborat bo'lishi kerak!")
        return
    
    data = await state.get_data()
    book_code = data.get('review_book_code')
    
    if not book_code:
        await state.clear()
        await message.answer("âŒ Xatolik yuz berdi!")
        return
    
    # Sharhni saqlash
    try:
        async with db.connect() as conn:
            await conn.execute('''
                INSERT INTO reviews (user_id, item_type, item_id, comment, rating)
                VALUES (?, 'book', ?, ?, 0)
            ''', (user_id, book_code, review_text))
            await conn.commit()
        
        await message.answer(
            f"âœ… <b>Sharh muvaffaqiyatli qo'shildi!</b>\n\n"
            f"ðŸ“– <b>Kitob:</b> {book_code}\n"
            f"ðŸ“ <b>Sharh:</b> {review_text[:100]}...\n\n"
            f"ðŸ’¡ Sharhingiz boshqa foydalanuvchilar tomonidan ko'rinadi.",
            reply_markup=Keyboards.back_button(f"view_book_{book_code}"),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Review save error: {e}")
        await message.answer("âŒ Xatolik yuz berdi!")
    
    await state.clear()

@router.callback_query(F.data == "random_book")
async def handle_random_book(callback: CallbackQuery):
    """Tasodifiy kitob"""
    await callback.answer()
    books = await db.get_random_books(limit=1)
    
    if books:
        book = books[0]
        book_code = book.get('code', '')
        text = f"""
ðŸ“š <b>{book.get('caption', 'Nomsiz')}</b>

ðŸ‘¤ Muallif: {book.get('author', 'Noma\'lum')}
ðŸ“‚ Janr: {book.get('genre', 'Boshqa')}
â­ Reyting: {book.get('rating', 0):.1f}/5.0 ({book.get('rating_count', 0)} ta baholash)
ðŸ“Š Yuklashlar: {book.get('downloads', 0)}
        """
        if book.get('description'):
            text += f"\nðŸ“ {book.get('description', '')[:200]}..."
        await callback.message.edit_text(text, reply_markup=Keyboards.book_actions(book_code, can_download=True), parse_mode=ParseMode.HTML)
    else:
        await callback.message.edit_text("âŒ Kitob topilmadi.")

@router.callback_query(F.data.startswith("rate_book_"))
async def handle_rate_book(callback: CallbackQuery):
    """Kitobni baholash"""
    user_id = callback.from_user.id
    book_code = callback.data.replace("rate_book_", "")
    
    book = await db.get_book(book_code)
    if not book:
        await callback.answer("âŒ Kitob topilmadi!")
        return
    
    # Baholash tugmalarini ko'rsatish
    builder = InlineKeyboardBuilder()
    for i in range(1, 6):
        builder.button(text=f"{'â­' * i}", callback_data=f"set_rating_{book_code}_{i}")
    builder.button(text="ðŸ”™ Orqaga", callback_data=f"view_book_{book_code}")
    builder.adjust(1, 1, 1, 1, 1, 1)
    
    await callback.message.edit_text(
        f"â­ <b>KITOBNI BAHOLASH</b>\n\n"
        f"ðŸ“– <b>{book.get('caption', 'Noma\'lum kitob')}</b>\n\n"
        f"Baholashni tanlang (1-5 yulduz):",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data.startswith("set_rating_"))
async def handle_set_rating(callback: CallbackQuery):
    """Baholashni saqlash"""
    user_id = callback.from_user.id
    data_parts = callback.data.replace("set_rating_", "").split("_")
    if len(data_parts) < 2:
        await callback.answer("âŒ Xatolik!")
        return
    
    book_code = "_".join(data_parts[:-1])
    rating = int(data_parts[-1])
    
    if rating < 1 or rating > 5:
        await callback.answer("âŒ Noto'g'ri baholash!")
        return
    
    book = await db.get_book(book_code)
    if not book:
        await callback.answer("âŒ Kitob topilmadi!")
        return
    
    success, message = await db.set_book_rating(user_id, book_code, rating)
    
    if success:
        await callback.answer(f"âœ… {rating} yulduz bilan baholandi!")
        
        # Kitob sahifasiga qaytish
        book = await db.get_book(book_code)
        if book:
            book_text = (
                f"ðŸ“– <b>{book.get('caption', 'Noma\'lum kitob')}</b>\n\n"
                f"ðŸ‘¤ <b>Muallif:</b> {book.get('author', 'Noma\'lum')}\n"
                f"ðŸ“š <b>Janr:</b> {book.get('genre', 'Noma\'lum')}\n"
                f"ðŸ“Š <b>Yuklashlar:</b> {book.get('downloads', 0)}\n"
                f"â­ <b>Reyting:</b> {book.get('rating', 0):.1f}/5.0 ({book.get('rating_count', 0)} ta baholash)\n\n"
            )
            
            if book.get('description'):
                book_text += f"ðŸ“ <b>Tavsif:</b>\n{book.get('description', '')[:500]}\n\n"
            
            await callback.message.edit_text(
                book_text,
                reply_markup=Keyboards.book_actions(book_code, can_download=True),
                parse_mode=ParseMode.HTML
            )
    else:
        await callback.answer("âŒ Baholashda xatolik!")

@router.callback_query(F.data == "my_books")
async def handle_my_books(callback: CallbackQuery):
    """Mening kitoblarim"""
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT b.code, b.caption, b.author, b.genre, b.downloads
            FROM download_history dh
            JOIN books b ON dh.item_type = 'book' AND dh.item_id = b.id
            WHERE dh.user_id = ?
            AND b.is_active = 1
            ORDER BY dh.download_date DESC
            LIMIT 20
        ''', (user_id,))
        books = await cursor.fetchall()
    
    if not books:
        await safe_edit_text(callback,
            "<b>MENING KITOBLARIM</b>\n\n"
            "Hozircha yuklangan kitoblar yo'q.\n\n"
            "Kitoblar yuklaganingizdan keyin bu yerda ko'rinadi.",
            reply_markup=Keyboards.back_button("library_menu")
        )
        await callback.answer()
        return
    
    text = f"<b>MENING KITOBLARIM</b>\n\n"
    text += f"<b>Jami:</b> {len(books)} ta kitob\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, book in enumerate(books[:15], 1):
        book_code = book[0]
        book_title = book[1] or 'Nomsiz'[:40]
        text += f"{i}. {book_title}\n"
        builder.button(text=f"{book_title[:30]}", callback_data=f"view_book_{book_code}")
    
    builder.button(text="Kutubxona", callback_data="library_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "my_favorites")
async def handle_my_favorites(callback: CallbackQuery):
    """Mening sevimlilarim"""
    # favorites handler allaqachon mavjud, lekin my_favorites uchun alohida qilamiz
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT f.item_type, f.item_id, 
                   COALESCE(b.caption, m.caption, c.title, 'Nomalum') as name
            FROM favorites f
            LEFT JOIN books b ON f.item_type = 'book' AND f.item_id = b.id
            LEFT JOIN movies m ON f.item_type = 'movie' AND f.item_id = m.id
            LEFT JOIN courses c ON f.item_type = 'course' AND f.item_id = c.id
            WHERE f.user_id = ?
            ORDER BY f.created_date DESC
            LIMIT 20
        ''', (user_id,))
        favorites = await cursor.fetchall()
    
    if not favorites:
        await safe_edit_text(callback,
            "<b>MENING SEVIMLILARIM</b>\n\n"
            "Hozircha sevimlilar yo'q.\n\n"
            "Kitob, film yoki kursni ochib, 'Sevimlilarga qo'shish' tugmasini bosing.",
            reply_markup=Keyboards.back_button("library_menu")
        )
        await callback.answer()
        return
    
    text = f"<b>MENING SEVIMLILARIM</b>\n\n"
    text += f"<b>Jami:</b> {len(favorites)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, (item_type, item_id, name) in enumerate(favorites[:15], 1):
        text += f"{i}. {name or 'Noma\'lum'}\n"
        if item_type == "book":
            builder.button(text=f"{name[:30]}", callback_data=f"view_book_{item_id}")
        elif item_type == "movie":
            builder.button(text=f"{name[:30]}", callback_data=f"watch_movie_{item_id}")
        elif item_type == "course":
            builder.button(text=f"{name[:30]}", callback_data=f"view_course_{item_id}")
    
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("download_book_"))
async def handle_download_book(callback: CallbackQuery):
    """Kitobni yuklash"""
    await callback.answer("â³ Tekshirilmoqda...")
    
    book_code = callback.data.replace("download_book_", "")
    book = await db.get_book(book_code)
    
    if not book:
        await callback.answer("âŒ Kitob topilmadi!", show_alert=True)
        return
    
    # Premium kitob tekshiruvi
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!", show_alert=True)
        return
    
    subscription_type = user.get('subscription_type', 0)
    is_premium_book = book.get('is_premium', 0)
    
    if is_premium_book and subscription_type < 2:
        await callback.answer(
            "âŒ Bu kitob faqat Premium foydalanuvchilar uchun!\n\n"
            "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    file_id = book.get('file_id')
    if not file_id:
        await callback.answer("âŒ File ID topilmadi!", show_alert=True)
        return
    
    try:
        caption = f"ðŸ“š {book.get('caption', 'Kitob')}\nðŸ‘¤ {book.get('author', 'Noma\'lum')}"
        await bot.send_document(
            chat_id=callback.from_user.id,
            document=file_id,
            caption=caption
        )
        
        # Download history ga yozish (statistika uchun)
        await db.record_download(callback.from_user.id, "book", book.get('id', 0))
        
        # Book downloads tracking ga yozish
        await db.add_book_download(callback.from_user.id, book_code)
        
        # Daily challenge progress tracking
        challenge_result = await db.track_daily_challenge_progress(user_id, 'download_book')
        if challenge_result.get('completed'):
            await bot.send_message(
                user_id,
                f"ðŸŽ¯ <b>KUNLIK CHALLENGE BAJARILDI!</b>\n\n"
                f"ðŸŽ <b>Mukofotlar:</b>\n"
                f"â­ +{challenge_result['xp_reward']} XP\n"
                f"ðŸª™ +{challenge_result['gold_reward']} Gold\n\n"
                f"Ertaga yangi challenge kutadi! ðŸŽ‰",
                parse_mode=ParseMode.HTML
            )
        
        await callback.answer("âœ… Kitob yuborildi!")
    except Exception as e:
        logger.error(f"Download book error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

# Foydalanuvchilar uchun kitob qo'shish funksiyasi o'chirilgan
# Faqat adminlar kitob qo'sha oladi

@router.callback_query(F.data == "admin_add_book")
async def handle_admin_add_book(callback: CallbackQuery, state: FSMContext):
    """Admin: Cheksiz kitob qo'shish (avtomatik saqlash)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸ“š <b>CHEKSIZ KITOB QO'SHISH</b>\n\n"
        "âœ… <b>Qanday ishlaydi:</b>\n"
        "1. Kitob faylini yuboring (PDF, DOC, DOCX, TXT, EPUB)\n"
        "2. Avtomatik ravishda bazaga saqlanadi\n"
        "3. Yana kitob yuborish mumkin (cheksiz)\n"
        "4. Jarayonni to'xtatish uchun /cancel\n\n"
        "ðŸ“Ž <b>Fayl yuborish:</b>\n"
        "Fayl yuboring yoki /cancel tugmasini bosing.",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_add_book_file)
    await callback.answer("âœ… Kitob qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_add_book_file, F.text == "/cancel")
async def handle_admin_cancel_add_book_text(message: Message, state: FSMContext):
    """Admin: Kitob qo'shishni bekor qilish (/cancel)"""
    user_id = message.from_user.id
    
    if not await check_is_admin(user_id, db):
        return
    
    await state.clear()
    await message.answer(
        "âŒ <b>Kitob qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.message(AdminStates.waiting_add_book_file, F.document)
async def handle_admin_book_file(message: Message, state: FSMContext):
    """Admin: Kitob faylini qabul qilish va avtomatik saqlash (cheksiz)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await message.answer("âŒ Siz admin emassiz!")
        await state.clear()
        return
    
    if not message.document:
        await message.answer(
            "âŒ Hujjat topilmadi! Iltimos, PDF, DOC, DOCX, TXT yoki EPUB formatidagi fayl yuboring.\n\n"
            "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
            reply_markup=Keyboards.cancel_button()
        )
        return
    
    file_name = message.document.file_name or "book.pdf"
    file_id = message.document.file_id
    
    # Fayl turini tekshirish
    allowed_types = ['.pdf', '.doc', '.docx', '.txt', '.epub']
    if not any(file_name.lower().endswith(ext) for ext in allowed_types):
        await message.answer(
            "âŒ <b>Noto'g'ri fayl formati!</b>\n\n"
            "Qabul qilinadigan formatlar: PDF, DOC, DOCX, TXT, EPUB\n"
            "Boshqa fayl yuboring yoki /cancel tugmasini bosing.",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
        return
    
    # Caption ni olish va avtomatik tahlil qilish
    caption = message.caption or file_name
    author = ""
    genre = "Boshqa"
    cleaned_caption = file_name
    
    # Avtomatik janr tanlash va matn tozalash
    if UTILS_AVAILABLE:
        try:
            result = auto_detect_and_clean(caption, "book")
            cleaned_caption = result['cleaned_caption'] or file_name
            author = result['author']
            genre = result['genre']
        except Exception as e:
            logger.error(f"Avtomatik tahlil xatosi: {e}")
            # Xatolik bo'lsa, oddiy ishlatish
            cleaned_caption = clean_text(caption) if UTILS_AVAILABLE else caption
            if not cleaned_caption:
                cleaned_caption = file_name
    
    # Janrda " belgisini olib tashlash
    genre = genre.replace('"', '').replace("'", "").strip()
    if not genre or genre == "":
        genre = "Boshqa"
    
    # Kitob kodini tartib raqamlar bilan generatsiya qilish (1, 2, 3, 4...)
    try:
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT MAX(order_number) FROM books WHERE is_active = 1')
            row = await cursor.fetchone()
            max_order = row[0] if row[0] is not None else 0
            next_order = max_order + 1
            book_code = str(next_order)  # Tartib raqami kod sifatida
    except Exception:
        book_code = f"{int(time.time())}"
    
    # Bazaga saqlash
    try:
        success = await db.add_book(book_code, file_id, cleaned_caption, author=author, genre=genre)
        
        if success:
            genre_display = genre if genre != "Boshqa" else "Boshqa (avtomatik aniqlanmadi)"
            author_display = f"\nâœï¸ <b>Muallif:</b> {author}\n" if author else ""
            
            await message.answer(
                f"âœ… <b>Kitob muvaffaqiyatli qo'shildi!</b>\n\n"
                f"ðŸ“š <b>Nomi:</b> {cleaned_caption[:100]}\n"
                f"ðŸ”‘ <b>Kod:</b> {book_code}\n"
                f"ðŸ“‚ <b>Janr:</b> {genre_display}"
                f"{author_display}\n"
                f"Kitob endi bazada mavjud va foydalanuvchilar uni topa oladi!\n\n"
                f"ðŸ’¡ <b>Yana kitob qo'shish uchun fayl yuboring yoki /cancel tugmasini bosing.</b>",
                reply_markup=Keyboards.cancel_button(),
                parse_mode=ParseMode.HTML
            )
            logger.info(f"Admin {user_id} kitob qo'shdi: {book_code}")
        else:
            await message.answer(
                "âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.\n\n"
                "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
                reply_markup=Keyboards.cancel_button()
            )
    except Exception as e:
        logger.error(f"Admin book add error: {e}", exc_info=True)
        await message.answer(
            f"âŒ Xatolik yuz berdi: {str(e)}\n\n"
            "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
            reply_markup=Keyboards.cancel_button()
        )
    
    # State ni tozalamaymiz - cheksiz qo'shish uchun

# ========== ADMIN: JANR BO'YICHA QO'SHISH ==========

@router.callback_query(F.data == "admin_add_books_by_genre")
async def handle_admin_add_books_by_genre(callback: CallbackQuery, state: FSMContext):
    """Admin: Janr bo'yicha kitoblar qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    # Bazadan barcha mavjud janrlarni olish
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT genre, COUNT(*) as count 
            FROM books 
            WHERE is_active = 1 AND genre IS NOT NULL AND genre != ''
            GROUP BY genre
            ORDER BY count DESC
            LIMIT 30
        ''')
        genres = await cursor.fetchall()
    
    if not genres:
        await safe_edit_text(callback,
            "ðŸ“š <b>JANR BO'YICHA KITOBLAR QO'SHISH</b>\n\n"
            "âŒ Hozircha janrlar mavjud emas.\n\n"
            "ðŸ’¡ Avval oddiy kitob qo'shing, keyin janrlar paydo bo'ladi.",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        await callback.answer()
        return
    
    text = "<b>JANR BO'YICHA KITOBLAR QO'SHISH</b>\n\n"
    text += "<b>Janrni tanlang:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for genre_row in genres:
        genre = genre_row[0] or "Boshqa"
        genre_clean = remove_emoji(genre)
        count = genre_row[1] or 0
        text += f"{genre_clean} ({count} ta)\n"  # Textdan emoji olib tashlandi
        builder.button(text=genre_clean, callback_data=f"admin_book_genre_{genre}")  # Button textda emoji yo'q
    
    builder.button(text="âž• Yangi janr", callback_data="admin_new_book_genre")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_new_book_genre")
async def handle_admin_new_book_genre(callback: CallbackQuery, state: FSMContext):
    """Admin: Yangi kitob janri qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ“š <b>YANGI KITOB JANRI QO'SHISH</b>\n\n"
        "ðŸ“ <b>Yangi janr nomini yozing:</b>\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_book_genre_select)
    await callback.answer()

@router.message(AdminStates.waiting_book_genre_select)
async def handle_admin_new_book_genre_name(message: Message, state: FSMContext):
    """Admin: Yangi janr nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Janr qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    genre = message.text.strip()
    await state.update_data(selected_genre=genre, content_type="book")
    
    await message.answer(
        f"âœ… <b>Yangi janr:</b> {genre}\n\n"
        f"ðŸ“Ž <b>Endi bu janrga kitoblar qo'sha olasiz!</b>\n\n"
        f"ðŸ“Ž <b>Kitob faylini yuboring:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_book_genre_file)

@router.callback_query(F.data.startswith("admin_book_genre_"))
async def handle_admin_book_genre_select(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitob janrini tanlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    genre = callback.data.replace("admin_book_genre_", "")
    # Janrda " belgisini olib tashlash
    genre = genre.replace('"', '').replace("'", "").strip()
    if not genre or genre == "":
        genre = "Boshqa"
    await state.update_data(selected_genre=genre, content_type="book")
    
    await safe_edit_text(callback,
        f"ðŸ“š <b>JANR: {genre}</b>\n\n"
        f"âœ… <b>Endi bu janrga cheksiz kitoblar qo'sha olasiz!</b>\n\n"
        f"ðŸ“Ž <b>Kitob faylini yuboring:</b>\n"
        f"Fayl yuboring yoki /cancel tugmasini bosing.",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_book_genre_file)
    await callback.answer()

@router.message(AdminStates.waiting_book_genre_file, F.document)
async def handle_admin_book_genre_file(message: Message, state: FSMContext):
    """Admin: Janr bo'yicha kitob faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    genre = data.get('selected_genre', 'Boshqa')
    
    if not message.document:
        await message.answer("âŒ Hujjat topilmadi!")
        return
    
    file_name = message.document.file_name or "book.pdf"
    file_id = message.document.file_id
    
    allowed_types = ['.pdf', '.doc', '.docx', '.txt', '.epub']
    if not any(file_name.lower().endswith(ext) for ext in allowed_types):
        await message.answer("âŒ Noto'g'ri fayl formati!")
        return
    
    caption = message.caption or file_name
    author = ""
    cleaned_caption = file_name
    
    if UTILS_AVAILABLE:
        try:
            result = auto_detect_and_clean(caption, "book")
            cleaned_caption = result['cleaned_caption'] or file_name
            author = result['author']
        except Exception:
            cleaned_caption = caption
    
    try:
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT MAX(order_number) FROM books WHERE is_active = 1')
            row = await cursor.fetchone()
            max_order = row[0] if row[0] is not None else 0
            next_order = max_order + 1
            book_code = str(next_order)
    except Exception:
        book_code = f"{int(time.time())}"
    
    success = await db.add_book(book_code, file_id, cleaned_caption, author=author, genre=genre)
    
    if success:
        await message.answer(
            f"âœ… <b>Kitob qo'shildi!</b>\n\n"
            f"ðŸ“š <b>Nomi:</b> {cleaned_caption[:100]}\n"
            f"ðŸ“‚ <b>Janr:</b> {genre}\n"
            f"ðŸ”‘ <b>Kod:</b> {book_code}\n\n"
            f"ðŸ’¡ <b>Yana kitob qo'shish uchun fayl yuboring yoki /cancel tugmasini bosing.</b>",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
    else:
        await message.answer("âŒ Xatolik yuz berdi!")

@router.callback_query(F.data == "admin_add_movies_by_genre")
async def handle_admin_add_movies_by_genre(callback: CallbackQuery, state: FSMContext):
    """Admin: Janr bo'yicha filmlar qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT genre, COUNT(*) as count 
            FROM movies 
            WHERE is_active = 1 AND genre IS NOT NULL AND genre != ''
            GROUP BY genre
            ORDER BY count DESC
            LIMIT 30
        ''')
        genres = await cursor.fetchall()
    
    if not genres:
        await safe_edit_text(callback,
            "ðŸŽ¬ <b>JANR BO'YICHA FILMLAR QO'SHISH</b>\n\n"
            "âŒ Hozircha janrlar mavjud emas.\n\n"
            "ðŸ’¡ Avval oddiy film qo'shing, keyin janrlar paydo bo'ladi.",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        await callback.answer()
        return
    
    text = "<b>JANR BO'YICHA FILMLAR QO'SHISH</b>\n\n"
    text += "<b>Janrni tanlang:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for genre_row in genres:
        genre = genre_row[0] or "Boshqa"
        genre_clean = remove_emoji(genre)
        count = genre_row[1] or 0
        text += f"{genre_clean} ({count} ta)\n"  # Textdan emoji olib tashlandi
        builder.button(text=genre_clean, callback_data=f"admin_movie_genre_{genre}")  # Button textda emoji yo'q
    
    builder.button(text="âž• Yangi janr", callback_data="admin_new_movie_genre")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_new_movie_genre")
async def handle_admin_new_movie_genre(callback: CallbackQuery, state: FSMContext):
    """Admin: Yangi film janri qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>YANGI FILM JANRI QO'SHISH</b>\n\n"
        "ðŸ“ <b>Yangi janr nomini yozing:</b>\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_movie_genre_select)
    await callback.answer()

@router.message(AdminStates.waiting_movie_genre_select)
async def handle_admin_new_movie_genre_name(message: Message, state: FSMContext):
    """Admin: Yangi film janri nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Janr qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    genre = message.text.strip()
    # Janrda " belgisini olib tashlash
    genre = genre.replace('"', '').replace("'", "").strip()
    if not genre or genre == "":
        await message.answer("âŒ Janr nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(selected_genre=genre, content_type="movie")
    
    await message.answer(
        f"âœ… <b>Yangi janr:</b> {genre}\n\n"
        f"ðŸ“Ž <b>Endi bu janrga filmlar qo'sha olasiz!</b>\n\n"
        f"ðŸ“Ž <b>Video faylni yuboring:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_movie_genre_file)

@router.callback_query(F.data.startswith("admin_movie_genre_"))
async def handle_admin_movie_genre_select(callback: CallbackQuery, state: FSMContext):
    """Admin: Film janrini tanlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    genre = callback.data.replace("admin_movie_genre_", "")
    # Janrda " belgisini olib tashlash
    genre = genre.replace('"', '').replace("'", "").strip()
    if not genre or genre == "":
        genre = "Boshqa"
    await state.update_data(selected_genre=genre, content_type="movie")
    
    await safe_edit_text(callback,
        f"ðŸŽ¬ <b>JANR: {genre}</b>\n\n"
        f"âœ… <b>Endi bu janrga cheksiz filmlar qo'sha olasiz!</b>\n\n"
        f"ðŸ“Ž <b>Video faylni yuboring:</b>\n"
        f"Fayl yuboring yoki /cancel tugmasini bosing.",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_movie_genre_file)
    await callback.answer()

@router.message(AdminStates.waiting_movie_genre_file, F.video)
async def handle_admin_movie_genre_file(message: Message, state: FSMContext):
    """Admin: Janr bo'yicha film faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    genre = data.get('selected_genre', 'Boshqa')
    
    if not message.video:
        await message.answer("âŒ Video topilmadi!")
        return
    
    file_id = message.video.file_id
    caption = message.caption or message.video.file_name or "Film"
    
    success = await db.add_movie(file_id, caption, genre=genre, quality="720p")
    
    if success:
        await message.answer(
            f"âœ… <b>Film qo'shildi!</b>\n\n"
            f"ðŸŽ¬ <b>Nomi:</b> {caption[:100]}\n"
            f"ðŸ“‚ <b>Janr:</b> {genre}\n\n"
            f"ðŸ’¡ <b>Yana film qo'shish uchun video yuboring yoki /cancel tugmasini bosing.</b>",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
    else:
        await message.answer("âŒ Xatolik yuz berdi!")

@router.callback_query(F.data == "admin_add_courses_by_category")
async def handle_admin_add_courses_by_category(callback: CallbackQuery, state: FSMContext):
    """Admin: Kategoriya bo'yicha kurslar qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT category, COUNT(*) as count 
            FROM courses 
            WHERE is_active = 1 AND category IS NOT NULL AND category != ''
            GROUP BY category
            ORDER BY count DESC
            LIMIT 30
        ''')
        categories = await cursor.fetchall()
    
    if not categories:
        await safe_edit_text(callback,
            "ðŸŽ“ <b>KATEGORIYA BO'YICHA KURSLAR QO'SHISH</b>\n\n"
            "âŒ Hozircha kategoriyalar mavjud emas.\n\n"
            "ðŸ’¡ Avval oddiy kurs qo'shing, keyin kategoriyalar paydo bo'ladi.",
            reply_markup=Keyboards.back_button("admin_menu")
        )
        await callback.answer()
        return
    
    text = "ðŸŽ“ <b>KATEGORIYA BO'YICHA KURSLAR QO'SHISH</b>\n\n"
    text += "ðŸ“‚ <b>Kategoriyani tanlang:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for cat_row in categories:
        category = cat_row[0] or "Boshqa"
        count = cat_row[1] or 0
        text += f"â€¢ {category} ({count} ta)\n"
        builder.button(text=f"ðŸŽ“ {category}", callback_data=f"admin_course_category_{category}")
    
    builder.button(text="âž• Yangi kategoriya", callback_data="admin_new_course_category")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "admin_new_course_category")
async def handle_admin_new_course_category(callback: CallbackQuery, state: FSMContext):
    """Admin: Yangi kurs kategoriyasi qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ“ <b>YANGI KURS KATEGORIYASI QO'SHISH</b>\n\n"
        "ðŸ“ <b>Yangi kategoriya nomini yozing:</b>\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_course_category_select)
    await callback.answer()

@router.message(AdminStates.waiting_course_category_select)
async def handle_admin_new_course_category_name(message: Message, state: FSMContext):
    """Admin: Yangi kategoriya nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Kategoriya qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    category = message.text.strip()
    # Kategoriyada " belgisini olib tashlash
    category = category.replace('"', '').replace("'", "").strip()
    if not category or category == "":
        await message.answer("âŒ Kategoriya nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(selected_category=category, content_type="course")
    
    await message.answer(
        f"âœ… <b>Yangi kategoriya:</b> {category}\n\n"
        f"ðŸ“ <b>Endi bu kategoriyaga kurslar qo'sha olasiz!</b>\n\n"
        f"ðŸ“ <b>Kurs nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_course_category_file)

@router.callback_query(F.data.startswith("admin_course_category_"))
async def handle_admin_course_category_select(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs kategoriyasini tanlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    category = callback.data.replace("admin_course_category_", "")
    # Kategoriyada " belgisini olib tashlash
    category = category.replace('"', '').replace("'", "").strip()
    if not category or category == "":
        category = "Boshqa"
    await state.update_data(selected_category=category, content_type="course")
    
    await safe_edit_text(callback,
        f"ðŸŽ“ <b>KATEGORIYA: {category}</b>\n\n"
        f"âœ… <b>Endi bu kategoriyaga cheksiz kurslar qo'sha olasiz!</b>\n\n"
        f"ðŸ“ <b>Kurs nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_course_category_file)
    await callback.answer()

@router.message(AdminStates.waiting_course_category_file)
async def handle_admin_course_category_name(message: Message, state: FSMContext):
    """Admin: Kategoriya bo'yicha kurs nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return

    raw_text = (message.text or message.caption or "").strip()

    if raw_text == "/cancel":
        await state.clear()
        await message.answer("âŒ Kurs qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return

    if not raw_text:
        await message.answer(
            "âŒ Kurs nomi matn ko'rinishida kelmadi! Iltimos, kurs nomini oddiy matn qilib yuboring:",
            reply_markup=Keyboards.cancel_button()
        )
        return

    course_title = raw_text
    data = await state.get_data()
    category = data.get('selected_category', 'Boshqa')
    
    await state.update_data(course_title=course_title, course_category=category, course_part_number=1)
    
    await message.answer(
        f"âœ… <b>Kurs nomi:</b> {course_title}\n"
        f"ðŸ“‚ <b>Kategoriya:</b> {category}\n\n"
        f"ðŸ“¹ <b>Birinchi video qismini yuboring:</b>\n\n"
        f"ðŸ’¡ <b>Yana qism qo'shish uchun video yuboring yoki /cancel tugmasini bosing.</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    await state.set_state(AdminStates.waiting_add_course_file)

@router.message(AdminStates.waiting_book_genre_file, F.text == "/cancel")
@router.message(AdminStates.waiting_movie_genre_file, F.text == "/cancel")
@router.message(AdminStates.waiting_course_category_file, F.text == "/cancel")
async def handle_cancel_genre_add(message: Message, state: FSMContext):
    """Admin: Janr bo'yicha qo'shishni bekor qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        return
    
    await state.clear()
    await message.answer(
        "âŒ <b>Qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data == "user_add_movie")
async def handle_user_add_movie(callback: CallbackQuery, state: FSMContext):
    """Foydalanuvchi: Film qo'shish"""
    await callback.answer()
    await callback.message.edit_text("ðŸ“¤ <b>Film qo'shish</b>\n\nVideo faylini yuboring:", parse_mode=ParseMode.HTML)
    await state.set_state(UserStates.waiting_movie_file)

@router.message(UserStates.waiting_movie_file, F.video)
async def handle_user_movie_file(message: Message, state: FSMContext):
    """Foydalanuvchi: Film faylini qabul qilish"""
    if not message.video:
        await message.answer("âŒ Video topilmadi!")
        return
    
    file_id = message.video.file_id
    caption = message.caption or message.video.file_name or "Kino"
    
    # Bazaga saqlash (pending status bilan, quality=720p default)
    async with db.connect() as conn:
        await conn.execute('''
            INSERT INTO movies (file_id, caption, genre, quality, is_active, status)
            VALUES (?, ?, ?, ?, 1, 'pending')
        ''', (file_id, caption, "Boshqa", "720p"))
    
    await message.answer("âœ… Film yuborildi! Admin tasdiqlashini kutib turing.")
    await state.clear()

@router.callback_query(F.data == "admin_stats")
async def handle_admin_stats(callback: CallbackQuery):
    """Admin: Statistika"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.answer()
    
    # Statistika olish
    async with db.connect() as conn:
        cursor = await conn.execute("SELECT COUNT(*) FROM users")
        users_count = (await cursor.fetchone())[0]
        
        cursor = await conn.execute("SELECT COUNT(*) FROM books WHERE is_active = 1")
        books_count = (await cursor.fetchone())[0]
        
        cursor = await conn.execute("SELECT COUNT(*) FROM movies WHERE is_active = 1")
        movies_count = (await cursor.fetchone())[0]
        
        cursor = await conn.execute("SELECT COUNT(*) FROM courses WHERE is_active = 1")
        courses_count = (await cursor.fetchone())[0]
    
    text = f"""
ðŸ“Š <b>Tizim statistikasi</b>

ðŸ‘¥ Foydalanuvchilar: {users_count}
ðŸ“š Kitoblar: {books_count}
ðŸŽ¬ Filmlar: {movies_count}
ðŸŽ“ Kurslar: {courses_count}
    """
    
    await callback.message.edit_text(text, parse_mode=ParseMode.HTML)
    await callback.message.answer(
        "Admin panel:",
        reply_markup=Keyboards.admin_menu()
    )
    await callback.answer()

@router.callback_query(F.data == "ai_mentor_courses")
async def handle_ai_mentor_courses(callback: CallbackQuery):
    """AI Mentor kurslar"""
    user_id = callback.from_user.id
    
    text = """
ðŸ¤– <b>AI MENTOR - SUN'IY INTELLEKT YORDAMCHISI</b>

ðŸŽ“ <b>AI Mentor nima?</b>
AI Mentor sizga kurslar bo'yicha yordam beradi:
â€¢ Kurslar bo'yicha maslahatlar
â€¢ Kod tahlili va yechimlar
â€¢ Darslar bo'yicha savollar
â€¢ Amaliy topshiriqlar yechimi

ðŸ’¡ <b>Qanday ishlaydi:</b>
1. Kurs tanlang
2. AI Mentor'ga savol bering
3. Batafsil javob oling

ðŸŽ¯ <b>Mavjud funksiyalar:</b>
â€¢ Python dasturlash yordami
â€¢ Web dizayn maslahatlari
â€¢ Kod optimallashtirish
â€¢ Xatolarni tuzatish

ðŸ‘‡ <b>AI Mentor'ga savol bering:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’¬ AI ga savol", callback_data="ask_ai")
    builder.button(text="ðŸ“š Kurslar", callback_data="courses_menu")
    builder.button(text="ðŸ”™ Orqaga", callback_data="courses_menu")
    builder.adjust(1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "user_add_course")
async def handle_user_add_course(callback: CallbackQuery, state: FSMContext):
    """Foydalanuvchi kurs qo'shish (pul ishlash)"""
    user_id = callback.from_user.id
    
    text = """
âž• <b>KURS QO'SHISH - PUL ISHLASH</b>

ðŸ’° <b>Qanday ishlaydi:</b>
1. Kurs nomini yozing
2. Kurs faylini yuboring (video yoki PDF)
3. Admin tasdiqlashini kuting
4. Kurs tasdiqlangandan so'ng 200 XP olasiz!

ðŸ’µ <b>Mukofot:</b>
â€¢ Har bir tasdiqlangan kurs: 200 XP
â€¢ Cheksiz kurs qo'shish mumkin
â€¢ Admin tekshirgandan keyin XP olasiz

ðŸ“ <b>Talablar:</b>
â€¢ Kurs nomi aniq bo'lishi kerak
â€¢ Fayl sifatli bo'lishi kerak
â€¢ Spam yoki noto'g'ri kontent qabul qilinmaydi

ðŸ‘‡ <b>Kurs nomini yozing:</b>
    """
    
    await safe_edit_text(callback, text, reply_markup=Keyboards.cancel_button())
    await state.set_state(UserStates.waiting_course_upload)
    await callback.answer("âœ… Kurs qo'shish rejimi yoqildi!")

@router.callback_query(F.data == "courses_menu")
async def handle_courses_menu(callback: CallbackQuery):
    """Kurslar menyusi callback (OPTIMALLASHTIRILGAN)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    menu_text = f"""
ðŸŽ“ <b>KURSLAR - PROFESSIONAL TA'LIM</b>

ðŸ’° <b>Barcha kurslar:</b> 19,990 so'm
ðŸ‘¨â€ðŸ« <b>Professional instructorlar</b> - Sertifikatlangan mutaxassislar
ðŸ“– <b>To'liq materiallar</b> - Video, PDF, kodlar
ðŸ’» <b>Amaliy topshiriqlar</b> - Real loyihalar
ðŸ† <b>Bitiruv sertifikati</b> - Ishga kirish uchun

ðŸ”¥ <b>Top kurslar:</b>
  ðŸ’» Python dasturlash - 500+ talaba
  ðŸŽ¨ Web dizayn - 300+ talaba
  ðŸ‡ºðŸ‡¸ Ingliz tili - 400+ talaba
  ðŸ’¼ Biznes menejment - 250+ talaba
  ðŸ¤– Sun'iy intellekt - 200+ talaba

ðŸ’¡ <b>Nima olasiz:</b>
  âœ… Hayotiy ko'nikmalar
  âœ… Professional portfolio
  âœ… Doimiy qo'llab-quvvatlash

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await callback.message.edit_text(menu_text, reply_markup=Keyboards.courses_menu(user.get('subscription_type', 0)), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "market_mining")
async def handle_market_mining(callback: CallbackQuery):
    """Mining uskunalari"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    user_xp = user.get('xp', 0)
    
    text = f"""
â›ï¸ <b>MINING USKUNALARI</b>

ðŸ’° <b>Sizning XP: {user_xp:,}</b>

ðŸ›’ <b>Mavjud uskunalar:</b>

1. â›ï¸ <b>Basic Miner</b>
   ðŸ’° Narxi: 1,000 XP
   âš¡ XP/soat: 10 XP
   ðŸ“Š Level: 1

2. ðŸ”§ <b>Advanced Miner</b>
   ðŸ’° Narxi: 5,000 XP
   âš¡ XP/soat: 25 XP
   ðŸ“Š Level: 2

3. âš™ï¸ <b>Professional Miner</b>
   ðŸ’° Narxi: 15,000 XP
   âš¡ XP/soat: 50 XP
   ðŸ“Š Level: 3

4. ðŸ­ <b>Industrial Miner</b>
   ðŸ’° Narxi: 50,000 XP
   âš¡ XP/soat: 100 XP
   ðŸ“Š Level: 4

ðŸ’¡ <b>Maslahat:</b>
â€¢ Mining fermasi har 1 soatda XP beradi
â€¢ Upgrade qilish orqali ko'proq XP olasiz
â€¢ Har bir level 2 baravar ko'p XP beradi

ðŸ‘‡ <b>Mining fermasiga o'tish:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="â›ï¸ Mining fermasi", callback_data="mining_menu")
    builder.button(text="ðŸ”™ Market", callback_data="market_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "fortune_wheel")
async def handle_fortune_wheel(callback: CallbackQuery):
    """Fortune Wheel (Aylana)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    # Kunlik aylana tekshiruvi
    last_spin = user.get('last_fortune_spin')
    today = datetime.now().date()
    
    if last_spin:
        from datetime import datetime as dt
        try:
            date_str = str(last_spin).replace('Z', '').split('.')[0]
            last_spin_date = dt.fromisoformat(date_str).date()
        except (ValueError, AttributeError):
            try:
                date_str = str(last_spin).replace('Z', '').split('.')[0]
                last_spin_date = dt.strptime(date_str, '%Y-%m-%d %H:%M:%S').date()
            except:
                last_spin_date = None
        
        if last_spin_date and last_spin_date == today:
            await callback.answer("Siz bugun allaqachon aylana aylantirdingiz. Ertaga qaytib keling.", show_alert=True)
            return
    
    # Aylana natijasi
    import random
    rewards = [
        (25, "25 XP"),
        (50, "50 XP"),
        (100, "100 XP"),
        (250, "250 XP"),
        (500, "500 XP"),
        (1000, "1000 XP"),
    ]
    
    # Ehtimollik: kichik mukofotlar ko'proq
    weights = [30, 25, 20, 15, 7, 3]  # Foizlar
    reward_xp, reward_text = random.choices(rewards, weights=weights)[0]
    
    # XP qo'shish
    new_xp = user.get('xp', 0) + reward_xp
    await db.update_user_xp(user_id, reward_xp)
    
    # Last spin yangilash
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE users SET last_fortune_spin = datetime('now') WHERE user_id = ?
        ''', (user_id,))
        await conn.commit()
    
    text = f"""
<b>FORTUNE WHEEL</b>

<b>Tabriklaymiz!</b>

{reward_text}

<b>Yangi XP: {new_xp:,}</b>

<b>Maslahat:</b>
â€¢ Har kuni 1 marta bepul aylantirish mumkin
â€¢ Katta mukofotlar kam uchraydi
â€¢ Doimiy aylantirish orqali ko'proq XP oling

<b>Keyingi aylana:</b> Ertaga
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="Market", callback_data="market_menu")
    builder.button(text="Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer("Mukofot olingan!")

@router.callback_query(F.data == "my_xp")
async def handle_my_xp(callback: CallbackQuery):
    """Mening XP"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    user_xp = user.get('xp', 0)
    
    # XP statistikasi
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT SUM(xp_amount) FROM xp_transactions WHERE user_id = ? AND transaction_type = 'earned'
        ''', (user_id,))
        total_earned = (await cursor.fetchone())[0] or 0
        
        cursor = await conn.execute('''
            SELECT SUM(xp_amount) FROM xp_transactions WHERE user_id = ? AND transaction_type = 'spent'
        ''', (user_id,))
        total_spent = (await cursor.fetchone())[0] or 0
    
    text = f"""
ðŸ’° <b>MENING XP</b>

ðŸ’µ <b>Joriy XP: {user_xp:,}</b>

ðŸ“Š <b>Statistika:</b>
ðŸ’° Jami yig'ilgan: {total_earned:,} XP
ðŸ’¸ Jami sarflangan: {total_spent:,} XP
ðŸ“ˆ Sof daromad: {total_earned - total_spent:,} XP

ðŸ’¡ <b>XP qanday olinadi:</b>
â€¢ Kunlik bonus (50 XP)
â€¢ Referal taklif (100 XP)
â€¢ Kurslar yuklash (200 XP)
â€¢ Mining fermasi (10-100 XP/soat)
â€¢ Fortune Wheel (25-1000 XP)

ðŸ›’ <b>XP evaziga sotib olish:</b>
â€¢ Premium tariflar
â€¢ Mining upgrade
â€¢ Boshqa xizmatlar

ðŸ‘‡ <b>Tanlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ›’ Market", callback_data="market_menu")
    builder.button(text="â›ï¸ Mining", callback_data="mining_menu")
    builder.button(text="ðŸŽ° Fortune Wheel", callback_data="fortune_wheel")
    builder.button(text="ðŸ”™ Orqaga", callback_data="market_menu")
    builder.adjust(1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "market_menu")
async def handle_market_menu_callback(callback: CallbackQuery):
    """Market menyusi callback (MARKETING)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    user_xp = user.get('xp', 0)
    
    menu_text = f"""
ðŸ›’ <b>MARKET - XP DO'KONI</b>

ðŸ’° <b>Sizning XP: {user_xp:,}</b>

ðŸŽ <b>XP evaziga sotib olish:</b>
  â­ Premium tariflar (1-30 kun)
  ðŸ”¥ PRO obuna (30 kun)
  ðŸ’Ž Exclusive obuna (30 kun)

ðŸ¦ <b>To'lov orqali Premium:</b>
  ðŸ’Ž Premium: 19,990 so'm
  ðŸ”¥ PRO: 29,990 so'm
  ðŸ¥‡ Exclusive: 39,990 so'm
  ðŸ† Exclusive Pro+: 59,990 so'm

ðŸŽ° <b>Fortune Wheel (Aylana):</b>
  ðŸŽ Har kuni 1 marta bepul
  ðŸ’° 25-1000 XP yutib olish
  ðŸŽ¯ Bonus imkoniyatlar

ðŸ’¡ <b>Maslahat:</b>
  â€¢ XP to'plash uchun kunlik bonus oling
  â€¢ Referal taklif qiling
  â€¢ Kurslar yuklab pul ishlang

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await callback.message.edit_text(menu_text, reply_markup=Keyboards.market_menu(user_xp), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "referral_menu")
async def handle_referral_menu_callback(callback: CallbackQuery):
    """Referal menyusi callback (MARKETING)"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("Foydalanuvchi topilmadi")
        return
    
    # Referal statistikasini olish
    async with db.connect() as conn:
        try:
            cursor = await conn.execute('''
                SELECT 
                    COUNT(*) as total_referrals,
                    SUM(xp_gained) as total_xp_earned,
                    SUM(limit_gained) as total_limit_earned
                FROM referrals 
                WHERE referrer_id = ?
            ''', (user_id,))
            ref_stats = await cursor.fetchone()
            total_refs = ref_stats['total_referrals'] or 0 if ref_stats else 0
            total_xp = ref_stats['total_xp_earned'] or 0 if ref_stats else 0
            total_limit = ref_stats['total_limit_earned'] or 0 if ref_stats else 0
        except Exception:
            total_refs = 0
            total_xp = 0
            total_limit = 0
    
    next_bonus_at = 10 - (total_refs % 10) if total_refs % 10 != 0 else 0
    premium_bonus_count = total_refs // 10
    
    referral_link = f"https://t.me/{(await bot.get_me()).username}?start={user_id}"
    
    referral_text = f"""
ðŸ‘¥ <b>REFERAL TIZIMI - PUL ISHLASH</b>

ðŸ’° <b>Statistika:</b>
  ðŸ‘¥ Jami referallar: {total_refs}
  ðŸ’° Olingan XP: {total_xp:,}
  ðŸ¤– Olingan AI limit: {total_limit}
  ðŸŽ Premium bonuslar: {premium_bonus_count} ta (har 10 referal uchun)
  ðŸŽ¯ Keyingi Premium bonus: {next_bonus_at} referal qoldi

ðŸŽ <b>Bonuslar:</b>
  âœ… Har 1 referal: 75 XP + 1 AI limit
  âœ… Har 10 referal: 3 kunlik Premium obuna
  âœ… Har 20 referal: 7 kunlik Premium obuna
  âœ… Har 50 referal: 30 kunlik Premium obuna

ðŸ”— <b>Sizning referal havolangiz:</b>
<code>{referral_link}</code>

ðŸ’¡ <b>Qanday ishlatish:</b>
  1. Havolani nusxalang yoki ulashish tugmasini bosing
  2. Do'stlaringizga yuboring
  3. Ular botga qo'shilganda siz avtomatik bonus olasiz!
  4. Ko'proq do'st = Ko'proq pul!

ðŸš€ <b>Nima uchun ajoyib:</b>
  â€¢ Bepul pul ishlash
  â€¢ Cheksiz referallar
  â€¢ Premium obuna bepul
  â€¢ Do'stlaringizga foyda

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”— Referal linkni ulashish", url=f"tg://msg_url?url={referral_link}&text=Nexus Media - Kitoblar, filmlar, kurslar va AI Mentor!")
    builder.button(text="ðŸ“‹ Nusxa olish", callback_data="copy_referral")
    builder.button(text="ðŸŽ Bonuslar", callback_data="bonus_menu")
    builder.button(text="ðŸ“Š Referal statistikasi", callback_data="referral_stats")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1)
    
    await callback.message.edit_text(referral_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "search_courses")
async def handle_search_courses(callback: CallbackQuery, state: FSMContext):
    """Kurs qidirish"""
    await callback.answer()
    await callback.message.edit_text("ðŸ” <b>Kurs qidirish</b>\n\nKurs nomini yozing:", parse_mode=ParseMode.HTML)
    await state.set_state(UserStates.waiting_course_upload)

@router.message(UserStates.waiting_course_upload)
async def handle_search_course_query(message: Message, state: FSMContext):
    """Kurs qidiruv natijalari (YUKLAB OLISH FUNKSIYASI BILAN)"""
    query = message.text.strip()
    
    if query == "/cancel":
        await state.clear()
        await message.answer("âŒ Qidiruv bekor qilindi.", reply_markup=Keyboards.main_menu(message.from_user.id))
        return
    
    if len(query) < 2:
        await message.answer("âŒ Qidiruv so'zi juda qisqa! Kamida 2 belgi bo'lishi kerak.")
        return
    
    courses = await db.search_courses(query, limit=100)  # Barcha natijalarni olish
    
    # Pagination - 10 tadan ko'rsatish
    page = 0
    items_per_page = 10
    total_pages = (len(courses) + items_per_page - 1) // items_per_page if courses else 0
    
    if courses:
        text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
        text += f"ðŸ“Š Topilgan: {len(courses)} ta\n"
        text += f"ðŸ“„ Sahifa: {page + 1}/{total_pages}\n\n"
        
        # Faqat joriy sahifadagi natijalarni ko'rsatish
        start_idx = page * items_per_page
        end_idx = start_idx + items_per_page
        current_courses = courses[start_idx:end_idx]
        
        builder = InlineKeyboardBuilder()
        for i, course in enumerate(current_courses, start_idx + 1):
            course_title = course.get('title', 'Nomsiz')[:40] + "..." if len(course.get('title', '')) > 40 else course.get('title', 'Nomsiz')
            text += f"{i}. <b>{course_title}</b>\n"
            if course.get('instructor'):
                text += f"   ðŸ‘¨â€ðŸ« {course.get('instructor')}\n"
            if course.get('price'):
                text += f"   ðŸ’° {course.get('price', 19990):,} so'm\n"
            text += "\n"
            
            # Har bir kurs uchun ko'rish/yuklab olish tugmasi
            builder.button(text=f"ðŸ“š {course_title[:25]}", callback_data=f"view_course_{course.get('id')}")
        
        # Pagination tugmalari
        if total_pages > 1:
            pagination_buttons = []
            if page > 0:
                pagination_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Orqaga", callback_data=f"search_page_courses_{page - 1}"))
            if page < total_pages - 1:
                pagination_buttons.append(InlineKeyboardButton(text="âž¡ï¸ Keyingi", callback_data=f"search_page_courses_{page + 1}"))
            if pagination_buttons:
                builder.row(*pagination_buttons)
        
        # State'ga saqlash
        await state.update_data(
            search_query=query,
            search_results=courses,
            search_type="courses",
            current_page=page
        )
        
        builder.button(text="ðŸ” Qayta qidirish", callback_data="search_courses")
        builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
        
        if len(current_courses) <= 5:
            builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
        else:
            builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
        
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    else:
        await message.answer(
            f"âŒ '{query}' bo'yicha kurs topilmadi.\n\n"
            "ðŸ’¡ <b>Maslahat:</b>\n"
            "â€¢ Kurs nomini to'liq yozing\n"
            "â€¢ Kategoriya bo'yicha qidiring\n"
            "â€¢ O'qituvchi nomini yozib ko'ring",
            reply_markup=Keyboards.back_button("courses_menu"),
            parse_mode=ParseMode.HTML
        )
    
    await state.clear()

@router.callback_query(F.data == "random_course")
async def handle_random_course(callback: CallbackQuery):
    """Tasodifiy kurs"""
    await callback.answer()
    courses = await db.get_random_courses(limit=1)
    
    if courses:
        course = courses[0]
        text = f"""
ðŸŽ“ <b>{course.get('title', 'Nomsiz')}</b>

ðŸ“ {course.get('description', 'Tavsif mavjud emas')}
ðŸ’° Narx: {course.get('price', 19990)} so'm
ðŸ“‚ Kategoriya: {course.get('category', 'Boshqa')}
        """
        await callback.message.edit_text(text, reply_markup=Keyboards.course_actions(course.get('id')), parse_mode=ParseMode.HTML)
    else:
        await callback.message.edit_text("âŒ Kurs topilmadi.")

@router.callback_query(F.data.startswith("view_course_"))
async def handle_view_course(callback: CallbackQuery):
    """Kursni ko'rish (yaxshilangan - demo video)"""
    course_id = int(callback.data.replace("view_course_", ""))
    user_id = callback.from_user.id
    
    course = await db.get_course(course_id)
    
    if not course:
        await callback.answer("âŒ Kurs topilmadi!", show_alert=True)
        return
    
    # Foydalanuvchi bu kursni sotib olganligini tekshirish
    async with db.connect() as conn:
        cursor = await conn.execute(
            'SELECT 1 FROM user_courses WHERE user_id = ? AND course_id = ?',
            (user_id, course_id)
        )
        has_purchased = await cursor.fetchone()
    
    # Demo video olish
    demo_video_id = await db.get_course_demo_video(course_id)
    
    course_text = f"""
ðŸŽ“ <b>{course.get('title', 'Nomsiz')}</b>

ðŸ‘¨â€ðŸ« <b>O'qituvchi:</b> {course.get('instructor', 'Noma\'lum')}
â±ï¸ <b>Davomiylik:</b> {course.get('duration', '4 hafta')}
ðŸ“š <b>Darslar:</b> {course.get('lessons_count', 10)} ta
ðŸ‘¥ <b>Talabalar:</b> {course.get('students_count', 0)} kishi
â­ <b>Reyting:</b> {course.get('rating', 0)}/5.0
ðŸ’° <b>Narx:</b> {course.get('price', 19990):,} so'm

ðŸ“– <b>Tavsif:</b>
{course.get('full_description', course.get('description', 'Tavsif mavjud emas'))}

ðŸ“‹ <b>Talablar:</b>
{course.get('requirements', 'Yo\'q')}

ðŸŽ <b>Siz olasiz:</b>
{course.get('what_you_get', 'Sertifikat va materiallar')}
    """
    
    builder = InlineKeyboardBuilder()
    
    if has_purchased:
        builder.button(text="ðŸ“š Kursga kirish", callback_data=f"access_course_{course_id}")
    else:
        builder.button(text="ðŸ’° Sotib olish", callback_data=f"buy_course_{course_id}")
        # Demo video tugmasi
        if demo_video_id:
            builder.button(text="ðŸŽ¬ Demo video", callback_data=f"demo_course_{course_id}")
    
    builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
    
    if has_purchased:
        builder.adjust(1, 1)
    else:
        if demo_video_id:
            builder.adjust(2, 1)
        else:
            builder.adjust(1, 1)
    
    await callback.message.edit_text(course_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.startswith("download_course_"))
async def handle_download_course(callback: CallbackQuery):
    """Kursni yuklash"""
    await callback.answer("â³ Tekshirilmoqda...")
    
    course_id = int(callback.data.replace("download_course_", ""))
    course = await db.get_course(course_id)
    
    if not course:
        await callback.answer("âŒ Kurs topilmadi!", show_alert=True)
        return
    
    file_id = course.get('file_id')
    if not file_id:
        await callback.answer("âŒ File ID topilmadi!", show_alert=True)
        return
    
    try:
        caption = f"ðŸŽ“ {course.get('title', 'Kurs')}\nðŸ’° {course.get('price', 19990)} so'm"
        await bot.send_document(
            chat_id=callback.from_user.id,
            document=file_id,
            caption=caption
        )
        
        # Download history ga yozish (statistika uchun)
        await db.record_download(callback.from_user.id, "course", course_id)
        
        await callback.answer("âœ… Kurs yuborildi!")
    except Exception as e:
        logger.error(f"Download course error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data == "admin_add_podcast")
async def handle_admin_add_podcast(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast qo'shish (audio yoki video)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ§ Audio podcast", callback_data="admin_add_podcast_audio")
    builder.button(text="ðŸŽ¬ Video podcast", callback_data="admin_add_podcast_video")
    builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
    builder.adjust(1, 1, 1)
    
    await safe_edit_text(callback,
        "ðŸŽ™ï¸ <b>PODCAST QO'SHISH</b>\n\n"
        "ðŸ“ <b>Podcast turini tanlang:</b>\n\n"
        "ðŸŽ§ <b>Audio podcast:</b> Audio fayl (mp3, m4a)\n"
        "ðŸŽ¬ <b>Video podcast:</b> Video fayl (mp4, avi)\n\n"
        "ðŸ’¡ <b>Maslahat:</b> Audio podcastlar uchun audio fayl, video podcastlar uchun video fayl yuboriladi.",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "admin_add_podcast_audio")
async def handle_admin_add_podcast_audio(callback: CallbackQuery, state: FSMContext):
    """Admin: Audio podcast qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await state.update_data(podcast_content_type="audio")
    await safe_edit_text(callback,
        "ðŸŽ§ <b>AUDIO PODCAST QO'SHISH</b>\n\n"
        "ðŸ“ <b>Podcast nomini yozing:</b>\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_podcast_title)
    await callback.answer()

@router.callback_query(F.data == "admin_add_podcast_video")
async def handle_admin_add_podcast_video(callback: CallbackQuery, state: FSMContext):
    """Admin: Video podcast qo'shish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await state.update_data(podcast_content_type="video")
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>VIDEO PODCAST QO'SHISH</b>\n\n"
        "ðŸ“ <b>Podcast nomini yozing:</b>\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_podcast_title)
    await callback.answer()

@router.message(AdminStates.waiting_podcast_title)
async def handle_podcast_title(message: Message, state: FSMContext):
    """Admin: Podcast nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return

    raw_text = (message.text or message.caption or "").strip()

    # Agar bot tugmasi bo'lsa, ignore qilish
    if raw_text in ["Admin Panel", "Admin panel", "Kutubxona", "Kinoteatr", "Kurslar", "Podcastlar", "Profil", "Premium", "Yangi funksiyalar", "AI Mentor", "Asosiy menyu"]:
        await state.clear()
        return

    if not raw_text:
        await message.answer(
            "âŒ Podcast nomi matn ko'rinishida kelmadi! Iltimos, nomni oddiy matn qilib yuboring:",
            reply_markup=Keyboards.cancel_button()
        )
        return

    title = raw_text
    if title == "/cancel":
        await state.clear()
        await message.answer("âŒ Podcast qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return
    
    if not title or len(title) < 2:
        await message.answer("âŒ Podcast nomi juda qisqa! Kamida 2 belgi bo'lishi kerak. Qayta kiriting:")
        return
    
    await state.update_data(podcast_title=title)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="podcast_lang_uz")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="podcast_lang_en")
    builder.adjust(2)
    
    await message.answer(
        f"âœ… <b>Podcast nomi qabul qilindi!</b>\n\n"
        f"ðŸ“ <b>Podcast nomi:</b> {title}\n\n"
        f"ðŸŒ <b>Tilni tanlang:</b>",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data.startswith("podcast_lang_"))
async def handle_podcast_language(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast tilini tanlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    content_type = data.get('podcast_content_type')
    is_video = (content_type == 'video') or callback.data.endswith("_video")
    language = "uz" if "uz" in callback.data else "en"
    await state.update_data(podcast_language=language)
    
    # Video podcast uchun kategoriya so'rash
    if is_video:
        categories = ["Motivatsion", "Biznes", "Texnologiya", "Ta'lim", "Sog'liq", "Ijtimoiy", "Boshqa"]
        builder = InlineKeyboardBuilder()
        for cat in categories:
            builder.button(text=f"ðŸ“‚ {cat}", callback_data=f"podcast_cat_{cat}_video")
        builder.button(text="âŒ Bekor qilish", callback_data="admin_add_podcast")
        builder.adjust(2)
        
        data = await state.get_data()
        title = data.get('podcast_title', 'Podcast')
        
        await safe_edit_text(callback,
            f"âœ… <b>Til tanlandi!</b>\n\n"
            f"ðŸŽ¬ <b>Podcast:</b> {title}\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n\n"
            f"ðŸ“‚ <b>Kategoriyani tanlang:</b>",
            reply_markup=builder.as_markup()
        )
        await callback.answer("âœ… Til tanlandi!")
        return
    
    try:
        await callback.message.edit_text(
            f"âœ… <b>Til tanlandi!</b>\n\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n\n"
            f"ðŸ“ <b>Podcast tavsifini yozing (ixtiyoriy):</b>\n\n"
            f"ðŸ’¡ <i>Maslahat:</i> Tavsifni o'tkazib yuborish uchun /skip yozing\n\n"
            f"âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
    except Exception:
        # Agar edit qilishda xatolik bo'lsa, yangi xabar yuboramiz
        await callback.message.answer(
            f"âœ… <b>Til tanlandi!</b>\n\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n\n"
            f"ðŸ“ <b>Podcast tavsifini yozing (ixtiyoriy):</b>\n\n"
            f"ðŸ’¡ <i>Maslahat:</i> Tavsifni o'tkazib yuborish uchun /skip yozing\n\n"
            f"âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
    await state.set_state(AdminStates.waiting_podcast_description)
    await callback.answer("âœ… Til tanlandi!")

@router.message(AdminStates.waiting_podcast_description)
async def handle_podcast_description(message: Message, state: FSMContext):
    """Admin: Podcast tavsifini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/skip":
        description = ""
    else:
        description = message.text.strip()
    
    await state.update_data(podcast_description=description)
    
    categories = [
        ("ðŸ’ª Motivatsion", "Motivatsion"),
        ("ðŸ’¼ Biznes", "Biznes"),
        ("ðŸ¤– Texnologiya", "Texnologiya"),
        ("ðŸŽ“ Ta'lim", "Ta'lim"),
        ("ðŸŽ¨ Dizayn", "Dizayn"),
        ("ðŸ“ˆ Marketing", "Marketing"),
        ("ðŸ”¬ Fan", "Fan"),
        ("ðŸŽ­ Madaniyat", "Madaniyat"),
        ("ðŸƒ Salomatlik", "Salomatlik"),
        ("ðŸ’° Moliya", "Moliya"),
        ("ðŸ“‚ Boshqa", "Boshqa")
    ]
    
    builder = InlineKeyboardBuilder()
    for name, cat in categories:
        builder.button(text=name, callback_data=f"podcast_cat_{cat}")
    builder.button(text="ðŸ”™ Orqaga", callback_data="admin_add_podcast")
    builder.adjust(2, 2, 2, 2, 2, 1, 1)
    
    await message.answer(
        f"âœ… <b>Tavsif:</b> {description or 'Yo\'q'}\n\n"
        f"ðŸ“‚ <b>Kategoriyani tanlang:</b>",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data.startswith("podcast_cat_"))
async def handle_podcast_category(callback: CallbackQuery, state: FSMContext):
    """Admin: Podcast kategoriyasini tanlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    is_video = callback.data.endswith("_video")
    category = callback.data.replace("podcast_cat_", "").replace("_video", "")
    await state.update_data(podcast_category=category)
    
    # Video podcast uchun to'g'ridan-to'g'ri saqlash
    if is_video:
        data = await state.get_data()
        title = data.get('podcast_title', 'Podcast')
        video_file_id = data.get('podcast_video_file_id')
        language = data.get('podcast_language', 'uz')
        description = ''  # Tavsif kerakmas
        host = data.get('podcast_host', '')
        
        if not video_file_id:
            await callback.answer("âŒ Video fayl topilmadi!", show_alert=True)
            return
        
        if not title or title == 'Podcast':
            await callback.answer("âŒ Podcast nomi topilmadi!", show_alert=True)
            return
        
        success = await db.add_podcast(
            title=title,
            description=description,
            file_id=video_file_id,
            video_file_id=video_file_id,
            category=category,
            host=host,
            language=language,
            content_type="video",
            created_by=user_id
        )
        
        if success:
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸŽ™ï¸ Yana podcast qo'shish", callback_data="admin_add_podcast")
            builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
            builder.adjust(1, 1)
            
            await safe_edit_text(callback,
                f"âœ… <b>Video podcast muvaffaqiyatli qo'shildi!</b>\n\n"
                f"ðŸŽ¬ <b>Nomi:</b> {title}\n"
                f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
                f"ðŸ“‚ <b>Kategoriya:</b> {category}\n"
                f"ðŸŽ™ï¸ <b>Host:</b> {host or 'Yo\'q'}\n\n"
                f"ðŸ’¡ <b>Yana podcast qo'shish uchun tugmani bosing yoki /cancel tugmasini bosing.</b>",
                reply_markup=builder.as_markup()
            )
            logger.info(f"Admin {user_id} video podcast qo'shdi: {title}")
            await state.clear()
        else:
            await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)
        return
    
    # Audio podcast uchun host so'rash
    await safe_edit_text(callback,
        f"ðŸ“‚ <b>Kategoriya:</b> {category}\n\n"
        f"ðŸŽ™ï¸ <b>Host nomini yozing (ixtiyoriy):</b>\n\n"
        f"âŒ O'tkazib yuborish: /skip",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_podcast_host)
    await callback.answer()

@router.message(AdminStates.waiting_podcast_host)
async def handle_podcast_host(message: Message, state: FSMContext):
    """Admin: Podcast host nomini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    if message.text == "/skip":
        host = ""
    else:
        host = message.text.strip()
    
    await state.update_data(podcast_host=host)
    
    data = await state.get_data()
    content_type = data.get('podcast_content_type', 'audio')
    
    if content_type == 'audio':
        await message.answer(
            f"âœ… <b>Host:</b> {host or 'Yo\'q'}\n\n"
            f"ðŸŽ§ <b>Audio faylni yuboring:</b>\n\n"
            f"âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_podcast_file)
    else:
        await message.answer(
            f"âœ… <b>Host:</b> {host or 'Yo\'q'}\n\n"
            f"ðŸŽ¬ <b>Video faylni yuboring:</b>\n\n"
            f"âŒ Bekor qilish: /cancel",
            reply_markup=Keyboards.cancel_button(),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_podcast_video)

@router.message(AdminStates.waiting_podcast_file, F.audio)
async def handle_podcast_audio_file(message: Message, state: FSMContext):
    """Admin: Audio podcast faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    file_id = message.audio.file_id
    data = await state.get_data()
    
    # Audio fayl saqlanadi
    await state.update_data(podcast_audio_file_id=file_id)
    
    title = data.get('podcast_title', 'Podcast')
    category = data.get('podcast_category', 'Boshqa')
    language = data.get('podcast_language', 'uz')
    
    # Video qo'shish imkoniyatini taklif qilish
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ¬ Video qo'shish", callback_data="admin_add_podcast_video_optional")
    builder.button(text="âœ… Faqat audio (Tugatish)", callback_data="admin_finish_podcast_audio")
    builder.button(text="âŒ Bekor qilish", callback_data="admin_add_podcast")
    builder.adjust(1, 1, 1)
    
    await message.answer(
        f"âœ… <b>Audio fayl qabul qilindi!</b>\n\n"
        f"ðŸŽ™ï¸ <b>Podcast:</b> {title}\n"
        f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
        f"ðŸ“‚ <b>Kategoriya:</b> {category}\n\n"
        f"ðŸ’¡ <b>Video qo'shish (ixtiyoriy):</b>\n"
        f"â€¢ Motivatsion va boshqa kategoriyalar uchun video qo'shishingiz mumkin\n"
        f"â€¢ Video qo'shmasangiz, faqat audio podcast sifatida saqlanadi\n\n"
        f"ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>",
        reply_markup=builder.as_markup(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data == "admin_add_podcast_video_optional")
async def handle_admin_add_podcast_video_optional(callback: CallbackQuery, state: FSMContext):
    """Admin: Audio podcastga video qo'shish (ixtiyoriy)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>VIDEO QO'SHISH</b>\n\n"
        "ðŸ“¹ <b>Video faylni yuboring:</b>\n\n"
        "ðŸ’¡ <b>Maslahat:</b>\n"
        "â€¢ Video podcastlar uchun qo'shimcha video qo'shishingiz mumkin\n"
        "â€¢ Motivatsion va boshqa kategoriyalar uchun video qo'shish tavsiya etiladi\n"
        "â€¢ Video qo'shmasangiz, faqat audio podcast sifatida saqlanadi\n\n"
        "âŒ O'tkazib yuborish: /skip",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(AdminStates.waiting_podcast_video_optional)
    await callback.answer()

@router.callback_query(F.data == "admin_finish_podcast_audio")
async def handle_admin_finish_podcast_audio(callback: CallbackQuery, state: FSMContext):
    """Admin: Faqat audio podcastni saqlash"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    
    title = data.get('podcast_title', 'Podcast')
    description = data.get('podcast_description', '')
    category = data.get('podcast_category', 'Boshqa')
    language = data.get('podcast_language', 'uz')
    host = data.get('podcast_host', '')
    audio_file_id = data.get('podcast_audio_file_id')
    
    if not audio_file_id:
        await callback.answer("âŒ Audio fayl topilmadi!", show_alert=True)
        return
    
    success = await db.add_podcast(
        title=title,
        description=description,
        file_id=audio_file_id,
        video_file_id=None,
        category=category,
        host=host,
        language=language,
        content_type="audio",
        created_by=user_id
    )
    
    if success:
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ™ï¸ Yana podcast qo'shish", callback_data="admin_add_podcast")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback,
            f"âœ… <b>Audio podcast muvaffaqiyatli qo'shildi!</b>\n\n"
            f"ðŸŽ™ï¸ <b>Nomi:</b> {title}\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {category}\n"
            f"ðŸŽ™ï¸ <b>Host:</b> {host or 'Yo\'q'}\n\n"
            f"ðŸ’¡ <b>Yana podcast qo'shish uchun tugmani bosing.</b>",
            reply_markup=builder.as_markup()
        )
        logger.info(f"Admin {user_id} audio podcast qo'shdi: {title}")
    else:
        await callback.answer("âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.", show_alert=True)
    
    await state.clear()
    await callback.answer()

@router.message(AdminStates.waiting_podcast_video, F.video)
async def handle_podcast_video_file(message: Message, state: FSMContext):
    """Admin: Video podcast faylini qabul qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    video_file_id = message.video.file_id
    
    data = await state.get_data()
    
    # Title state'dan olinadi (birinchi nom yozilgan)
    title = data.get('podcast_title', '')
    if not title or title == '':
        # Agar title yo'q bo'lsa, caption yoki file_name dan olish
        if message.caption:
            title = message.caption.strip()
        elif message.video.file_name:
            title = message.video.file_name.rsplit('.', 1)[0] if '.' in message.video.file_name else message.video.file_name
        else:
            title = 'Podcast'
    
    # Tavsif kerakmas, bo'sh qoldiramiz
    description = ''
    category = data.get('podcast_category', 'Boshqa')
    language = data.get('podcast_language', 'uz')
    host = data.get('podcast_host', '')
    
    # Video file_id ni saqlash
    await state.update_data(podcast_video_file_id=video_file_id, podcast_title=title)
    
    if not language:
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="podcast_lang_uz_video")
        builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="podcast_lang_en_video")
        builder.adjust(2)
        
        await message.answer(
            f"âœ… <b>Video qabul qilindi!</b>\n\n"
            f"ðŸŽ¬ <b>Podcast nomi:</b> {title}\n\n"
            f"ðŸŒ <b>Tilni tanlang:</b>",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        return
    
    if not category or category == 'Boshqa':
        # Kategoriya so'rash
        categories = ["Motivatsion", "Biznes", "Texnologiya", "Ta'lim", "Sog'liq", "Ijtimoiy", "Boshqa"]
        builder = InlineKeyboardBuilder()
        for cat in categories:
            builder.button(text=f"ðŸ“‚ {cat}", callback_data=f"podcast_cat_{cat}_video")
        builder.button(text="âŒ Bekor qilish", callback_data="admin_add_podcast")
        builder.adjust(2)
        
        await message.answer(
            f"âœ… <b>Til tanlandi!</b>\n\n"
            f"ðŸŽ¬ <b>Podcast:</b> {title}\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n\n"
            f"ðŸ“‚ <b>Kategoriyani tanlang:</b>",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        return
    
    # Video podcast uchun file_id sifatida video_file_id ishlatiladi
    success = await db.add_podcast(
        title=title,
        description=description,
        file_id=video_file_id,  # Video podcast uchun video_file_id file_id sifatida
        video_file_id=video_file_id,
        category=category,
        host=host,
        language=language,
        content_type="video",
        created_by=user_id
    )
    
    if success:
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ™ï¸ Yana podcast qo'shish", callback_data="admin_add_podcast")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(1, 1)
        
        await message.answer(
            f"âœ… <b>Video podcast muvaffaqiyatli qo'shildi!</b>\n\n"
            f"ðŸŽ¬ <b>Nomi:</b> {title}\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {category}\n\n"
            f"ðŸ’¡ <b>Yana podcast qo'shish uchun tugmani bosing.</b>",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        logger.info(f"Admin {user_id} video podcast qo'shdi: {title}")
    else:
        await message.answer("âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.")
    
    await state.clear()

@router.message(AdminStates.waiting_podcast_video_optional, F.video)
async def handle_podcast_video_optional(message: Message, state: FSMContext):
    """Admin: Audio podcastga video qo'shish (ixtiyoriy)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    video_file_id = message.video.file_id
    data = await state.get_data()
    
    title = data.get('podcast_title', 'Podcast')
    description = data.get('podcast_description', '')
    category = data.get('podcast_category', 'Boshqa')
    language = data.get('podcast_language', 'uz')
    host = data.get('podcast_host', '')
    audio_file_id = data.get('podcast_audio_file_id')
    
    if not audio_file_id:
        await message.answer("âŒ Audio fayl topilmadi! Qaytadan boshlang.")
        await state.clear()
        return
    
    # Audio va video bilan podcast qo'shish
    success = await db.add_podcast(
        title=title,
        description=description,
        file_id=audio_file_id,
        video_file_id=video_file_id,
        category=category,
        host=host,
        language=language,
        content_type="video",  # Video mavjud bo'lgani uchun
        created_by=user_id
    )
    
    if success:
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ™ï¸ Yana podcast qo'shish", callback_data="admin_add_podcast")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(1, 1)
        
        await message.answer(
            f"âœ… <b>Podcast muvaffaqiyatli qo'shildi!</b>\n\n"
            f"ðŸŽ™ï¸ <b>Nomi:</b> {title}\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {category}\n"
            f"ðŸŽ™ï¸ <b>Host:</b> {host or 'Yo\'q'}\n"
            f"ðŸŽ§ <b>Audio:</b> âœ…\n"
            f"ðŸŽ¬ <b>Video:</b> âœ…\n\n"
            f"ðŸ’¡ <b>Yana podcast qo'shish uchun tugmani bosing.</b>",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        logger.info(f"Admin {user_id} audio+video podcast qo'shdi: {title}")
    else:
        await message.answer("âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.")
    
    await state.clear()

@router.message(AdminStates.waiting_podcast_video_optional, F.text == "/skip")
async def handle_podcast_video_skip(message: Message, state: FSMContext):
    """Admin: Video qo'shishni o'tkazib yuborish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return
    
    data = await state.get_data()
    
    title = data.get('podcast_title', 'Podcast')
    description = data.get('podcast_description', '')
    category = data.get('podcast_category', 'Boshqa')
    language = data.get('podcast_language', 'uz')
    host = data.get('podcast_host', '')
    audio_file_id = data.get('podcast_audio_file_id')
    
    if not audio_file_id:
        await message.answer("âŒ Audio fayl topilmadi! Qaytadan boshlang.")
        await state.clear()
        return
    
    # Faqat audio bilan podcast qo'shish
    success = await db.add_podcast(
        title=title,
        description=description,
        file_id=audio_file_id,
        video_file_id=None,
        category=category,
        host=host,
        language=language,
        content_type="audio",
        created_by=user_id
    )
    
    if success:
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ™ï¸ Yana podcast qo'shish", callback_data="admin_add_podcast")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(1, 1)
        
        await message.answer(
            f"âœ… <b>Audio podcast muvaffaqiyatli qo'shildi!</b>\n\n"
            f"ðŸŽ™ï¸ <b>Nomi:</b> {title}\n"
            f"ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if language == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {category}\n"
            f"ðŸŽ™ï¸ <b>Host:</b> {host or 'Yo\'q'}\n"
            f"ðŸŽ§ <b>Audio:</b> âœ…\n"
            f"ðŸŽ¬ <b>Video:</b> âŒ (O'tkazib yuborildi)\n\n"
            f"ðŸ’¡ <b>Yana podcast qo'shish uchun tugmani bosing.</b>",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        logger.info(f"Admin {user_id} audio podcast qo'shdi (video o'tkazib yuborildi): {title}")
    else:
        await message.answer("âŒ Xatolik yuz berdi! Database ga saqlashda muammo bo'ldi.")
    
    await state.clear()

@router.message(AdminStates.waiting_podcast_file, F.text == "/cancel")
@router.message(AdminStates.waiting_podcast_video, F.text == "/cancel")
@router.message(AdminStates.waiting_podcast_video_optional, F.text == "/cancel")
@router.message(AdminStates.waiting_podcast_host, F.text == "/cancel")
@router.message(AdminStates.waiting_podcast_description, F.text == "/cancel")
async def handle_cancel_podcast(message: Message, state: FSMContext):
    """Admin: Podcast qo'shishni bekor qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        return
    
    await state.clear()
    await message.answer(
        "âŒ <b>Podcast qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data == "admin_add_course")
async def handle_admin_add_course(callback: CallbackQuery, state: FSMContext):
    """Admin: Qismli kurs qo'shish (professional va sodda)"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await callback.message.edit_text(
        "ðŸŽ“ <b>QISMLI KURS QO'SHISH</b>\n\n"
        "ðŸ“ <b>Qanday ishlaydi:</b>\n"
        "1. Kurs nomini yozing\n"
        "2. Keyin video qismlarini yuborish mumkin (cheksiz)\n"
        "3. Har bir qism avtomatik bazaga saqlanadi\n"
        "4. Jarayonni to'xtatish uchun /cancel\n\n"
        "ðŸ“ <b>Kurs nomini yozing:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.update_data(course_part_number=1)
    await state.set_state(AdminStates.waiting_course_title)
    await callback.answer("âœ… Kurs qo'shish rejimi yoqildi!")

@router.message(AdminStates.waiting_course_title)
async def handle_course_title(message: Message, state: FSMContext):
    """Admin: Kurs nomini qabul qilish va video so'rash"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await state.clear()
        return

    raw_text = (message.text or message.caption or "").strip()

    if raw_text == "/cancel":
        await state.clear()
        await message.answer("âŒ Kurs qo'shish bekor qilindi.", reply_markup=Keyboards.admin_menu())
        return

    if not raw_text:
        await message.answer(
            "âŒ Kurs nomi matn ko'rinishida kelmadi! Iltimos, kurs nomini oddiy matn qilib yuboring:",
            reply_markup=Keyboards.cancel_button()
        )
        return

    course_title = raw_text
    
    if not course_title:
        await message.answer("âŒ Kurs nomi bo'sh bo'lishi mumkin emas! Qayta yozing:")
        return
    
    await state.update_data(course_title=course_title, course_part_number=1)
    
    await message.answer(
        f"âœ… <b>Kurs nomi qabul qilindi!</b>\n\n"
        f"ðŸŽ“ <b>Nomi:</b> {course_title}\n\n"
        f"ðŸ“Ž <b>Endi video qismlarini yuborishingiz mumkin:</b>\n"
        f"â€¢ Birinchi qismni yuboring\n"
        f"â€¢ Keyin ikkinchi, uchinchi va hokazo (cheksiz)\n"
        f"â€¢ Har bir qism avtomatik bazaga saqlanadi\n"
        f"â€¢ To'xtatish uchun /cancel\n\n"
        f"ðŸ“¹ <b>Birinchi video qismini yuboring:</b>",
        reply_markup=Keyboards.cancel_button(),
        parse_mode=ParseMode.HTML
    )
    
    await state.set_state(AdminStates.waiting_add_course_file)

@router.message(AdminStates.waiting_add_course_file, F.video)
async def handle_admin_course_file(message: Message, state: FSMContext):
    """Admin: Kurs video qismlarini qabul qilish va avtomatik saqlash (cheksiz)"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        await message.answer("âŒ Siz admin emassiz!")
        await state.clear()
        return
    
    if not message.video:
        await message.answer("âŒ Video topilmadi! Video fayl yuboring yoki /cancel tugmasini bosing.")
        return
    
    data = await state.get_data()
    course_title = data.get('course_title', 'Kurs')
    part_number = data.get('course_part_number', 1)
    
    file_id = message.video.file_id
    
    try:
        # Birinchi qism bo'lsa, yangi kurs yaratish
        if part_number == 1:
            # Kursni yaratish
            course_id = await db.add_course(
                title=course_title,
                description=f"{course_title} kursi",
                full_description=f"{course_title} kursi - professional video darslar",
                instructor="Admin",
                file_id="",  # Asosiy fayl yo'q, faqat videolar
                category="Boshqa",
                price=19990,
                lessons_count=1
            )
            
            if course_id:
                # Birinchi videoni qo'shish
                async with db.connect() as conn:
                    await conn.execute('''
                        INSERT INTO course_videos (course_id, video_id, video_order, title, is_demo)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (course_id, file_id, part_number, f"{course_title} - Qism {part_number}", 0))
                    await conn.commit()
                
                await state.update_data(course_id=course_id, course_part_number=2)
                
                await message.answer(
                    f"âœ… <b>Kurs yaratildi va birinchi qism qo'shildi!</b>\n\n"
                    f"ðŸŽ“ <b>Nomi:</b> {course_title}\n"
                    f"ðŸ†” <b>ID:</b> {course_id}\n"
                    f"ðŸ“¦ <b>Qism:</b> 1\n\n"
                    f"ðŸ’¡ <b>Yana qism qo'shish uchun video yuboring yoki /cancel tugmasini bosing.</b>",
                    reply_markup=Keyboards.cancel_button(),
                    parse_mode=ParseMode.HTML
                )
            else:
                await message.answer("âŒ Kurs yaratishda xatolik yuz berdi!")
        else:
            # Keyingi qismlar uchun
            course_id = data.get('course_id')
            if not course_id:
                await message.answer("âŒ Xatolik! Kurs ID topilmadi. Qaytadan boshlang.")
                await state.clear()
                return
            
            # Video qismini qo'shish
            async with db.connect() as conn:
                await conn.execute('''
                    INSERT INTO course_videos (course_id, video_id, video_order, title, is_demo)
                    VALUES (?, ?, ?, ?, ?)
                ''', (course_id, file_id, part_number, f"{course_title} - Qism {part_number}", 0))
                
                # Kursdagi videolar sonini yangilash
                await conn.execute('''
                    UPDATE courses SET lessons_count = ? WHERE id = ?
                ''', (part_number, course_id))
                await conn.commit()
            
            await state.update_data(course_part_number=part_number + 1)
            
            await message.answer(
                f"âœ… <b>Qism {part_number} muvaffaqiyatli qo'shildi!</b>\n\n"
                f"ðŸŽ“ <b>Nomi:</b> {course_title}\n"
                f"ðŸ†” <b>ID:</b> {course_id}\n"
                f"ðŸ“¦ <b>Qismlar:</b> {part_number} ta\n\n"
                f"ðŸ’¡ <b>Yana qism qo'shish uchun video yuboring yoki /cancel tugmasini bosing.</b>",
                reply_markup=Keyboards.cancel_button(),
                parse_mode=ParseMode.HTML
            )
        
        logger.info(f"Admin {user_id} kurs qismi qo'shdi: {course_id} - qism {part_number}")
    except Exception as e:
        logger.error(f"Admin course add error: {e}", exc_info=True)
        await message.answer(
            f"âŒ Xatolik yuz berdi: {str(e)}\n\n"
            "Yana urinib ko'ring yoki /cancel tugmasini bosing.",
            reply_markup=Keyboards.cancel_button()
        )
    
    # State ni tozalamaymiz - cheksiz qo'shish uchun

@router.message(AdminStates.waiting_add_course_file, F.text == "/cancel")
async def handle_cancel_course(message: Message, state: FSMContext):
    """Admin: Kurs qo'shishni bekor qilish"""
    user_id = message.from_user.id
    if not await check_is_admin(user_id, db):
        return
    
    await state.clear()
    await message.answer(
        "âŒ <b>Kurs qo'shish bekor qilindi.</b>",
        reply_markup=Keyboards.admin_menu(),
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data == "top_courses")
async def handle_top_courses(callback: CallbackQuery):
    """Top kurslar"""
    await callback.answer()
    top_purchased = await db.get_top_courses(limit=5, sort_by="purchases")
    top_students = await db.get_top_courses(limit=5, sort_by="students")
    
    results_text = "ðŸ”¥ <b>TOP KURSLAR</b>\n\n"
    
    results_text += "ðŸ’° <b>Eng ko'p sotib olingan:</b>\n"
    if top_purchased:
        for i, course in enumerate(top_purchased, 1):
            purchase_count = course.get('purchase_count', course.get('students_count', 0))
            results_text += f"{i}. <b>{course.get('title', 'Noma\'lum')}</b>\n"
            results_text += f"   ðŸ’° {purchase_count} ta sotib olingan\n"
            results_text += f"   â­ {course.get('rating', 0)}/5.0\n"
            results_text += f"   ðŸ’µ {course.get('price', 19990):,} so'm\n\n"
    else:
        results_text += "Hozircha ma'lumotlar yo'q.\n\n"
    
    results_text += "ðŸ‘¥ <b>Eng ko'p talabalar:</b>\n"
    if top_students:
        for i, course in enumerate(top_students, 1):
            results_text += f"{i}. <b>{course.get('title', 'Noma\'lum')}</b>\n"
            results_text += f"   ðŸ‘¥ {course.get('students_count', 0)} talaba\n"
            results_text += f"   â­ {course.get('rating', 0)}/5.0\n"
            results_text += f"   ðŸ’µ {course.get('price', 19990):,} so'm\n\n"
    else:
        results_text += "Hozircha ma'lumotlar yo'q.\n\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ” Qidirish", callback_data="search_courses")
    builder.button(text="ðŸ’¸ Arzon kurslar", callback_data="cheap_courses")
    builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
    builder.adjust(2, 1)
    
    await callback.message.edit_text(results_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "cheap_courses")
async def handle_cheap_courses(callback: CallbackQuery):
    """Arzon kurslar"""
    await callback.answer()
    cheap_courses = await db.get_cheap_courses(max_price=15000, limit=10)
    
    if not cheap_courses:
        await callback.message.edit_text("âŒ Arzon kurslar topilmadi.", reply_markup=Keyboards.courses_menu())
        return
    
    text = "ðŸ’¸ <b>ARZON KURSLAR</b>\n\n"
    builder = InlineKeyboardBuilder()
    
    for i, course in enumerate(cheap_courses[:10], 1):
        price = course.get('discount_price') or course.get('price', 19990)
        text += f"{i}. <b>{course.get('title', 'Noma\'lum')}</b>\n"
        text += f"   ðŸ’° {price:,} so'm\n"
        text += f"   â­ {course.get('rating', 0)}/5.0\n\n"
        builder.button(text=f"ðŸ“š {i}", callback_data=f"view_course_{course.get('id')}")
    
    builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
    builder.adjust(2, 2, 2, 2, 2, 1)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.in_(["category_programming", "category_business", "category_design", "category_marketing", "category_math", "category_science", "category_management", "category_english", "category_finance", "category_ai"]))
async def handle_course_category(callback: CallbackQuery):
    """Kurs kategoriyasini tanlash (TO'LIQ FUNKSIYA)"""
    category_type = callback.data.replace("category_", "")
    user_id = callback.from_user.id
    
    category_mapping = {
        "programming": ("ðŸ’» Dasturlash", "Python, JavaScript, Java va boshqa dasturlash tillari"),
        "business": ("ðŸ’¼ Biznes", "Biznes, marketing, menejment"),
        "design": ("ðŸŽ¨ Dizayn", "Grafik dizayn, UI/UX, 3D modellashtirish"),
        "marketing": ("ðŸ“ˆ Marketing", "Digital marketing, SMM, SEO"),
        "math": ("ðŸ§® Matematika", "Matematika, statistika, hisoblash"),
        "science": ("ðŸ”¬ Fan", "Fizika, kimyo, biologiya"),
        "management": ("ðŸ‘” Menejment", "Liderlik, loyiha boshqaruvi"),
        "english": ("ðŸ‡ºðŸ‡¸ Ingliz tili", "Ingliz tili, IELTS, TOEFL"),
        "finance": ("ðŸ’° Moliya", "Investitsiya, buxgalteriya, moliyaviy savodxonlik"),
        "ai": ("ðŸ¤– Sun'iy intellekt", "AI, Machine Learning, Deep Learning")
    }
    
    if category_type not in category_mapping:
        await callback.answer("âŒ Noto'g'ri kategoriya!")
        return
    
    category_name, category_desc = category_mapping[category_type]
    
    # Real bazadan kurslarni olish
    courses = await db.get_courses_by_category(category_type, limit=20)
    
    if not courses:
        courses_text = f"ðŸŽ“ <b>{category_name}</b>\n\n{category_desc}\n\n"
        courses_text += "âŒ Hozircha bu kategoriyada kurslar mavjud emas.\n\n"
        courses_text += "ðŸ“¤ Kurs yuklash uchun admin bilan bog'laning."
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 1)
    else:
        courses_text = f"ðŸŽ“ <b>{category_name}</b>\n\n{category_desc}\n\n"
        courses_text += f"ðŸ“Š Topilgan: {len(courses)} ta kurs\n\n"
        
        builder = InlineKeyboardBuilder()
        for i, course in enumerate(courses[:10], 1):
            course_title = course.get('title', 'Noma\'lum')[:35] + "..." if len(course.get('title', '')) > 35 else course.get('title', 'Noma\'lum')
            courses_text += f"{i}. <b>{course_title}</b>\n"
            if course.get('instructor'):
                courses_text += f"   ðŸ‘¨â€ðŸ« {course['instructor']}\n"
            courses_text += f"   â­ {course.get('rating', 0):.1f}/5.0\n"
            courses_text += f"   ðŸ‘¥ {course.get('students_count', 0)} talaba\n"
            courses_text += f"   ðŸ’° {course.get('price', 19990):,} so'm\n\n"
            
            builder.button(text=f"ðŸ“š {i}. {course_title[:25]}", callback_data=f"view_course_{course.get('id')}")
        
        if len(courses) > 10:
            courses_text += f"\n... va yana {len(courses) - 10} ta kurs\n"
        
        builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
        
        if len(courses) <= 5:
            builder.adjust(1, 1, 1, 1, 1, 2, 1)
        else:
            builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1)
    
    await callback.message.edit_text(courses_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data == "my_courses")
async def handle_my_courses(callback: CallbackQuery):
    """Mening kurslarim (TO'LIQ FUNKSIYA)"""
    user_id = callback.from_user.id
    user_courses = await db.get_user_courses(user_id)
    
    if not user_courses:
        await callback.message.edit_text(
            "ðŸ“š <b>MENING KURSLARIM</b>\n\n"
            "âŒ Sizda hozircha sotib olingan kurslar yo'q.\n\n"
            "ðŸŽ“ Kurslar bo'limiga o'tib, kurs sotib oling!",
            reply_markup=Keyboards.courses_menu(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
        return
    
    courses_text = f"ðŸ“š <b>MENING KURSLARIM</b>\n\n"
    courses_text += f"ðŸ“Š Jami: {len(user_courses)} ta kurs\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, course in enumerate(user_courses[:10], 1):
        progress = course.get('progress', 0)
        completed = "âœ… Tamomlangan" if course.get('completed') else f"ðŸ“Š {progress}%"
        
        courses_text += f"{i}. <b>{course.get('title', 'Noma\'lum')}</b>\n"
        courses_text += f"   {completed}\n\n"
        
        course_title = course.get('title', 'Kurs')[:25] + "..." if len(course.get('title', '')) > 25 else course.get('title', 'Kurs')
        builder.button(text=f"ðŸ“š {course_title}", callback_data=f"access_course_{course.get('id')}")
    
    builder.button(text="ðŸ”™ Kurslar", callback_data="courses_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
    
    await callback.message.edit_text(courses_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

# ========== PODCASTS HANDLERS (YANGILANGAN) ==========

@router.callback_query(F.data == "premium_podcasts")
async def handle_premium_podcasts(callback: CallbackQuery):
    """Premium podcastlar"""
    user_id = callback.from_user.id
    analytics.track_command(user_id, "premium_podcasts")
    
    user = await db.get_user(user_id)
    if not user or user.get('subscription_type', 0) == 0:
        await callback.answer("âŒ Premium podcastlar faqat premium foydalanuvchilar uchun!", show_alert=True)
        return
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM podcasts 
            WHERE is_active = 1 
            AND (status = "approved" OR status IS NULL)
            AND is_premium = 1
            ORDER BY created_at DESC
            LIMIT 50
        ''')
        podcasts = await cursor.fetchall()
    
    if not podcasts:
        await callback.answer("âŒ Premium podcastlar topilmadi!", show_alert=True)
        return
    
    text = "â­ <b>PREMIUM PODCASTLAR</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:20], 1):
        title = podcast[1] or "Nomsiz"[:40]
        podcast_id = podcast[0]
        text += f"{i}. <b>{title}</b>\n"
        builder.button(text=f"ðŸŽ™ï¸ {title[:30]}", callback_data=f"view_podcast_{podcast_id}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "podcast_categories")
async def handle_podcast_categories(callback: CallbackQuery):
    """Podcast kategoriyalari"""
    user_id = callback.from_user.id
    analytics.track_command(user_id, "podcast_categories")
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT DISTINCT category, COUNT(*) as count 
            FROM podcasts 
            WHERE is_active = 1 
            AND category IS NOT NULL AND category != ''
            AND (status = "approved" OR status IS NULL)
            GROUP BY category
            ORDER BY count DESC
            LIMIT 30
        ''')
        categories = await cursor.fetchall()
    
    if not categories:
        await callback.answer("âŒ Kategoriyalar topilmadi!", show_alert=True)
        return
    
    text = "ðŸ“‚ <b>PODCAST KATEGORIYALARI</b>\n\n"
    text += "ðŸ“‚ <b>Kategoriyani tanlang:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    for cat_row in categories:
        category = cat_row[0] or "Boshqa"
        count = cat_row[1] or 0
        text += f"â€¢ {category} ({count} ta)\n"
        builder.button(text=f"ðŸ“‚ {category}", callback_data=f"category_podcasts_{category}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("category_podcasts_"))
async def handle_category_podcasts(callback: CallbackQuery):
    """Kategoriya bo'yicha podcastlar"""
    category = callback.data.replace("category_podcasts_", "")
    user_id = callback.from_user.id
    
    # Kategoriyada " belgisini olib tashlash
    category = category.replace('"', '').replace("'", "").strip()
    if not category or category == "":
        category = "Boshqa"
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM podcasts 
            WHERE is_active = 1 
            AND category = ?
            AND (status = "approved" OR status IS NULL)
            ORDER BY created_at DESC
            LIMIT 50
        ''', (category,))
        podcasts = await cursor.fetchall()
    
    if not podcasts:
        await callback.answer(f"âŒ '{category}' kategoriyasida podcastlar topilmadi!", show_alert=True)
        return
    
    text = f"ðŸ“‚ <b>{category.upper()} KATEGORIYASI PODCASTLARI</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:20], 1):
        title = podcast[1] or "Nomsiz"[:40]
        podcast_id = podcast[0]
        text += f"{i}. <b>{title}</b>\n"
        builder.button(text=f"ðŸŽ™ï¸ {title[:30]}", callback_data=f"view_podcast_{podcast_id}")
    
    builder.button(text="ðŸ”™ Kategoriyalar", callback_data="podcast_categories")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("view_podcast_"))
async def handle_view_podcast(callback: CallbackQuery):
    """Podcast ko'rish"""
    podcast_id = int(callback.data.replace("view_podcast_", ""))
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM podcasts WHERE id = ? AND is_active = 1
        ''', (podcast_id,))
        podcast_row = await cursor.fetchone()
    
    if not podcast_row:
        await callback.answer("âŒ Podcast topilmadi!", show_alert=True)
        return
    
    podcast = {
        'id': podcast_row[0],
        'title': podcast_row[1] or "Nomsiz",
        'description': podcast_row[2] or "Tavsif mavjud emas",
        'file_id': podcast_row[3],
        'video_file_id': podcast_row[4],
        'category': podcast_row[5] or "Boshqa",
        'host': podcast_row[6] or "Noma'lum",
        'language': podcast_row[7] or "uz",
        'content_type': podcast_row[8] or "audio",
        'is_premium': podcast_row[9] or 0,
        'downloads': podcast_row[10] or 0,
        'rating': podcast_row[11] or 0.0,
        'rating_count': podcast_row[12] or 0
    }
    
    user = await db.get_user(user_id)
    is_premium = user and user.get('subscription_type', 0) > 0
    
    if podcast['is_premium'] and not is_premium:
        await callback.answer("âŒ Bu podcast faqat premium foydalanuvchilar uchun!", show_alert=True)
        return
    
    text = f"""
ðŸŽ™ï¸ <b>{podcast['title']}</b>

ðŸ“ <b>Tavsif:</b>
{podcast['description'][:500]}

ðŸŽ™ï¸ <b>Host:</b> {podcast['host']}
ðŸ“‚ <b>Kategoriya:</b> {podcast['category']}
ðŸŒ <b>Til:</b> {'ðŸ‡ºðŸ‡¿ O\'zbek' if podcast['language'] == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}
â­ <b>Reyting:</b> {podcast['rating']:.1f}/5.0 ({podcast['rating_count']} ta baholash)
ðŸ“Š <b>Yuklashlar:</b> {podcast['downloads']}
    """
    
    builder = InlineKeyboardBuilder()
    
    if podcast['content_type'] == 'video' and podcast['video_file_id']:
        builder.button(text="ðŸŽ¬ Video ko'rish", callback_data=f"watch_podcast_{podcast_id}")
    elif podcast['file_id']:
        builder.button(text="ðŸŽ§ Audio tinglash", callback_data=f"listen_podcast_{podcast_id}")
    
    builder.button(text="â­ Baholash", callback_data=f"rate_podcast_{podcast_id}")
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

# DUPLICATE HANDLER REMOVED - using the more complete handler below that supports both audio/video and premium checks

@router.callback_query(F.data.startswith("watch_podcast_"))
async def handle_watch_podcast(callback: CallbackQuery):
    """Podcast video ko'rish"""
    podcast_id = int(callback.data.replace("watch_podcast_", ""))
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT video_file_id, title FROM podcasts WHERE id = ? AND is_active = 1
        ''', (podcast_id,))
        podcast = await cursor.fetchone()
    
    if not podcast or not podcast[0]:
        await callback.answer("âŒ Podcast topilmadi!", show_alert=True)
        return
    
    try:
        await bot.send_video(
            chat_id=user_id,
            video=podcast[0],
            caption=f"ðŸŽ¬ {podcast[1] or 'Video Podcast'}"
        )
        
        # Download history
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE podcasts SET downloads = downloads + 1 WHERE id = ?
            ''', (podcast_id,))
            await conn.execute('''
                INSERT INTO download_history (user_id, content_type, content_id, downloaded_at)
                VALUES (?, 'podcast', ?, datetime('now'))
            ''', (user_id, podcast_id))
            await conn.commit()
        
        await callback.answer("âœ… Video podcast yuborildi!")
    except Exception as e:
        logger.error(f"Watch podcast error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data.startswith("rate_podcast_"))
async def handle_rate_podcast(callback: CallbackQuery):
    """Podcast baholash"""
    podcast_id = int(callback.data.replace("rate_podcast_", ""))
    user_id = callback.from_user.id
    
    text = """
â­ <b>PODCAST BAHOLASH</b>

ðŸ“ <b>Reytingni tanlang:</b>

1 â­ - Juda yomon
2 â­ - Yomon
3 â­ - O'rtacha
4 â­ - Yaxshi
5 â­ - Juda yaxshi
    """
    
    builder = InlineKeyboardBuilder()
    for i in range(1, 6):
        builder.button(text=f"{'â­' * i}", callback_data=f"set_podcast_rating_{podcast_id}_{i}")
    builder.button(text="ðŸ”™ Orqaga", callback_data=f"view_podcast_{podcast_id}")
    builder.adjust(1, 1, 1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("set_podcast_rating_"))
async def handle_set_podcast_rating(callback: CallbackQuery):
    """Podcast reytingini saqlash"""
    parts = callback.data.replace("set_podcast_rating_", "").split("_")
    podcast_id = int(parts[0])
    rating = int(parts[1])
    user_id = callback.from_user.id
    
    try:
        async with db.connect() as conn:
            # Eski reytingni olish
            cursor = await conn.execute('''
                SELECT rating, rating_count FROM podcasts WHERE id = ?
            ''', (podcast_id,))
            old_data = await cursor.fetchone()
            
            if old_data:
                old_rating = old_data[0] or 0.0
                old_count = old_data[1] or 0
                
                # Yangi reyting hisoblash
                new_count = old_count + 1
                new_rating = ((old_rating * old_count) + rating) / new_count
                
                await conn.execute('''
                    UPDATE podcasts SET rating = ?, rating_count = ? WHERE id = ?
                ''', (new_rating, new_count, podcast_id))
                await conn.commit()
        
        await callback.answer(f"âœ… {rating} â­ reyting qo'shildi!", show_alert=True)
        
        # Podcast sahifasiga qaytish
        await handle_view_podcast(callback)
    except Exception as e:
        logger.error(f"Rate podcast error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data.startswith("access_course_"))
async def handle_access_course(callback: CallbackQuery):
    """Kursga kirish"""
    course_id = int(callback.data.replace("access_course_", ""))
    user_id = callback.from_user.id
    
    # Foydalanuvchi kursga ega ekanligini tekshirish
    user_courses = await db.get_user_courses(user_id)
    has_access = any(c.get('id') == course_id for c in user_courses)
    
    if not has_access:
        await callback.answer("âŒ Sizda bu kursga kirish huquqi yo'q!", show_alert=True)
        return
    
    course = await db.get_course(course_id)
    if not course:
        await callback.answer("âŒ Kurs topilmadi!", show_alert=True)
        return
    
    # Kurs videolarini olish
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT * FROM course_videos WHERE course_id = ? ORDER BY video_order ASC
        ''', (course_id,))
        videos = await cursor.fetchall()
    
    if not videos:
        await callback.answer("âŒ Kurs videolari topilmadi!", show_alert=True)
        return
    
    text = f"""
ðŸŽ“ <b>{course.get('title', 'Kurs')}</b>

ðŸ“¹ <b>Kurs videolari:</b>
ðŸ“Š Jami: {len(videos)} ta video

ðŸ‘‡ <b>Videoni tanlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    for i, video in enumerate(videos[:10], 1):
        video_title = video[3] or f"Video {i}"
        video_id = video[0]
        builder.button(text=f"ðŸ“¹ {video_title[:30]}", callback_data=f"watch_course_video_{video_id}")
    
    if len(videos) > 10:
        text += f"\n... va yana {len(videos) - 10} ta video"
    
    builder.button(text="ðŸ”™ Mening kurslarim", callback_data="my_courses")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("watch_course_video_"))
async def handle_watch_course_video(callback: CallbackQuery):
    """Kurs videoni ko'rish"""
    video_id = int(callback.data.replace("watch_course_video_", ""))
    user_id = callback.from_user.id
    
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT cv.video_id, cv.title, c.title as course_title
            FROM course_videos cv
            JOIN courses c ON cv.course_id = c.id
            WHERE cv.id = ?
        ''', (video_id,))
        video = await cursor.fetchone()
    
    if not video or not video[0]:
        await callback.answer("âŒ Video topilmadi!", show_alert=True)
        return
    
    try:
        await bot.send_video(
            chat_id=user_id,
            video=video[0],
            caption=f"ðŸŽ“ {video[2] or 'Kurs'}\nðŸ“¹ {video[1] or 'Video'}"
        )
        await callback.answer("âœ… Video yuborildi!")
    except Exception as e:
        logger.error(f"Watch course video error: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data == "random_podcast_uz")
async def handle_random_podcast_uz(callback: CallbackQuery):
    """O'zbek tilida tasodifiy podcast"""
    podcasts = await db.get_random_podcasts(limit=1, language="uz")
    
    if not podcasts:
        await callback.answer("âŒ Hozircha o'zbek tilida podcastlar yo'q!", show_alert=True)
        return
    
    podcast = podcasts[0]
    podcast_id = podcast.get('id')
    
    text = f"""
ðŸŽ™ï¸ <b>{podcast.get('title', 'Nomsiz')}</b>

ðŸ“ {podcast.get('description', 'Tavsif mavjud emas')}
ðŸŽ™ï¸ Host: {podcast.get('host', 'Noma\'lum')}
ðŸ“‚ Kategoriya: {podcast.get('category', 'Boshqa')}
ðŸŒ Til: ðŸ‡ºðŸ‡¿ O'zbek
â­ Reyting: {podcast.get('rating', 0):.1f}/5.0 ({podcast.get('rating_count', 0)} ta baholash)
ðŸ“Š Yuklashlar: {podcast.get('downloads', 0)}
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ§ Tinglash", callback_data=f"listen_podcast_{podcast_id}")
    builder.button(text="ðŸŽ² Yana o'zbek podcast", callback_data="random_podcast_uz")
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "random_podcast_en")
async def handle_random_podcast_en(callback: CallbackQuery):
    """English tilida tasodifiy podcast"""
    podcasts = await db.get_random_podcasts(limit=1, language="en")
    
    if not podcasts:
        await callback.answer("âŒ Hozircha English tilida podcastlar yo'q!", show_alert=True)
        return
    
    podcast = podcasts[0]
    podcast_id = podcast.get('id')
    
    text = f"""
ðŸŽ™ï¸ <b>{podcast.get('title', 'Nomsiz')}</b>

ðŸ“ {podcast.get('description', 'Tavsif mavjud emas')}
ðŸŽ™ï¸ Host: {podcast.get('host', 'Noma\'lum')}
ðŸ“‚ Category: {podcast.get('category', 'Other')}
ðŸŒ Language: ðŸ‡¬ðŸ‡§ English
â­ Rating: {podcast.get('rating', 0):.1f}/5.0 ({podcast.get('rating_count', 0)} ratings)
ðŸ“Š Downloads: {podcast.get('downloads', 0)}
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ§ Listen", callback_data=f"listen_podcast_{podcast_id}")
    builder.button(text="ðŸŽ² Another English podcast", callback_data="random_podcast_en")
    builder.button(text="ðŸ”™ Podcasts", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Main menu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "podcasts_menu")
async def handle_podcasts_menu(callback: CallbackQuery):
    """Podcastlar menyusi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    subscription_type = user.get('subscription_type', 0) if user else 0
    
    menu_text = f"""
ðŸŽ™ï¸ <b>PODCASTLAR</b>

ðŸ“š <b>Mavjud funksiyalar:</b>
â€¢ ðŸ” Qidirish - Podcastlarni qidirish
â€¢ ðŸ“‚ Kategoriyalar - Kategoriya bo'yicha
â€¢ ðŸ”¥ Top podcastlar - Eng ko'p tinglanganlar
â€¢ ðŸŽ² O'zbek podcastlar - Tasodifiy o'zbek podcastlar
â€¢ ðŸŽ² English podcasts - Tasodifiy ingliz podcastlar
â€¢ ðŸŽ¬ Video majmua - Video podcastlar
â€¢ ðŸ’ª Motivatsion - Motivatsion podcastlar
{f"â€¢ â­ Premium podcastlar - Premium kontent" if subscription_type >= 2 else ""}

ðŸ’¡ <b>Maslahat:</b>
â€¢ Har bir podcastni to'liq tinglash mumkin
â€¢ Video podcastlarni ko'rish mumkin
â€¢ Kategoriya bo'yicha qidirish mumkin

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
    """
    
    await safe_edit_text(callback, menu_text, reply_markup=Keyboards.podcasts_menu(subscription_type))
    await callback.answer()

@router.callback_query(F.data == "video_podcasts")
async def handle_video_podcasts(callback: CallbackQuery):
    """Video podcastlar majmuasi"""
    user_id = callback.from_user.id
    podcasts = await db.get_video_podcasts(limit=20)
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸŽ¬ <b>VIDEO PODCASTLAR</b>\n\n"
            "âŒ Hozircha video podcastlar mavjud emas.\n\n"
            "ðŸ’¡ Adminlar video podcastlar qo'shganda bu yerda ko'rinadi.",
            reply_markup=Keyboards.back_button("podcasts_menu")
        )
        await callback.answer()
        return
    
    text = "ðŸŽ¬ <b>VIDEO PODCASTLAR</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:15], 1):
        podcast_title = podcast.get('title', 'Nomsiz')[:40]
        text += f"{i}. <b>{podcast_title}</b>\n"
        if podcast.get('host'):
            text += f"   ðŸŽ™ï¸ {podcast.get('host')}\n"
        if podcast.get('category'):
            text += f"   ðŸ“‚ {podcast.get('category')}\n"
        text += f"   ðŸ“¥ {podcast.get('downloads', 0)} yuklash\n\n"
        builder.button(text=f"ðŸŽ¬ {podcast_title[:30]}", callback_data=f"view_podcast_{podcast.get('id')}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "motivational_podcasts")
async def handle_motivational_podcasts(callback: CallbackQuery):
    """Motivatsion podcastlar"""
    user_id = callback.from_user.id
    podcasts = await db.get_motivational_podcasts(limit=20)
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸ’ª <b>MOTIVATSION PODCASTLAR</b>\n\n"
            "âŒ Hozircha motivatsion podcastlar mavjud emas.\n\n"
            "ðŸ’¡ Adminlar motivatsion podcastlar qo'shganda bu yerda ko'rinadi.",
            reply_markup=Keyboards.back_button("podcasts_menu")
        )
        await callback.answer()
        return
    
    text = "ðŸ’ª <b>MOTIVATSION PODCASTLAR</b>\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:15], 1):
        podcast_title = podcast.get('title', 'Nomsiz')[:40]
        text += f"{i}. <b>{podcast_title}</b>\n"
        if podcast.get('host'):
            text += f"   ðŸŽ™ï¸ {podcast.get('host')}\n"
        text += f"   ðŸ“¥ {podcast.get('downloads', 0)} yuklash\n\n"
        builder.button(text=f"ðŸ’ª {podcast_title[:30]}", callback_data=f"view_podcast_{podcast.get('id')}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "top_podcasts")
async def handle_top_podcasts(callback: CallbackQuery):
    """Top podcastlar"""
    user_id = callback.from_user.id
    podcasts = await db.get_top_podcasts(limit=20)
    
    if not podcasts:
        await safe_edit_text(callback,
            "ðŸ”¥ <b>TOP PODCASTLAR</b>\n\n"
            "âŒ Hozircha podcastlar mavjud emas.\n\n"
            "ðŸ’¡ Adminlar podcastlar qo'shganda bu yerda ko'rinadi.",
            reply_markup=Keyboards.back_button("podcasts_menu")
        )
        await callback.answer()
        return
    
    text = "ðŸ”¥ <b>TOP PODCASTLAR</b>\n\n"
    text += f"ðŸ“Š Eng ko'p tinglanganlar: {len(podcasts)} ta\n\n"
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(podcasts[:15], 1):
        podcast_title = podcast.get('title', 'Nomsiz')[:40]
        downloads = podcast.get('downloads', 0)
        rating = podcast.get('rating', 0)
        text += f"{i}. <b>{podcast_title}</b>\n"
        text += f"   â­ {rating:.1f}/5.0 | ðŸ“¥ {downloads} yuklash\n\n"
        builder.button(text=f"ðŸŽ™ï¸ {podcast_title[:30]}", callback_data=f"view_podcast_{podcast.get('id')}")
    
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "search_podcasts")
async def handle_search_podcasts(callback: CallbackQuery, state: FSMContext):
    """Podcast qidirish"""
    user_id = callback.from_user.id
    
    await safe_edit_text(callback,
        "ðŸ” <b>PODCAST QIDIRISH</b>\n\n"
        "ðŸ“ <b>Podcast nomini yoki kategoriyasini yozing:</b>\n\n"
        "âŒ Bekor qilish: /cancel",
        reply_markup=Keyboards.cancel_button()
    )
    await state.set_state(UserStates.waiting_podcast_search)
    await callback.answer("âœ… Qidiruv rejimi yoqildi!")

@router.message(UserStates.waiting_podcast_search)
async def handle_search_podcast_query(message: Message, state: FSMContext):
    """Podcast qidiruv natijalari"""
    user_id = message.from_user.id
    
    if message.text == "/cancel":
        await state.clear()
        await message.answer("âŒ Qidiruv bekor qilindi.", reply_markup=Keyboards.podcasts_menu(0))
        return
    
    query = message.text.strip()
    if len(query) < 2:
        await message.answer("âŒ Qidiruv so'zi juda qisqa! Kamida 2 belgi bo'lishi kerak.")
        return
    
    podcasts = await db.search_podcasts(query, limit=50)
    
    if not podcasts:
        await message.answer(
            f"âŒ '{query}' bo'yicha podcast topilmadi.\n\n"
            "ðŸ’¡ <b>Maslahat:</b>\n"
            "â€¢ Podcast nomini to'liq yozing\n"
            "â€¢ Kategoriya bo'yicha qidiring\n"
            "â€¢ Host nomini yozib ko'ring",
            reply_markup=Keyboards.back_button("podcasts_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
        return
    
    # Pagination
    page = 0
    items_per_page = 10
    total_pages = (len(podcasts) + items_per_page - 1) // items_per_page if podcasts else 0
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n"
    text += f"ðŸ“„ Sahifa: {page + 1}/{total_pages}\n\n"
    
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_podcasts = podcasts[start_idx:end_idx]
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(current_podcasts, start_idx + 1):
        podcast_title = podcast.get('title', 'Nomsiz')[:40]
        text += f"{i}. <b>{podcast_title}</b>\n"
        if podcast.get('host'):
            text += f"   ðŸŽ™ï¸ {podcast.get('host')}\n"
        if podcast.get('category'):
            text += f"   ðŸ“‚ {podcast.get('category')}\n"
        text += f"   ðŸ“¥ {podcast.get('downloads', 0)} yuklash\n\n"
        builder.button(text=f"ðŸŽ™ï¸ {podcast_title[:30]}", callback_data=f"view_podcast_{podcast.get('id')}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_buttons = []
        if page > 0:
            pagination_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Orqaga", callback_data=f"search_page_podcasts_{page - 1}"))
        if page < total_pages - 1:
            pagination_buttons.append(InlineKeyboardButton(text="âž¡ï¸ Keyingi", callback_data=f"search_page_podcasts_{page + 1}"))
        if pagination_buttons:
            builder.row(*pagination_buttons)
    
    # State'ga saqlash
    await state.update_data(
        search_query=query,
        search_results=podcasts,
        search_type="podcasts",
        current_page=page
    )
    
    builder.button(text="ðŸ” Qayta qidirish", callback_data="search_podcasts")
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    if len(current_podcasts) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await state.clear()

@router.callback_query(F.data.startswith("search_page_podcasts_"))
async def handle_search_podcasts_page(callback: CallbackQuery, state: FSMContext):
    """Podcast qidiruv sahifasi"""
    page = int(callback.data.replace("search_page_podcasts_", ""))
    user_id = callback.from_user.id
    
    data = await state.get_data()
    query = data.get('search_query', '')
    podcasts = data.get('search_results', [])
    
    if not podcasts:
        await callback.answer("âŒ Qidiruv natijalari topilmadi!", show_alert=True)
        return
    
    items_per_page = 10
    total_pages = (len(podcasts) + items_per_page - 1) // items_per_page
    
    if page < 0 or page >= total_pages:
        await callback.answer("âŒ Noto'g'ri sahifa!", show_alert=True)
        return
    
    text = f"ðŸ” <b>QIDIRUV NATIJALARI:</b> '{query}'\n\n"
    text += f"ðŸ“Š Topilgan: {len(podcasts)} ta\n"
    text += f"ðŸ“„ Sahifa: {page + 1}/{total_pages}\n\n"
    
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_podcasts = podcasts[start_idx:end_idx]
    
    builder = InlineKeyboardBuilder()
    for i, podcast in enumerate(current_podcasts, start_idx + 1):
        podcast_title = podcast.get('title', 'Nomsiz')[:40]
        text += f"{i}. <b>{podcast_title}</b>\n"
        if podcast.get('host'):
            text += f"   ðŸŽ™ï¸ {podcast.get('host')}\n"
        if podcast.get('category'):
            text += f"   ðŸ“‚ {podcast.get('category')}\n"
        text += f"   ðŸ“¥ {podcast.get('downloads', 0)} yuklash\n\n"
        builder.button(text=f"ðŸŽ™ï¸ {podcast_title[:30]}", callback_data=f"view_podcast_{podcast.get('id')}")
    
    # Pagination tugmalari
    if total_pages > 1:
        pagination_buttons = []
        if page > 0:
            pagination_buttons.append(InlineKeyboardButton(text="â¬…ï¸ Orqaga", callback_data=f"search_page_podcasts_{page - 1}"))
        if page < total_pages - 1:
            pagination_buttons.append(InlineKeyboardButton(text="âž¡ï¸ Keyingi", callback_data=f"search_page_podcasts_{page + 1}"))
        if pagination_buttons:
            builder.row(*pagination_buttons)
    
    await state.update_data(current_page=page)
    
    builder.button(text="ðŸ” Qayta qidirish", callback_data="search_podcasts")
    builder.button(text="ðŸ”™ Podcastlar", callback_data="podcasts_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    
    if len(current_podcasts) <= 5:
        builder.adjust(1, 1, 1, 1, 1, 2, 1, 1)
    else:
        builder.adjust(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("listen_podcast_"))
async def handle_listen_podcast(callback: CallbackQuery):
    """Podcastni tinglash/yuklab olish (audio va video)"""
    podcast_id = int(callback.data.replace("listen_podcast_", ""))
    user_id = callback.from_user.id
    
    podcast = await db.get_podcast(podcast_id)
    if not podcast:
        await callback.answer("âŒ Podcast topilmadi!", show_alert=True)
        return
    
    # Premium tekshiruvi
    user = await db.get_user(user_id)
    subscription_type = user.get('subscription_type', 0) if user else 0
    
    if podcast.get('is_premium', 0) and subscription_type < 2:
        await callback.answer(
            "âŒ Bu podcast faqat Premium foydalanuvchilar uchun!\n\n"
            "ðŸ’Ž Premium obuna olish uchun 'Premium' tugmasini bosing.",
            show_alert=True
        )
        return
    
    content_type = podcast.get('content_type', 'audio')
    file_id = podcast.get('file_id')
    video_file_id = podcast.get('video_file_id')
    
    # Podcast yuklashlar sonini oshirish
    async with db.connect() as conn:
        await conn.execute('UPDATE podcasts SET downloads = downloads + 1 WHERE id = ?', (podcast_id,))
        await conn.commit()
    
    # Audio yoki video faylni yuborish
    try:
        if content_type == 'video' and video_file_id:
            await bot.send_video(
                user_id,
                video_file_id,
                caption=f"ðŸŽ¬ <b>{podcast.get('title', 'Podcast')}</b>\n\n"
                       f"ðŸŽ™ï¸ Host: {podcast.get('host', 'Noma\'lum')}\n"
                       f"ðŸ“‚ Kategoriya: {podcast.get('category', 'Boshqa')}\n"
                       f"ðŸŒ Til: {'ðŸ‡ºðŸ‡¿ O\'zbek' if podcast.get('language') == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}",
                parse_mode=ParseMode.HTML
            )
        elif file_id:
            await bot.send_audio(
                user_id,
                file_id,
                caption=f"ðŸŽ™ï¸ <b>{podcast.get('title', 'Podcast')}</b>\n\n"
                       f"ðŸŽ™ï¸ Host: {podcast.get('host', 'Noma\'lum')}\n"
                       f"ðŸ“‚ Kategoriya: {podcast.get('category', 'Boshqa')}\n"
                       f"ðŸŒ Til: {'ðŸ‡ºðŸ‡¿ O\'zbek' if podcast.get('language') == 'uz' else 'ðŸ‡¬ðŸ‡§ English'}",
                parse_mode=ParseMode.HTML
            )
        else:
            await callback.answer("âŒ Podcast fayli topilmadi!", show_alert=True)
            return
        
        await callback.answer("âœ… Podcast yuborildi!")
    except Exception as e:
        logger.error(f"Podcast yuborish xatosi: {e}")
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

@router.callback_query(F.data.startswith("buy_course_"))
async def handle_buy_course(callback: CallbackQuery):
    """Kurs sotib olish - to'lov so'rovi"""
    course_id = int(callback.data.replace("buy_course_", ""))
    user_id = callback.from_user.id
    user_name = callback.from_user.full_name or f"User_{user_id}"
    
    course = await db.get_course(course_id)
    if not course:
        await callback.answer("âŒ Kurs topilmadi!", show_alert=True)
        return
    
    price = course.get('price', 19990)
    course_title = course.get('title', 'Kurs')
    
    # To'lov kartalarini olish
    cards = await db.get_payment_cards()
    
    if not cards:
        await callback.message.edit_text(
            "âŒ <b>To'lov kartalari sozlanmagan!</b>\n\n"
            "Admin bilan bog'laning: @admin",
            reply_markup=InlineKeyboardBuilder()
                .button(text="ðŸ”™ Orqaga", callback_data=f"view_course_{course_id}")
                .as_markup(),
            parse_mode=ParseMode.HTML
        )
        return
    
    # To'lov kartalarini ko'rsatish
    cards_text = ""
    for card in cards[:3]:
        cards_text += f"ðŸ’³ <code>{card.get('card_number', '')}</code>\n"
        cards_text += f"   ðŸ‘¤ {card.get('card_name', '')}\n\n"
    
    text = f"""
ðŸ’° <b>KURS SOTIB OLISH</b>

ðŸŽ“ <b>Kurs:</b> {course_title}
ðŸ’µ <b>Narx:</b> {price:,} so'm

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>TO'LOV QILISH UCHUN:</b>

{cards_text}
<b>Qadamlar:</b>
1ï¸âƒ£ Yuqoridagi kartaga <b>{price:,} so'm</b> o'tkazing
2ï¸âƒ£ Chek rasmini yuboring
3ï¸âƒ£ Admin tasdiqlashini kuting (1-24 soat)

âš ï¸ <b>Muhim:</b> To'lov izohiga Telegram ID yozing:
<code>{user_id}</code>

ðŸ”œ <i>Tez orada Click/Payme integratsiyasi qo'shiladi!</i>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“¸ Chek yuborish", callback_data=f"send_course_receipt_{course_id}")
    builder.button(text="â“ Yordam", callback_data="payment_help")
    builder.button(text="ðŸ”™ Orqaga", callback_data=f"view_course_{course_id}")
    builder.adjust(1, 1, 1)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer()

@router.callback_query(F.data.startswith("send_course_receipt_"))
async def handle_send_course_receipt(callback: CallbackQuery, state: FSMContext):
    """Kurs uchun chek yuborish"""
    course_id = int(callback.data.replace("send_course_receipt_", ""))
    
    course = await db.get_course(course_id)
    if not course:
        await callback.answer("âŒ Kurs topilmadi!", show_alert=True)
        return
    
    await state.update_data(pending_course_id=course_id, pending_course_price=course.get('price', 19990))
    await state.set_state(UserStates.waiting_course_receipt)
    
    await callback.message.edit_text(
        f"ðŸ“¸ <b>CHEK YUBORISH</b>\n\n"
        f"ðŸŽ“ <b>Kurs:</b> {course.get('title', 'Kurs')}\n"
        f"ðŸ’° <b>Narx:</b> {course.get('price', 19990):,} so'm\n\n"
        f"To'lov cheki rasmini yuboring.\n"
        f"<i>Rasm yoki screenshot bo'lishi kerak.</i>",
        reply_markup=InlineKeyboardBuilder()
            .button(text="âŒ Bekor qilish", callback_data=f"view_course_{course_id}")
            .as_markup(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

@router.callback_query(F.data == "payment_help")
async def handle_payment_help(callback: CallbackQuery):
    """To'lov yordami"""
    text = """
â“ <b>TO'LOV YORDAMI</b>

<b>Qanday to'lash mumkin?</b>

1ï¸âƒ£ <b>Karta orqali:</b>
   â€¢ Yuqoridagi kartaga pul o'tkazing
   â€¢ Chek rasmini yuboring
   â€¢ Admin tasdiqlashini kuting

2ï¸âƒ£ <b>Click/Payme (tez orada):</b>
   â€¢ Avtomatik to'lov
   â€¢ Darhol aktivatsiya

<b>Muammo bo'lsa:</b>
â€¢ Admin: @admin
â€¢ Yordam: /help

<b>Qaytarish siyosati:</b>
â€¢ 24 soat ichida to'liq qaytarish
â€¢ Kursni ko'rmagan bo'lishingiz kerak
    """
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardBuilder()
            .button(text="ðŸ”™ Orqaga", callback_data="courses_menu")
            .as_markup(),
        parse_mode=ParseMode.HTML
    )
    await callback.answer()

# Kurs uchun chek qabul qilish
@router.message(UserStates.waiting_course_receipt, F.photo)
async def handle_course_receipt_photo(message: Message, state: FSMContext):
    """Kurs to'lov cheki qabul qilish"""
    user_id = message.from_user.id
    user_name = message.from_user.full_name or f"User_{user_id}"
    username = message.from_user.username or "username_yoq"
    
    data = await state.get_data()
    course_id = data.get('pending_course_id')
    price = data.get('pending_course_price', 19990)
    
    if not course_id:
        await message.answer("âŒ Xatolik! Qaytadan urinib ko'ring.")
        await state.clear()
        return
    
    course = await db.get_course(course_id)
    if not course:
        await message.answer("âŒ Kurs topilmadi!")
        await state.clear()
        return
    
    course_title = course.get('title', 'Kurs')
    photo_id = message.photo[-1].file_id
    
    # Pending course purchase jadvaliga qo'shish
    async with db.connect() as conn:
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS pending_course_purchases (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                course_id INTEGER,
                price INTEGER,
                receipt_photo_id TEXT,
                status TEXT DEFAULT 'pending',
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                reviewed_at TEXT,
                reviewed_by INTEGER
            )
        ''')
        await conn.execute('''
            INSERT INTO pending_course_purchases (user_id, course_id, price, receipt_photo_id)
            VALUES (?, ?, ?, ?)
        ''', (user_id, course_id, price, photo_id))
        await conn.commit()
    
    # Foydalanuvchiga tasdiqlash
    await message.answer(
        f"âœ… <b>Chek qabul qilindi!</b>\n\n"
        f"ðŸŽ“ <b>Kurs:</b> {course_title}\n"
        f"ðŸ’° <b>Narx:</b> {price:,} so'm\n\n"
        f"â³ Admin tekshirishi kutilmoqda...\n"
        f"<i>Odatda 1-24 soat ichida tasdiqlanadi.</i>",
        reply_markup=InlineKeyboardBuilder()
            .button(text="ðŸ“š Kurslar", callback_data="courses_menu")
            .as_markup(),
        parse_mode=ParseMode.HTML
    )
    
    # Adminlarga xabar yuborish
    admin_text = f"""
ðŸ†• <b>YANGI KURS TO'LOVI!</b>

ðŸ‘¤ <b>Foydalanuvchi:</b> {user_name}
ðŸ†” <b>ID:</b> <code>{user_id}</code>
ðŸ“± <b>Username:</b> @{username}

ðŸŽ“ <b>Kurs:</b> {course_title}
ðŸ’° <b>Narx:</b> {price:,} so'm

â³ <b>Holat:</b> Kutilmoqda
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âœ… Tasdiqlash", callback_data=f"approve_course_payment_{user_id}_{course_id}")
    builder.button(text="âŒ Rad etish", callback_data=f"reject_course_payment_{user_id}_{course_id}")
    builder.adjust(2)
    
    for admin_id in Config.ADMIN_IDS:
        try:
            # Chek rasmini yuborish
            await bot.send_photo(
                chat_id=admin_id,
                photo=photo_id,
                caption=admin_text,
                reply_markup=builder.as_markup(),
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            logger.error(f"Admin {admin_id} ga xabar yuborishda xatolik: {e}")
    
    await state.clear()

@router.message(UserStates.waiting_course_receipt)
async def handle_course_receipt_invalid(message: Message, state: FSMContext):
    """Noto'g'ri format"""
    await message.answer(
        "âŒ Iltimos, to'lov cheki <b>rasmini</b> yuboring!\n"
        "<i>Faqat rasm qabul qilinadi.</i>",
        parse_mode=ParseMode.HTML
    )

# Admin: Kurs to'lovini tasdiqlash
@router.callback_query(F.data.startswith("approve_course_payment_"))
async def handle_approve_course_payment(callback: CallbackQuery):
    """Kurs to'lovini tasdiqlash"""
    if callback.from_user.id not in Config.ADMIN_IDS:
        await callback.answer("âŒ Sizda ruxsat yo'q!", show_alert=True)
        return
    
    parts = callback.data.replace("approve_course_payment_", "").split("_")
    user_id = int(parts[0])
    course_id = int(parts[1])
    
    course = await db.get_course(course_id)
    if not course:
        await callback.answer("âŒ Kurs topilmadi!", show_alert=True)
        return
    
    price = course.get('price', 19990)
    course_title = course.get('title', 'Kurs')
    
    # Kursni sotib olish
    success = await db.purchase_course(user_id, course_id, price)
    
    if success:
        # Pending statusini yangilash
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE pending_course_purchases 
                SET status = 'approved', reviewed_at = CURRENT_TIMESTAMP, reviewed_by = ?
                WHERE user_id = ? AND course_id = ? AND status = 'pending'
            ''', (callback.from_user.id, user_id, course_id))
            await conn.commit()
        
        # Foydalanuvchiga xabar
        try:
            await bot.send_message(
                chat_id=user_id,
                text=f"ðŸŽ‰ <b>TABRIKLAYMIZ!</b>\n\n"
                     f"âœ… Sizning to'lovingiz tasdiqlandi!\n\n"
                     f"ðŸŽ“ <b>Kurs:</b> {course_title}\n"
                     f"ðŸ’° <b>Narx:</b> {price:,} so'm\n\n"
                     f"Endi kursga kirishingiz mumkin!",
                reply_markup=InlineKeyboardBuilder()
                    .button(text="ðŸ“š Kursga kirish", callback_data=f"access_course_{course_id}")
                    .as_markup(),
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            logger.error(f"Foydalanuvchiga xabar yuborishda xatolik: {e}")
        
        # Admin xabarini yangilash
        await callback.message.edit_caption(
            caption=callback.message.caption + f"\n\nâœ… <b>TASDIQLANDI</b> - {callback.from_user.full_name}",
            parse_mode=ParseMode.HTML
        )
        await callback.answer("âœ… To'lov tasdiqlandi!")
    else:
        await callback.answer("âŒ Xatolik yuz berdi!", show_alert=True)

# Admin: Kurs to'lovini rad etish
@router.callback_query(F.data.startswith("reject_course_payment_"))
async def handle_reject_course_payment(callback: CallbackQuery):
    """Kurs to'lovini rad etish"""
    if callback.from_user.id not in Config.ADMIN_IDS:
        await callback.answer("âŒ Sizda ruxsat yo'q!", show_alert=True)
        return
    
    parts = callback.data.replace("reject_course_payment_", "").split("_")
    user_id = int(parts[0])
    course_id = int(parts[1])
    
    course = await db.get_course(course_id)
    course_title = course.get('title', 'Kurs') if course else 'Kurs'
    
    # Pending statusini yangilash
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE pending_course_purchases 
            SET status = 'rejected', reviewed_at = CURRENT_TIMESTAMP, reviewed_by = ?
            WHERE user_id = ? AND course_id = ? AND status = 'pending'
        ''', (callback.from_user.id, user_id, course_id))
        await conn.commit()
    
    # Foydalanuvchiga xabar
    try:
        await bot.send_message(
            chat_id=user_id,
            text=f"âŒ <b>TO'LOV RAD ETILDI</b>\n\n"
                 f"ðŸŽ“ <b>Kurs:</b> {course_title}\n\n"
                 f"<b>Sabab:</b> To'lov tasdiqlanmadi.\n"
                 f"Iltimos, to'g'ri chek yuboring yoki admin bilan bog'laning.",
            reply_markup=InlineKeyboardBuilder()
                .button(text="ðŸ”„ Qayta urinish", callback_data=f"buy_course_{course_id}")
                .button(text="ðŸ“ž Yordam", callback_data="payment_help")
                .adjust(1)
                .as_markup(),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Foydalanuvchiga xabar yuborishda xatolik: {e}")
    
    # Admin xabarini yangilash
    await callback.message.edit_caption(
        caption=callback.message.caption + f"\n\nâŒ <b>RAD ETILDI</b> - {callback.from_user.full_name}",
        parse_mode=ParseMode.HTML
    )
    await callback.answer("âŒ To'lov rad etildi!")

@router.callback_query(F.data.startswith("demo_course_"))
async def handle_demo_course(callback: CallbackQuery):
    """Kurs demo videosini ko'rish"""
    course_id = int(callback.data.replace("demo_course_", ""))
    demo_video_id = await db.get_course_demo_video(course_id)
    
    if not demo_video_id:
        await callback.answer("âŒ Demo video topilmadi!", show_alert=True)
        return
    
    course = await db.get_course(course_id)
    course_title = course.get('title', 'Kurs') if course else 'Kurs'
    
    try:
        await bot.send_video(
            chat_id=callback.from_user.id,
            video=demo_video_id,
            caption=f"ðŸŽ¬ <b>DEMO VIDEO</b>\n\n"
                   f"ðŸŽ“ Kurs: {course_title}\n"
                   f"ðŸ“š Bu kursning birinchi videosi\n\n"
                   f"ðŸ’¡ <b>To'liq kursni sotib oling va barcha videolarga ega bo'ling!</b>",
            reply_markup=InlineKeyboardBuilder()
                .button(text="ðŸ’° Sotib olish", callback_data=f"buy_course_{course_id}")
                .button(text="ðŸ”™ Orqaga", callback_data=f"view_course_{course_id}")
                .adjust(1, 1)
                .as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer("âœ… Demo video yuborildi!")
    except Exception as e:
        logger.error(f"Demo video yuborish xatosi: {e}")
        await callback.answer("âŒ Demo videoni yuborishda xatolik!", show_alert=True)

# =============================================================================
# MAIN
# =============================================================================

async def main():
    """Asosiy funksiya"""
    global bot, dp, db
    
    # Papkalar allaqachon yaratilgan (logging dan oldin)
    # Config.setup_dirs()  # Kerak emas, allaqachon yaratilgan
    
    # Bot va Dispatcher yaratish
    bot = Bot(token=Config.BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    storage = MemoryStorage()
    dp = Dispatcher(storage=storage)
    
    # Database yaratish
    db_path = os.path.join(Config.DATA_DIR, Config.DB_NAME)
    db = DatabaseManager(db_path)
    await db.init_db()
    
    # Router qo'shish
    # ============================================
    # YANGI ANALYTICS VA ADVANCED FUNKSIYALAR
    # ============================================
    
    @router.callback_query(F.data == "admin_analytics_dashboard")
    async def handle_admin_analytics_dashboard(callback: CallbackQuery):
        """Admin: Analytics Dashboard - kunlik/haftalik/oylik hisobotlar (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        async with db.connect() as conn:
            # Kunlik statistika
            today = datetime.now().strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) = ?
            ''', (today,))
            new_users_today = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM download_history WHERE DATE(download_date) = ?
            ''', (today,))
            downloads_today = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM ai_conversations WHERE DATE(timestamp) = ?
            ''', (today,))
            ai_questions_today = (await cursor.fetchone())[0] or 0
            
            # Haftalik statistika
            week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) >= ?
            ''', (week_ago,))
            new_users_week = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM download_history WHERE DATE(download_date) >= ?
            ''', (week_ago,))
            downloads_week = (await cursor.fetchone())[0] or 0
            
            # Oylik statistika
            month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) >= ?
            ''', (month_ago,))
            new_users_month = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (month_ago,))
            revenue_month = (await cursor.fetchone())[0] or 0
            
            # Eng ko'p yuklangan kontentlar
            cursor = await conn.execute('''
                SELECT caption, downloads FROM books 
                WHERE is_active = 1 
                ORDER BY downloads DESC 
                LIMIT 10
            ''')
            top_books = await cursor.fetchall()
            
            cursor = await conn.execute('''
                SELECT caption, views FROM movies 
                WHERE is_active = 1 
                ORDER BY views DESC 
                LIMIT 10
            ''')
            top_movies = await cursor.fetchall()
            
            # Foydalanuvchi retention
            cursor = await conn.execute('''
                SELECT COUNT(DISTINCT user_id) FROM download_history 
                WHERE DATE(created_date) >= DATE('now', '-7 days')
            ''')
            active_users_week = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM users')
            total_users = (await cursor.fetchone())[0] or 0
            
            retention_rate = (active_users_week / total_users * 100) if total_users > 0 else 0
        
        text = f"ðŸ“Š <b>ANALYTICS DASHBOARD</b>\n\n"
        
        text += f"ðŸ“… <b>KUNLIK STATISTIKA:</b>\n"
        text += f"   ðŸ‘¥ Yangi foydalanuvchilar: {new_users_today:,}\n"
        text += f"   ðŸ“¥ Yuklashlar: {downloads_today:,}\n"
        text += f"   ðŸ¤– AI savollar: {ai_questions_today:,}\n\n"
        
        text += f"ðŸ“… <b>HAFTALIK STATISTIKA:</b>\n"
        text += f"   ðŸ‘¥ Yangi foydalanuvchilar: {new_users_week:,}\n"
        text += f"   ðŸ“¥ Yuklashlar: {downloads_week:,}\n\n"
        
        text += f"ðŸ“… <b>OYLIK STATISTIKA:</b>\n"
        text += f"   ðŸ‘¥ Yangi foydalanuvchilar: {new_users_month:,}\n"
        text += f"   ðŸ’° Daromad: {revenue_month:,} so'm\n\n"
        
        text += f"ðŸ“ˆ <b>FOYDALANUVCHI RETENTION:</b>\n"
        text += f"   ðŸ”„ Retention rate: {retention_rate:.1f}%\n"
        text += f"   ðŸ‘¥ Faol (7 kun): {active_users_week:,}\n\n"
        
        text += f"ðŸ”¥ <b>ENG KO'P YUKLANGAN KITOBLAR (Top 5):</b>\n"
        for i, book in enumerate(top_books[:5], 1):
            text += f"   {i}. {book[0][:30] if book[0] else 'Nomsiz'} - {book[1] or 0} yuklash\n"
        
        text += f"\nðŸŽ¬ <b>ENG KO'P KO'RILGAN FILMLAR (Top 5):</b>\n"
        for i, movie in enumerate(top_movies[:5], 1):
            text += f"   {i}. {movie[0][:30] if movie[0] else 'Nomsiz'} - {movie[1] or 0} ko'rish\n"
        
        text += f"\nâ° <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“… Kunlik hisobot", callback_data="admin_daily_report")
        builder.button(text="ðŸ“… Haftalik hisobot", callback_data="admin_weekly_report")
        builder.button(text="ðŸ“… Oylik hisobot", callback_data="admin_monthly_report")
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_analytics_dashboard")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(1, 1, 1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_user_segmentation")
    async def handle_admin_user_segmentation(callback: CallbackQuery):
        """Admin: User Segmentation - foydalanuvchilarni kategoriyalash (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        async with db.connect() as conn:
            # Premium users
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users 
                WHERE subscription_type > 0 AND subscription_end > datetime('now')
            ''')
            premium_users = (await cursor.fetchone())[0] or 0
            
            # Active users (7 kun)
            week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT COUNT(DISTINCT user_id) FROM download_history 
                WHERE DATE(created_date) >= ?
            ''', (week_ago,))
            active_users = (await cursor.fetchone())[0] or 0
            
            # Inactive users (30 kun)
            month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users 
                WHERE user_id NOT IN (
                    SELECT DISTINCT user_id FROM download_history 
                    WHERE DATE(created_date) >= ?
                )
            ''', (month_ago,))
            inactive_users = (await cursor.fetchone())[0] or 0
            
            # New users (7 kun)
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) >= ?
            ''', (week_ago,))
            new_users = (await cursor.fetchone())[0] or 0
            
            # Top spenders
            cursor = await conn.execute('''
                SELECT user_id, full_name, total_spent 
                FROM users 
                WHERE total_spent > 0 
                ORDER BY total_spent DESC 
                LIMIT 10
            ''')
            top_spenders = await cursor.fetchall()
            
            # Top referrers
            cursor = await conn.execute('''
                SELECT r.referrer_id, u.full_name, COUNT(*) as ref_count
                FROM referrals r
                LEFT JOIN users u ON r.referrer_id = u.user_id
                GROUP BY r.referrer_id
                ORDER BY ref_count DESC
                LIMIT 10
            ''')
            top_referrers = await cursor.fetchall()
        
        text = f"ðŸ‘¥ <b>USER SEGMENTATION</b>\n\n"
        
        text += f"ðŸ“Š <b>SEGMENTLAR:</b>\n"
        text += f"   ðŸ‘‘ Premium users: {premium_users:,}\n"
        text += f"   ðŸ”¥ Active users (7 kun): {active_users:,}\n"
        text += f"   ðŸ˜´ Inactive users (30 kun): {inactive_users:,}\n"
        text += f"   ðŸ†• New users (7 kun): {new_users:,}\n\n"
        
        text += f"ðŸ’° <b>TOP SPENDERS (Top 5):</b>\n"
        for i, spender in enumerate(top_spenders[:5], 1):
            text += f"   {i}. {spender[1] or 'Noma\'lum'} - {spender[2] or 0:,} so'm\n"
        
        text += f"\nðŸ‘¥ <b>TOP REFERRERS (Top 5):</b>\n"
        for i, referrer in enumerate(top_referrers[:5], 1):
            text += f"   {i}. {referrer[1] or 'Noma\'lum'} - {referrer[2] or 0} referal\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‘‘ Premium users", callback_data="admin_premium_users")
        builder.button(text="ðŸ”¥ Active users", callback_data="admin_active_users")
        builder.button(text="ðŸ˜´ Inactive users", callback_data="admin_inactive_users")
        builder.button(text="ðŸ†• New users", callback_data="admin_new_users")
        builder.button(text="ðŸ’° Top spenders", callback_data="admin_top_spenders")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(2, 2, 2)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_revenue_analytics")
    async def handle_admin_revenue_analytics(callback: CallbackQuery):
        """Admin: Revenue Analytics - moliyaviy tahlil (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        async with db.connect() as conn:
            # Kunlik daromad
            today = datetime.now().strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) = ?
            ''', (today,))
            revenue_today = (await cursor.fetchone())[0] or 0
            
            # Haftalik daromad
            week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (week_ago,))
            revenue_week = (await cursor.fetchone())[0] or 0
            
            # Oylik daromad
            month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (month_ago,))
            revenue_month = (await cursor.fetchone())[0] or 0
            
            # Premium tariflar taqqoslash
            cursor = await conn.execute('''
                SELECT subscription_type, COUNT(*) as count
                FROM users 
                WHERE subscription_type > 0 AND subscription_end > datetime('now')
                GROUP BY subscription_type
            ''')
            premium_comparison = await cursor.fetchall()
            
            # XP xaridlari
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND description LIKE '%xp%'
                AND DATE(created_date) >= ?
            ''', (month_ago,))
            xp_purchases = (await cursor.fetchone())[0] or 0
            
            # Kurs sotuvlari
            cursor = await conn.execute('''
                SELECT COUNT(*), SUM(c.price) 
                FROM user_courses uc
                JOIN courses c ON uc.course_id = c.id
                WHERE DATE(uc.purchased_date) >= ?
            ''', (month_ago,))
            course_sales = await cursor.fetchone()
            course_count = course_sales[0] or 0 if course_sales else 0
            course_revenue = course_sales[1] or 0 if course_sales and course_sales[1] else 0
        
        text = f"ðŸ’° <b>REVENUE ANALYTICS</b>\n\n"
        
        text += f"ðŸ“… <b>DAROMAD:</b>\n"
        text += f"   ðŸ’° Kunlik: {revenue_today:,} so'm\n"
        text += f"   ðŸ’° Haftalik: {revenue_week:,} so'm\n"
        text += f"   ðŸ’° Oylik: {revenue_month:,} so'm\n\n"
        
        text += f"ðŸ‘‘ <b>PREMIUM TARIFLAR TAQQOSLASH:</b>\n"
        for row in premium_comparison:
            sub_type = row[0]
            count = row[1]
            sub_name = DatabaseManager.get_subscription_name(sub_type)
            text += f"   {sub_name}: {count} ta\n"
        
        text += f"\nðŸ’° <b>XP XARIDLARI (oylik):</b> {xp_purchases:,} so'm\n"
        text += f"ðŸŽ“ <b>KURS SOTUVLARI (oylik):</b> {course_count} ta, {course_revenue:,} so'm\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“… Kunlik", callback_data="admin_revenue_daily")
        builder.button(text="ðŸ“… Haftalik", callback_data="admin_revenue_weekly")
        builder.button(text="ðŸ“… Oylik", callback_data="admin_revenue_monthly")
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_revenue_analytics")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(3, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_advanced_search")
    async def handle_admin_advanced_search(callback: CallbackQuery):
        """Admin: Advanced Search - kengaytirilgan qidiruv (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="admin_adv_search_books")
        builder.button(text="ðŸŽ¬ Filmlar", callback_data="admin_adv_search_movies")
        builder.button(text="ðŸŽ“ Kurslar", callback_data="admin_adv_search_courses")
        builder.button(text="ðŸ‘¥ Foydalanuvchilar", callback_data="admin_adv_search_users")
        builder.button(text="ðŸ’³ To'lovlar", callback_data="admin_adv_search_payments")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(2, 2, 2)
        
        await callback.message.edit_text(
            "ðŸ” <b>ADVANCED SEARCH</b>\n\n"
            "Qidiruv turini tanlang:",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    @router.callback_query(F.data == "admin_bulk_operations")
    async def handle_admin_bulk_operations(callback: CallbackQuery):
        """Admin: Bulk Operations - ommaviy amallar (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ—‘ï¸ Bulk delete", callback_data="admin_bulk_delete")
        builder.button(text="âœï¸ Bulk edit", callback_data="admin_bulk_edit")
        builder.button(text="âœ… Bulk approve", callback_data="admin_bulk_approve")
        builder.button(text="ðŸ’Ž Bulk premium", callback_data="admin_bulk_premium")
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        builder.adjust(2, 2, 1)
        
        await callback.message.edit_text(
            "âš¡ <b>BULK OPERATIONS</b>\n\n"
            "Ommaviy amal turini tanlang:\n\n"
            "âš ï¸ <b>Eslatma:</b> Bu amallar ko'p ma'lumotlarni bir vaqtda o'zgartirish uchun.",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    # ============================================
    # YORDAM VA SUPPORT FUNKSIYALARI (MegaBook.py dan)
    # ============================================
    
    @router.callback_query(F.data == "user_guide")
    async def handle_user_guide(callback: CallbackQuery):
        """Foydalanuvchi qo'llanmasi (MegaBook.py dan ko'chirilgan)"""
        guide_text = """
ðŸ“š <b>FOYDALANUVCHI QO'LLANMASI</b>

ðŸ¤– <b>Botni ishga tushirish:</b>
  â€¢ /start - Botni ishga tushirish
  â€¢ Yangi foydalanuvchilar 100 XP bonus olishadi
  â€¢ 1 kunlik Premium trial beriladi

ðŸ“š <b>Kutubxona:</b>
  â€¢ 1000+ kitoblar
  â€¢ Janr bo'yicha filtrlash
  â€¢ Premium kitoblar uchun alohida obuna
  â€¢ Har bir yuklash uchun 50 XP bonus

ðŸŽ¬ <b>Kinoteatr:</b>
  â€¢ 500+ filmlar
  â€¢ 480p, 720p, 1080p, 4K sifatlar
  â€¢ Premium foydalanuvchilar uchun yuqori sifat
  â€¢ Har bir tomosha uchun 100 XP bonus

ðŸŽ“ <b>Kurslar:</b>
  â€¢ 100+ professional kurslar
  â€¢ Har bir kurs 19,990 so'm
  â€¢ Sertifikat va materiallar
  â€¢ Kurs tamomlash uchun 500 XP bonus

ðŸ¤– <b>AI Mentor:</b>
  â€¢ GPT-4 texnologiyasi
  â€¢ Har qanday savollarga javob
  â€¢ Kod yozishda yordam
  â€¢ Har bir savol uchun 1 AI limit

ðŸ’Ž <b>Premium obuna:</b>
  â€¢ 4 xil tariflar
  â€¢ Cheksiz yuklash
  â€¢ Yuqori sifatli kontent
  â€¢ AI limit 50-200 ta/kun

ðŸ›’ <b>Market:</b>
  â€¢ XP evaziga tovarlar
  â€¢ Premium tariflar (1-30 kun)
  â€¢ Mining uskunalari
  â€¢ Fortune Wheel

ðŸ“Š <b>Statistika & Reyting:</b>
  â€¢ Shaxsiy statistika
  â€¢ Global reyting jadvali
  â€¢ Liga tizimi
  â€¢ Yutuqlar tizimi

ðŸŽ <b>Bonuslar:</b>
  â€¢ Kunlik bonus (100 XP)
  â€¢ Referal tizimi (75 XP/referal)
  â€¢ Promo kodlar
  â€¢ Fortune Wheel (25-1000 XP)

âš™ï¸ <b>Sozlamalar:</b>
  â€¢ Bildirishnomalar
  â€¢ Maxfiylik sozlamalari
  â€¢ Til sozlamalari
  â€¢ Tarixni tozalash

ðŸ†˜ <b>Yordam:</b>
  â€¢ Qo'llanma (shu sahifa)
  â€¢ Troubleshooter
  â€¢ Support ticket
  â€¢ Admin bilan bog'lanish

ðŸ“ž <b>Aloqa:</b>
  â€¢ Asosiy admin: {Config.SUPPORT_USERNAME}
  â€¢ Support: {Config.SUPPORT_USERNAME}
  â€¢ 24/7 javob (48 soat ichida)
        """.format(Config=Config)
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”§ Troubleshooter", callback_data="troubleshooter")
        builder.button(text="ðŸŽ« Support ticket", callback_data="support_ticket")
        builder.button(text="ðŸ“¡ Status sahifasi", callback_data="status_page")
        builder.button(text="ðŸ”™ Yordam", callback_data="help_menu")
        builder.adjust(1, 2, 1)
        
        await safe_edit_text(callback, guide_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "troubleshooter")
    async def handle_troubleshooter(callback: CallbackQuery):
        """Troubleshooter - muammolarni hal qilish (MegaBook.py dan ko'chirilgan)"""
        troubleshooter_text = """
ðŸ”§ <b>TROUBLESHOOTER</b>

Quyidagi muammolardan birini tanlang:

1. âŒ Kitob yuklanmayapti
2. âŒ Film ochilmayapti  
3. âŒ AI javob bermayapti
4. âŒ To'lov tasdiqlanmadi
5. âŒ XP qo'shilmadi
6. âŒ Premium faollashmadi
7. âŒ Bot javob bermayapti
8. âŒ Boshqa muammo

ðŸ‘‡ <b>Muammoni tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="âŒ Kitob yuklanmayapti", callback_data="ts_book")
        builder.button(text="âŒ Film ochilmayapti", callback_data="ts_movie")
        builder.button(text="âŒ AI javob bermayapti", callback_data="ts_ai")
        builder.button(text="âŒ To'lov tasdiqlanmadi", callback_data="ts_payment")
        builder.button(text="âŒ XP qo'shilmadi", callback_data="ts_xp")
        builder.button(text="âŒ Premium faollashmadi", callback_data="ts_premium")
        builder.button(text="âŒ Bot javob bermayapti", callback_data="ts_bot")
        builder.button(text="âŒ Boshqa muammo", callback_data="ts_other")
        builder.button(text="ðŸ”™ Yordam", callback_data="help_menu")
        builder.adjust(2, 2, 2, 2, 1)
        
        await safe_edit_text(callback, troubleshooter_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("ts_"))
    async def handle_troubleshooter_detail(callback: CallbackQuery):
        """Troubleshooter batafsil (MegaBook.py dan ko'chirilgan)"""
        issue = callback.data.replace("ts_", "")
        
        solutions = {
            "book": """
ðŸ“š <b>KITOB YUKLANMAYAPTI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>Internet aloqasini tekshiring:</b>
   â€¢ Wi-Fi yoki mobil internet yoqilganligiga ishonch hosil qiling
   â€¢ Boshqa ilovalar ishlayotganligini tekshiring

2. <b>Fayl holatini tekshiring:</b>
   â€¢ Kitob admin tomonidan tasdiqlanganligiga ishonch hosil qiling
   â€¢ Boshqa kitoblarni yuklab ko'ring

3. <b>Botni qayta ishga tushiring:</b>
   â€¢ /start komandasini bosing
   â€¢ Kutubxonaga qayta kiring

4. <b>Cache va tarixni tozalash:</b>
   â€¢ Sozlamalar > Tarixni tozalash
   â€¢ Botni qayta ishga tushiring

5. <b>Support ticket oching:</b>
   â€¢ Agar muammo hal bo'lmasa, support ticket oching
   â€¢ Kitob kodini va xato haqida ma'lumot bering
            """,
            "movie": """
ðŸŽ¬ <b>FILM OCHILMAYAPTI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>Internet tezligini tekshiring:</b>
   â€¢ Video oqim uchun kamida 5 Mbps internet kerak
   â€¢ Speedtest ilovasi orqali tezlikni tekshiring

2. <b>Premium obunani tekshiring:</b>
   â€¢ 1080p/4K filmlar faqat Premium foydalanuvchilar uchun
   â€¢ Sizning obuna holatingizni tekshiring (/profile)

3. <b>Video pleerni yangilang:</b>
   â€¢ Telegram versiyangizni yangilang
   â€¢ Boshqa videolarni ochib ko'ring

4. <b>Telegram cache ni tozalash:</b>
   â€¢ Telegram sozlamalari > Data va storage > Cache tozalash
   â€¢ Botni qayta ishga tushiring

5. <b>Boshqa sifatni sinab ko'ring:</b>
   â€¢ 720p yoki 480p sifatda ochib ko'ring
   â€¢ Agar ochilsa, internet tezligi muammo
            """,
            "ai": """
ðŸ¤– <b>AI JAVOB BERMAYAPTI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>AI limitni tekshiring:</b>
   â€¢ Profilingizda qolgan AI limitni tekshiring
   â€¢ Limit tugagan bo'lishi mumkin

2. <b>Internet aloqasini tekshiring:</b>
   â€¢ AI javobi uchun barqaror internet kerak
   â€¢ Boshqa ilovalar ishlayotganligini tekshiring

3. <b>Savol uzunligini qisqartiring:</b>
   â€¢ Juda uzun savollar timeoutga olib kelishi mumkin
   â€¢ Savolni qisqartirib yuborib ko'ring

4. <b>Kuting va qayta urinib ko'ring:</b>
   â€¢ AI javobi 1-2 daqiqa vaqt olishi mumkin
   â€¢ 5 daqiqa kutib, qayta urinib ko'ring

5. <b>Support ticket oching:</b>
   â€¢ Agar muammo davom etsa, support ticket oching
   â€¢ Savol matnini va vaqtni ko'rsating
            """,
            "payment": """
ðŸ’³ <b>TO'LOV TASDIQLANMADI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>To'lov holatini tekshiring:</b>
   â€¢ Profilingizda to'lov holatini tekshiring
   â€¢ To'lov kutilayotgan bo'lishi mumkin

2. <b>Screenshot yuboring:</b>
   â€¢ To'lov screenshot'ini yuboring
   â€¢ Support ticket ga yuboring

3. <b>Admin bilan bog'laning:</b>
   â€¢ {Config.SUPPORT_USERNAME} ga yozing
   â€¢ To'lov ID va ma'lumotlarni yuboring

4. <b>Kuting:</b>
   â€¢ To'lov tasdiqlanishi 1-24 soat vaqt olishi mumkin
   â€¢ 24 soatdan keyin support ticket oching
            """.format(Config=Config),
            "xp": """
ðŸ’° <b>XP QO'SHILMADI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>XP holatini tekshiring:</b>
   â€¢ Profilingizda XP miqdorini tekshiring
   â€¢ XP qo'shilgan bo'lishi mumkin

2. <b>Botni qayta ishga tushiring:</b>
   â€¢ /start komandasini bosing
   â€¢ Profilga qayta kiring

3. <b>Kuting:</b>
   â€¢ XP qo'shilishi 1-5 daqiqa vaqt olishi mumkin
   â€¢ 5 daqiqadan keyin qayta tekshiring

4. <b>Support ticket oching:</b>
   â€¢ Agar XP hali ham qo'shilmagan bo'lsa
   â€¢ Qaysi harakatdan keyin XP qo'shilmaganligini yozing
            """,
            "premium": """
ðŸ‘‘ <b>PREMIUM FAQOLLASHMADI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>Premium holatini tekshiring:</b>
   â€¢ Profilingizda Premium holatini tekshiring
   â€¢ Premium aktiv bo'lishi mumkin

2. <b>Botni qayta ishga tushiring:</b>
   â€¢ /start komandasini bosing
   â€¢ Profilga qayta kiring

3. <b>To'lov holatini tekshiring:</b>
   â€¢ To'lov tasdiqlanganligiga ishonch hosil qiling
   â€¢ To'lov kutilayotgan bo'lishi mumkin

4. <b>Support ticket oching:</b>
   â€¢ Agar Premium hali ham faollashmagan bo'lsa
   â€¢ To'lov ID va ma'lumotlarni yuboring
            """,
            "bot": """
ðŸ¤– <b>BOT JAVOB BERMAYAPTI</b>

ðŸ” <b>Yechimlar:</b>

1. <b>Internet aloqasini tekshiring:</b>
   â€¢ Wi-Fi yoki mobil internet yoqilganligiga ishonch hosil qiling
   â€¢ Boshqa ilovalar ishlayotganligini tekshiring

2. <b>Botni qayta ishga tushiring:</b>
   â€¢ /start komandasini bosing
   â€¢ Botni qayta ishga tushiring

3. <b>Telegram versiyasini yangilang:</b>
   â€¢ Telegram versiyangizni yangilang
   â€¢ Eski versiyalar muammo berishi mumkin

4. <b>Kuting:</b>
   â€¢ Bot javob berishi 1-2 daqiqa vaqt olishi mumkin
   â€¢ 5 daqiqadan keyin qayta urinib ko'ring

5. <b>Support ticket oching:</b>
   â€¢ Agar bot hali ham javob bermayotgan bo'lsa
   â€¢ Muammoni batafsil tasvirlang
            """,
            "other": """
âŒ <b>BOSHQA MUAMMO</b>

Agar sizda yuqoridagi muammolardan boshqasi bo'lsa:

1. <b>Muammoni batafsil tasvirlang:</b>
   â€¢ Qachon boshlangan?
   â€¢ Qanday harakatlar muammoga olib keldi?
   â€¢ Xato xabari bormi?

2. <b>Screenshot yuboring:</b>
   â€¢ Xato paytida screenshot oling
   â€¢ Support ticket ga yuboring

3. <b>Support ticket oching:</b>
   â€¢ Yordam menyusidan support ticket tanlang
   â€¢ Muammoni batafsil tasvirlang

4. <b>Admin bilan bog'laning:</b>
   â€¢ {Config.SUPPORT_USERNAME} ga to'g'ridan-to'g'ri yozing
   â€¢ User ID: <code>{user_id}</code> ni ko'rsating

â° <b>Javob vaqti:</b>
   â€¢ Support ticket: 24 soat ichida
   â€¢ To'g'ridan-to'g'ri admin: 48 soat ichida
            """.format(Config=Config, user_id=callback.from_user.id)
        }
        
        solution_text = solutions.get(issue, solutions["other"])
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ« Support ticket ochish", callback_data="support_ticket")
        builder.button(text="ðŸ‘¨â€ðŸ’¼ Admin bilan bog'lanish", url=f"https://t.me/{Config.SUPPORT_USERNAME.replace('@', '')}")
        builder.button(text="ðŸ”™ Troubleshooter", callback_data="troubleshooter")
        builder.adjust(1, 1, 1)
        
        await safe_edit_text(callback, solution_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "support_ticket")
    async def handle_support_ticket(callback: CallbackQuery, state: FSMContext):
        """Support ticket ochish (MegaBook.py dan ko'chirilgan)"""
        user_id = callback.from_user.id
        
        categories = [
            ("âŒ Texnik muammo", "technical"),
            ("ðŸ’³ To'lov muammosi", "payment"),
            ("ðŸ“š Kontent muammosi", "content"),
            ("ðŸ‘¤ Hisob muammosi", "account"),
            ("ðŸ¤– AI muammosi", "ai"),
            ("ðŸŽ Bonus muammosi", "bonus"),
            ("âš™ï¸ Sozlama muammosi", "settings"),
            ("ðŸ” Xavfsizlik muammosi", "security"),
            ("ðŸ“Š Statistika muammosi", "stats"),
            ("ðŸ”— Referal muammosi", "referral"),
            ("ðŸ’Ž Premium muammosi", "premium"),
            ("ðŸ“¥ Yuklash muammosi", "download"),
            ("ðŸ”„ Boshqa muammo", "other")
        ]
        
        from datetime import datetime
        import time
        import random
        
        ticket_text = f"""
ðŸŽ« <b>SUPPORT TICKET OCHISH</b>

ðŸ†” <b>Sizning ID:</b> <code>{user_id}</code>
ðŸ‘¤ <b>Ism:</b> {callback.from_user.full_name}
â° <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}

ðŸ“‹ <b>Ticket ochish tartibi:</b>
1. Muammo kategoriyasini tanlang
2. Muammoni batafsil tasvirlang
3. Screenshot yuboring (agar kerak bo'lsa)
4. Admin javobini kuting

â³ <b>Javob vaqti:</b> 24 soat ichida
ðŸŽ« <b>Ticket ID:</b> TK{int(time.time())}{random.randint(100, 999)}

ðŸ‘‡ <b>Kategoriyani tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        
        for name, callback_data in categories:
            builder.button(text=name, callback_data=f"ticket_category_{callback_data}")
        
        builder.button(text="âŒ Bekor qilish", callback_data="help_menu")
        builder.adjust(1, 2, 2, 2, 2, 2, 2, 1)
        
        await safe_edit_text(callback, ticket_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("ticket_category_"))
    async def handle_ticket_category(callback: CallbackQuery, state: FSMContext):
        """Support ticket kategoriyasi tanlash"""
        user_id = callback.from_user.id
        category = callback.data.replace("ticket_category_", "")
        
        category_names = {
            "technical": "Texnik muammo",
            "payment": "To'lov muammosi",
            "content": "Kontent muammosi",
            "account": "Hisob muammosi",
            "ai": "AI muammosi",
            "bonus": "Bonus muammosi",
            "settings": "Sozlama muammosi",
            "security": "Xavfsizlik muammosi",
            "stats": "Statistika muammosi",
            "referral": "Referal muammosi",
            "premium": "Premium muammosi",
            "download": "Yuklash muammosi",
            "other": "Boshqa muammo"
        }
        
        await state.update_data(ticket_category=category)
        
        await safe_edit_text(callback,
            f"ðŸŽ« <b>SUPPORT TICKET</b>\n\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {category_names.get(category, 'Boshqa')}\n\n"
            f"Muammoni batafsil tasvirlang (yoki screenshot yuboring):",
            reply_markup=Keyboards.back_button("support_ticket")
        )
        await state.set_state(UserStates.waiting_support_message)
        await callback.answer()
    
    @router.message(UserStates.waiting_support_message)
    async def handle_support_message(message: Message, state: FSMContext):
        """Support ticket xabarini qabul qilish"""
        user_id = message.from_user.id
        data = await state.get_data()
        category = data.get('ticket_category', 'other')
        
        ticket_text = message.text or message.caption or ""
        if message.photo:
            ticket_text = f"[Rasm] {ticket_text}"
        elif message.video:
            ticket_text = f"[Video] {ticket_text}"
        elif message.document:
            ticket_text = f"[Fayl] {ticket_text}"
        
        if not ticket_text:
            await message.answer(
                "âŒ <b>Xabar matni bo'sh!</b>\n\n"
                "Muammoni batafsil tasvirlang:",
                reply_markup=Keyboards.back_button("support_ticket"),
                parse_mode=ParseMode.HTML
            )
            return
        
        from datetime import datetime
        import time
        import random
        
        ticket_id = f"TK{int(time.time())}{random.randint(100, 999)}"
        
        # Bazaga saqlash
        async with db.connect() as conn:
            await conn.execute('''
                INSERT INTO support_tickets (user_id, category, message, status, created_date)
                VALUES (?, ?, ?, 'open', datetime('now'))
            ''', (user_id, category, ticket_text))
            await conn.commit()
        
        # Adminlarga xabar (javob berish tugmasi bilan)
        admin_text = f"""
ðŸŽ« <b>YANGI SUPPORT TICKET</b>

ðŸ†” <b>Ticket ID:</b> {ticket_id}
ðŸ‘¤ <b>Foydalanuvchi:</b> {message.from_user.full_name}
ðŸ†” <b>User ID:</b> <code>{user_id}</code>
ðŸ“‚ <b>Kategoriya:</b> {category}
ðŸ“ <b>Xabar:</b> {ticket_text[:500]}

â° <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        """
        
        # Javob berish tugmasi
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ’¬ Javob berish", callback_data=f"admin_reply_ticket_{user_id}")
        builder.button(text="ðŸ“‹ Barcha ticketlar", callback_data="admin_tickets")
        builder.adjust(1, 1)
        
        for admin_id in Config.ADMIN_IDS:
            try:
                if message.photo:
                    await bot.send_photo(
                        admin_id,
                        message.photo[-1].file_id,
                        caption=admin_text,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
                elif message.video:
                    await bot.send_video(
                        admin_id,
                        message.video.file_id,
                        caption=admin_text,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
                elif message.document:
                    await bot.send_document(
                        admin_id,
                        message.document.file_id,
                        caption=admin_text,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await bot.send_message(
                        admin_id,
                        admin_text,
                        reply_markup=builder.as_markup(),
                        parse_mode=ParseMode.HTML
                    )
            except Exception as e:
                logger.error(f"Admin xabar yuborish xatosi {admin_id}: {e}")
        
        await message.answer(
            f"âœ… <b>SUPPORT TICKET OCHILDI!</b>\n\n"
            f"ðŸŽ« <b>Ticket ID:</b> {ticket_id}\n"
            f"ðŸ“‚ <b>Kategoriya:</b> {category}\n\n"
            f"â³ <b>Javob vaqti:</b> 24 soat ichida\n\n"
            f"Adminlar sizning muammoingizni ko'rib chiqishadi va javob berishadi.",
            reply_markup=Keyboards.back_button("help_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    
    @router.callback_query(F.data == "status_page")
    async def handle_status_page(callback: CallbackQuery):
        """Status sahifasi (MegaBook.py dan ko'chirilgan)"""
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT COUNT(*) FROM users')
            total_users = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM books WHERE is_active = 1')
            total_books = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1')
            total_movies = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM courses WHERE is_active = 1')
            total_courses = (await cursor.fetchone())[0] or 0
        
        from datetime import datetime
        
        status_text = f"""
ðŸ“¡ <b>STATUS SAHIFASI</b>

âœ… <b>Bot holati:</b> Faol
â° <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ðŸ“Š <b>TIZIM STATISTIKASI:</b>
  ðŸ‘¥ Foydalanuvchilar: {total_users:,}
  ðŸ“š Kitoblar: {total_books:,}
  ðŸŽ¬ Filmlar: {total_movies:,}
  ðŸŽ“ Kurslar: {total_courses:,}

ðŸ”„ <b>OXIRGI YANGILANISH:</b>
  â€¢ Bot versiyasi: v2.0
  â€¢ Database: Faol
  â€¢ API: Faol

ðŸ“ž <b>ALOQA:</b>
  â€¢ Support: {Config.SUPPORT_USERNAME}
  â€¢ Javob vaqti: 24 soat ichida

ðŸ’¡ <b>MUAMMOLAR BORMI?</b>
  â€¢ Troubleshooter dan foydalaning
  â€¢ Support ticket oching
  â€¢ Admin bilan bog'laning
        """.format(Config=Config)
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”§ Troubleshooter", callback_data="troubleshooter")
        builder.button(text="ðŸŽ« Support ticket", callback_data="support_ticket")
        builder.button(text="ðŸ”™ Yordam", callback_data="help_menu")
        builder.adjust(1, 1, 1)
        
        await safe_edit_text(callback, status_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ============================================
    # QOLGAN BARCHA FUNKSIYALAR
    # ============================================
    
    # ========== ADMIN QO'SHIMCHA FUNKSIYALAR ==========
    
    @router.callback_query(F.data == "admin_preload_all_movies")
    async def handle_admin_preload_all_movies(callback: CallbackQuery):
        """Admin: Barcha kinolarni yuklash (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text("â³ <b>Kinolarni yuklash...</b>", parse_mode=ParseMode.HTML)
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT id, file_id, caption FROM movies WHERE is_active = 1')
            movies = await cursor.fetchall()
        
        loaded_count = 0
        failed_count = 0
        
        for movie_id, file_id, caption in movies:
            try:
                # Bu yerda faylni yuklash logikasi bo'lishi kerak
                # Hozircha faqat statistikani ko'rsatamiz
                loaded_count += 1
            except Exception as e:
                failed_count += 1
                logger.error(f"Movie preload error {movie_id}: {e}")
        
        await callback.message.edit_text(
            f"âœ… <b>YUKLASH YAKUNLANDI!</b>\n\n"
            f"âœ… Yuklandi: {loaded_count:,}\n"
            f"âŒ Xatolik: {failed_count:,}\n"
            f"ðŸ“Š Jami: {len(movies):,}",
            reply_markup=Keyboards.back_button("admin_movies"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    @router.callback_query(F.data == "admin_delete_all_movies")
    async def handle_admin_delete_all_movies(callback: CallbackQuery):
        """Admin: Barcha kinolarni o'chirish (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        builder = InlineKeyboardBuilder()
        builder.button(text="âš ï¸ Ha, barchasini o'chirish", callback_data="admin_confirm_delete_all_movies")
        builder.button(text="âŒ Yo'q, bekor qilish", callback_data="admin_movies")
        builder.adjust(1, 1)
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 1')
            total_movies = (await cursor.fetchone())[0] or 0
        
        await callback.message.edit_text(
            f"âš ï¸ <b>DIQQAT!</b>\n\n"
            f"Barcha kinolarni o'chirish:\n"
            f"ðŸŽ¬ <b>Jami filmlar:</b> {total_movies:,}\n\n"
            f"âš ï¸ Bu amalni qaytarib bo'lmaydi!\n"
            f"âš ï¸ Barcha filmlar o'chiriladi!\n\n"
            f"Haqiqatan ham davom etasizmi?",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    @router.callback_query(F.data == "admin_confirm_delete_all_movies")
    async def handle_admin_confirm_delete_all_movies(callback: CallbackQuery):
        """Admin: Barcha kinolarni o'chirishni tasdiqlash"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            await conn.execute('UPDATE movies SET is_active = 0')
            await conn.commit()
            cursor = await conn.execute('SELECT COUNT(*) FROM movies WHERE is_active = 0')
            deleted_count = (await cursor.fetchone())[0] or 0
        
        await safe_edit_text(callback,
            f"âœ… <b>Barcha filmlar o'chirildi!</b>\n\n"
            f"ðŸŽ¬ <b>O'chirilgan:</b> {deleted_count:,} ta film",
            reply_markup=Keyboards.back_button("admin_movies")
        )
        await callback.answer("âœ… Barcha filmlar o'chirildi!")
    
    @router.callback_query(F.data == "admin_user_courses")
    async def handle_admin_user_courses(callback: CallbackQuery):
        """Admin: Foydalanuvchi kurslari (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT uc.user_id, u.full_name, c.title, uc.purchased_date
                FROM user_courses uc
                JOIN users u ON uc.user_id = u.user_id
                JOIN courses c ON uc.course_id = c.id
                ORDER BY uc.purchased_date DESC
                LIMIT 50
            ''')
            user_courses = await cursor.fetchall()
            
            cursor = await conn.execute('SELECT COUNT(*) FROM user_courses')
            total_purchases = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸŽ“ <b>FOYDALANUVCHI KURSLARI</b>\n\n"
        text += f"ðŸ“Š <b>Jami sotuvlar:</b> {total_purchases:,}\n\n"
        
        if not user_courses:
            text += "âŒ Hozircha sotuvlar mavjud emas."
        else:
            text += f"<b>Oxirgi {len(user_courses)} ta sotuv:</b>\n\n"
            for i, (uid, name, title, date) in enumerate(user_courses[:20], 1):
                text += f"{i}. <b>{name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸŽ“ {title[:30] if title else 'Nomsiz'}\n"
                text += f"   ðŸ“… {date[:10] if date else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_course_payments")
    async def handle_admin_course_payments(callback: CallbackQuery):
        """Admin: Kurs to'lovlari (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT p.id, u.full_name, c.title, p.amount, p.status, p.created_date
                FROM payments p
                JOIN users u ON p.user_id = u.user_id
                LEFT JOIN courses c ON p.course_id = c.id
                WHERE p.course_id IS NOT NULL
                ORDER BY p.created_date DESC
                LIMIT 50
            ''')
            course_payments = await cursor.fetchall()
            
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE course_id IS NOT NULL AND status = 'approved'
            ''')
            total_revenue = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ’³ <b>KURS TO'LOVLARI</b>\n\n"
        text += f"ðŸ’° <b>Jami daromad:</b> {total_revenue:,} so'm\n\n"
        
        if not course_payments:
            text += "âŒ Hozircha to'lovlar mavjud emas."
        else:
            text += f"<b>Oxirgi {len(course_payments)} ta to'lov:</b>\n\n"
            for i, (pid, name, title, amount, status, date) in enumerate(course_payments[:20], 1):
                status_icon = "âœ…" if status == "approved" else "â³" if status == "pending" else "âŒ"
                text += f"{status_icon} {i}. <b>{name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸŽ“ {title[:30] if title else 'Kurs'}\n"
                text += f"   ðŸ’° {amount:,} so'm\n"
                text += f"   ðŸ“… {date[:10] if date else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_leagues")
    async def handle_admin_leagues(callback: CallbackQuery):
        """Admin: Liga boshqaruvi (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT league_name, COUNT(*) as count, MIN(xp) as min_xp, MAX(xp) as max_xp
                FROM users
                WHERE league_name IS NOT NULL
                GROUP BY league_name
                ORDER BY min_xp
            ''')
            leagues = await cursor.fetchall()
        
        text = f"ðŸ† <b>LIGA BOSHQARUVI</b>\n\n"
        
        if not leagues:
            text += "âŒ Hozircha ligalar mavjud emas."
        else:
            for league_name, count, min_xp, max_xp in leagues:
                text += f"ðŸ† <b>{league_name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ‘¥ Foydalanuvchilar: {count}\n"
                text += f"   ðŸ’° XP: {min_xp or 0:,} - {max_xp or 0:,}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Admin panel", callback_data="admin_menu")
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_free_course")
    async def handle_admin_free_course(callback: CallbackQuery, state: FSMContext):
        """Admin: Kurs bepul qilish (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "ðŸŽ <b>KURS BEPUL QILISH</b>\n\n"
            "Bepul qilish uchun kurs ID ni yozing:",
            reply_markup=Keyboards.back_button("admin_courses"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_free_course_user)
        await callback.answer("âœ… Kurs bepul qilish rejimi yoqildi!")
    
    @router.message(AdminStates.waiting_free_course_user)
    async def handle_admin_free_course_id(message: Message, state: FSMContext):
        """Admin: Kursni bepul qilish"""
        user_id = message.from_user.id
        if not await check_is_admin(user_id, db):
            await state.clear()
            return
        
        try:
            course_id = int(message.text.strip())
            course = await db.get_course(course_id)
            
            if not course:
                await message.answer(
                    f"âŒ <b>Kurs topilmadi!</b>\n\n"
                    f"ID: <code>{course_id}</code>",
                    reply_markup=Keyboards.back_button("admin_courses"),
                    parse_mode=ParseMode.HTML
                )
                await state.clear()
                return
            
            # Kursni bepul qilish (narxni 0 qilish)
            async with db.connect() as conn:
                await conn.execute('UPDATE courses SET price = 0, discount_price = 0 WHERE id = ?', (course_id,))
                await conn.commit()
            
            await message.answer(
                f"âœ… <b>Kurs bepul qilindi!</b>\n\n"
                f"ðŸŽ“ <b>Kurs:</b> {course.get('title', 'Nomsiz')}\n"
                f"ðŸ†” <b>ID:</b> {course_id}\n"
                f"ðŸ’° <b>Narx:</b> 0 so'm (Bepul)",
                reply_markup=Keyboards.back_button("admin_courses"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
        except ValueError:
            await message.answer(
                "âŒ <b>Noto'g'ri ID!</b>\n\n"
                "Kurs ID raqam bo'lishi kerak.",
                reply_markup=Keyboards.back_button("admin_courses"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
    
    # ========== ADVANCED REPORTS ==========
    
    @router.callback_query(F.data == "admin_daily_report")
    async def handle_admin_daily_report(callback: CallbackQuery):
        """Admin: Kunlik hisobot (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        today = datetime.now().strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) = ?
            ''', (today,))
            new_users = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM download_history WHERE DATE(download_date) = ?
            ''', (today,))
            downloads = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) = ?
            ''', (today,))
            revenue = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM ai_conversations WHERE DATE(created_date) = ?
            ''', (today,))
            ai_questions = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ“… <b>KUNLIK HISOBOT</b>\n\n"
        text += f"ðŸ“… <b>Sana:</b> {today}\n\n"
        text += f"ðŸ‘¥ <b>Yangi foydalanuvchilar:</b> {new_users:,}\n"
        text += f"ðŸ“¥ <b>Yuklashlar:</b> {downloads:,}\n"
        text += f"ðŸ’° <b>Daromad:</b> {revenue:,} so'm\n"
        text += f"ðŸ¤– <b>AI savollar:</b> {ai_questions:,}\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_daily_report")
        builder.button(text="ðŸ”™ Dashboard", callback_data="admin_analytics_dashboard")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_weekly_report")
    async def handle_admin_weekly_report(callback: CallbackQuery):
        """Admin: Haftalik hisobot (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) >= ?
            ''', (week_ago,))
            new_users = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM download_history WHERE DATE(download_date) >= ?
            ''', (week_ago,))
            downloads = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (week_ago,))
            revenue = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ“… <b>HAFTALIK HISOBOT</b>\n\n"
        text += f"ðŸ“… <b>Davr:</b> {week_ago} - {datetime.now().strftime('%Y-%m-%d')}\n\n"
        text += f"ðŸ‘¥ <b>Yangi foydalanuvchilar:</b> {new_users:,}\n"
        text += f"ðŸ“¥ <b>Yuklashlar:</b> {downloads:,}\n"
        text += f"ðŸ’° <b>Daromad:</b> {revenue:,} so'm\n"
        text += f"ðŸ“Š <b>O'rtacha kunlik:</b> {new_users // 7:,} foydalanuvchi\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_weekly_report")
        builder.button(text="ðŸ”™ Dashboard", callback_data="admin_analytics_dashboard")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_monthly_report")
    async def handle_admin_monthly_report(callback: CallbackQuery):
        """Admin: Oylik hisobot (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) >= ?
            ''', (month_ago,))
            new_users = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM download_history WHERE DATE(download_date) >= ?
            ''', (month_ago,))
            downloads = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (month_ago,))
            revenue = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ“… <b>OYLIK HISOBOT</b>\n\n"
        text += f"ðŸ“… <b>Davr:</b> {month_ago} - {datetime.now().strftime('%Y-%m-%d')}\n\n"
        text += f"ðŸ‘¥ <b>Yangi foydalanuvchilar:</b> {new_users:,}\n"
        text += f"ðŸ“¥ <b>Yuklashlar:</b> {downloads:,}\n"
        text += f"ðŸ’° <b>Daromad:</b> {revenue:,} so'm\n"
        text += f"ðŸ“Š <b>O'rtacha kunlik:</b> {new_users // 30:,} foydalanuvchi\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_monthly_report")
        builder.button(text="ðŸ”™ Dashboard", callback_data="admin_analytics_dashboard")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== REVENUE REPORTS ==========
    
    @router.callback_query(F.data == "admin_revenue_daily")
    async def handle_admin_revenue_daily(callback: CallbackQuery):
        """Admin: Kunlik daromad (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime
        
        today = datetime.now().strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) = ?
            ''', (today,))
            revenue = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) = ?
            ''', (today,))
            transactions = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ’° <b>KUNLIK DAROMAD</b>\n\n"
        text += f"ðŸ“… <b>Sana:</b> {today}\n\n"
        text += f"ðŸ’° <b>Jami daromad:</b> {revenue:,} so'm\n"
        text += f"ðŸ’³ <b>To'lovlar soni:</b> {transactions:,}\n"
        if transactions > 0:
            text += f"ðŸ“Š <b>O'rtacha to'lov:</b> {revenue // transactions:,} so'm\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_revenue_daily")
        builder.button(text="ðŸ”™ Revenue Analytics", callback_data="admin_revenue_analytics")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_revenue_weekly")
    async def handle_admin_revenue_weekly(callback: CallbackQuery):
        """Admin: Haftalik daromad (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (week_ago,))
            revenue = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (week_ago,))
            transactions = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ’° <b>HAFTALIK DAROMAD</b>\n\n"
        text += f"ðŸ“… <b>Davr:</b> {week_ago} - {datetime.now().strftime('%Y-%m-%d')}\n\n"
        text += f"ðŸ’° <b>Jami daromad:</b> {revenue:,} so'm\n"
        text += f"ðŸ’³ <b>To'lovlar soni:</b> {transactions:,}\n"
        if transactions > 0:
            text += f"ðŸ“Š <b>O'rtacha kunlik:</b> {revenue // 7:,} so'm\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_revenue_weekly")
        builder.button(text="ðŸ”™ Revenue Analytics", callback_data="admin_revenue_analytics")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_revenue_monthly")
    async def handle_admin_revenue_monthly(callback: CallbackQuery):
        """Admin: Oylik daromad (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT SUM(amount) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (month_ago,))
            revenue = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM payments 
                WHERE status = 'approved' AND DATE(created_date) >= ?
            ''', (month_ago,))
            transactions = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ’° <b>OYLIK DAROMAD</b>\n\n"
        text += f"ðŸ“… <b>Davr:</b> {month_ago} - {datetime.now().strftime('%Y-%m-%d')}\n\n"
        text += f"ðŸ’° <b>Jami daromad:</b> {revenue:,} so'm\n"
        text += f"ðŸ’³ <b>To'lovlar soni:</b> {transactions:,}\n"
        if transactions > 0:
            text += f"ðŸ“Š <b>O'rtacha kunlik:</b> {revenue // 30:,} so'm\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="admin_revenue_monthly")
        builder.button(text="ðŸ”™ Revenue Analytics", callback_data="admin_revenue_analytics")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== USER SEGMENTATION HANDLERS ==========
    
    @router.callback_query(F.data == "admin_active_users")
    async def handle_admin_active_users(callback: CallbackQuery):
        """Admin: Active users (7 kun) (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT DISTINCT u.user_id, u.full_name, u.xp
                FROM users u
                JOIN download_history dh ON u.user_id = dh.user_id
                WHERE DATE(dh.download_date) >= ?
                ORDER BY u.xp DESC
                LIMIT 20
            ''', (week_ago,))
            active_users = await cursor.fetchall()
            
            cursor = await conn.execute('''
                SELECT COUNT(DISTINCT user_id) FROM download_history 
                WHERE DATE(created_date) >= ?
            ''', (week_ago,))
            total_active = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ”¥ <b>ACTIVE USERS (7 kun)</b>\n\n"
        text += f"ðŸ“Š <b>Jami faol:</b> {total_active:,}\n\n"
        
        if not active_users:
            text += "âŒ Hozircha faol foydalanuvchilar yo'q."
        else:
            text += f"<b>Top {len(active_users)} ta:</b>\n\n"
            for i, (uid, name, xp) in enumerate(active_users, 1):
                text += f"{i}. <b>{name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ’° {xp:,} XP\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ User Segmentation", callback_data="admin_user_segmentation")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_inactive_users")
    async def handle_admin_inactive_users(callback: CallbackQuery):
        """Admin: Inactive users (30 kun) (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT u.user_id, u.full_name, u.xp, u.joined_date
                FROM users u
                WHERE u.user_id NOT IN (
                    SELECT DISTINCT user_id FROM download_history 
                    WHERE DATE(created_date) >= ?
                )
                ORDER BY u.joined_date DESC
                LIMIT 20
            ''', (month_ago,))
            inactive_users = await cursor.fetchall()
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users 
                WHERE user_id NOT IN (
                    SELECT DISTINCT user_id FROM download_history 
                    WHERE DATE(created_date) >= ?
                )
            ''', (month_ago,))
            total_inactive = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ˜´ <b>INACTIVE USERS (30 kun)</b>\n\n"
        text += f"ðŸ“Š <b>Jami nofaol:</b> {total_inactive:,}\n\n"
        
        if not inactive_users:
            text += "âœ… Barcha foydalanuvchilar faol!"
        else:
            text += f"<b>Top {len(inactive_users)} ta:</b>\n\n"
            for i, (uid, name, xp, joined) in enumerate(inactive_users, 1):
                text += f"{i}. <b>{name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ’° {xp:,} XP\n"
                text += f"   ðŸ“… Ro'yxatdan o'tgan: {joined[:10] if joined else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ User Segmentation", callback_data="admin_user_segmentation")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_new_users")
    async def handle_admin_new_users(callback: CallbackQuery):
        """Admin: New users (7 kun) (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        from datetime import datetime, timedelta
        
        week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT user_id, full_name, xp, joined_date
                FROM users
                WHERE DATE(joined_date) >= ?
                ORDER BY joined_date DESC
                LIMIT 20
            ''', (week_ago,))
            new_users = await cursor.fetchall()
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM users WHERE DATE(joined_date) >= ?
            ''', (week_ago,))
            total_new = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ†• <b>NEW USERS (7 kun)</b>\n\n"
        text += f"ðŸ“Š <b>Jami yangi:</b> {total_new:,}\n\n"
        
        if not new_users:
            text += "âŒ Hozircha yangi foydalanuvchilar yo'q."
        else:
            text += f"<b>Oxirgi {len(new_users)} ta:</b>\n\n"
            for i, (uid, name, xp, joined) in enumerate(new_users, 1):
                text += f"{i}. <b>{name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ’° {xp:,} XP\n"
                text += f"   ðŸ“… {joined[:10] if joined else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ User Segmentation", callback_data="admin_user_segmentation")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "admin_top_spenders")
    async def handle_admin_top_spenders(callback: CallbackQuery):
        """Admin: Top spenders (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT user_id, full_name, total_spent, xp
                FROM users
                WHERE total_spent > 0
                ORDER BY total_spent DESC
                LIMIT 20
            ''')
            top_spenders = await cursor.fetchall()
        
        text = f"ðŸ’° <b>TOP SPENDERS</b>\n\n"
        
        if not top_spenders:
            text += "âŒ Hozircha xaridorlar yo'q."
        else:
            text += f"<b>Top {len(top_spenders)} ta:</b>\n\n"
            for i, (uid, name, spent, xp) in enumerate(top_spenders, 1):
                text += f"{i}. <b>{name or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ’° {spent:,} so'm\n"
                text += f"   ðŸ’Ž {xp:,} XP\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ User Segmentation", callback_data="admin_user_segmentation")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== ADVANCED SEARCH HANDLERS ==========
    
    @router.callback_query(F.data == "admin_adv_search_books")
    async def handle_admin_adv_search_books(callback: CallbackQuery, state: FSMContext):
        """Admin: Advanced search - Kitoblar"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "ðŸ” <b>ADVANCED SEARCH - KITOBLAR</b>\n\n"
            "Qidiruv so'zini yozing (kod, nom, muallif, janr):",
            reply_markup=Keyboards.back_button("admin_advanced_search"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_book_search)
        await callback.answer()
    
    @router.callback_query(F.data == "admin_adv_search_movies")
    async def handle_admin_adv_search_movies(callback: CallbackQuery, state: FSMContext):
        """Admin: Advanced search - Filmlar"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "ðŸ” <b>ADVANCED SEARCH - FILMLAR</b>\n\n"
            "Qidiruv so'zini yozing (nom, janr, sifat):",
            reply_markup=Keyboards.back_button("admin_advanced_search"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_movie_id_search)
        await callback.answer()
    
    @router.callback_query(F.data == "admin_adv_search_courses")
    async def handle_admin_adv_search_courses(callback: CallbackQuery, state: FSMContext):
        """Admin: Advanced search - Kurslar"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "ðŸ” <b>ADVANCED SEARCH - KURSLAR</b>\n\n"
            "Qidiruv so'zini yozing (nom, kategoriya):",
            reply_markup=Keyboards.back_button("admin_advanced_search"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_course_search)
        await callback.answer()
    
    @router.callback_query(F.data == "admin_adv_search_users")
    async def handle_admin_adv_search_users(callback: CallbackQuery, state: FSMContext):
        """Admin: Advanced search - Foydalanuvchilar"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "ðŸ” <b>ADVANCED SEARCH - FOYDALANUVCHILAR</b>\n\n"
            "Qidiruv so'zini yozing (ID, ism, username):",
            reply_markup=Keyboards.back_button("admin_advanced_search"),
            parse_mode=ParseMode.HTML
        )
        await state.set_state(AdminStates.waiting_user_search)
        await callback.answer()
    
    @router.callback_query(F.data == "admin_adv_search_payments")
    async def handle_admin_adv_search_payments(callback: CallbackQuery):
        """Admin: Advanced search - To'lovlar"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT p.id, u.full_name, p.amount, p.status, p.created_date
                FROM payments p
                LEFT JOIN users u ON p.user_id = u.user_id
                ORDER BY p.created_date DESC
                LIMIT 50
            ''')
            payments = await cursor.fetchall()
        
        text = f"ðŸ’³ <b>ADVANCED SEARCH - TO'LOVLAR</b>\n\n"
        text += f"ðŸ“Š <b>Oxirgi 50 ta to'lov:</b>\n\n"
        
        for i, (pid, name, amount, status, date) in enumerate(payments[:20], 1):
            status_icon = "âœ…" if status == "approved" else "â³" if status == "pending" else "âŒ"
            text += f"{status_icon} {i}. <b>{name or 'Noma\'lum'}</b>\n"
            text += f"   ðŸ’° {amount:,} so'm\n"
            text += f"   ðŸ“… {date[:10] if date else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Advanced Search", callback_data="admin_advanced_search")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== BULK OPERATIONS HANDLERS ==========
    
    @router.callback_query(F.data == "admin_bulk_delete")
    async def handle_admin_bulk_delete(callback: CallbackQuery):
        """Admin: Bulk delete (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="admin_bulk_delete_books")
        builder.button(text="ðŸŽ¬ Filmlar", callback_data="admin_bulk_delete_movies")
        builder.button(text="ðŸŽ“ Kurslar", callback_data="admin_bulk_delete_courses")
        builder.button(text="ðŸ”™ Bulk Operations", callback_data="admin_bulk_operations")
        builder.adjust(1, 1, 1, 1)
        
        await callback.message.edit_text(
            "ðŸ—‘ï¸ <b>BULK DELETE</b>\n\n"
            "O'chirish uchun kontent turini tanlang:\n\n"
            "âš ï¸ <b>Eslatma:</b> Bu amalni qaytarib bo'lmaydi!",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    @router.callback_query(F.data == "admin_bulk_edit")
    async def handle_admin_bulk_edit(callback: CallbackQuery):
        """Admin: Bulk edit (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "âœï¸ <b>BULK EDIT</b>\n\n"
            "âš ï¸ Bu funksiya keyingi versiyada qo'shiladi.\n\n"
            "Hozircha har bir kontentni alohida tahrirlash mumkin.",
            reply_markup=Keyboards.back_button("admin_bulk_operations"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    @router.callback_query(F.data == "admin_bulk_approve")
    async def handle_admin_bulk_approve(callback: CallbackQuery):
        """Admin: Bulk approve (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT COUNT(*) FROM pending_uploads WHERE status = "pending"')
            pending_count = (await cursor.fetchone())[0] or 0
        
        if pending_count == 0:
            await callback.answer("âœ… Kutilayotgan yuklamalar yo'q!", show_alert=True)
            return
        
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Ha, barchasini tasdiqlash", callback_data="admin_confirm_bulk_approve")
        builder.button(text="âŒ Yo'q, bekor qilish", callback_data="admin_bulk_operations")
        builder.adjust(1, 1)
        
        await callback.message.edit_text(
            f"âœ… <b>BULK APPROVE</b>\n\n"
            f"ðŸ“Š <b>Kutilayotgan yuklamalar:</b> {pending_count:,}\n\n"
            f"Barcha yuklamalarni tasdiqlashni xohlaysizmi?",
            reply_markup=builder.as_markup(),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    @router.callback_query(F.data == "admin_confirm_bulk_approve")
    async def handle_admin_confirm_bulk_approve(callback: CallbackQuery):
        """Admin: Bulk approve tasdiqlash"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        async with db.connect() as conn:
            await conn.execute('UPDATE pending_uploads SET status = "approved" WHERE status = "pending"')
            await conn.commit()
            cursor = await conn.execute('SELECT COUNT(*) FROM pending_uploads WHERE status = "approved"')
            approved_count = (await cursor.fetchone())[0] or 0
        
        await safe_edit_text(callback,
            f"âœ… <b>Barcha yuklamalar tasdiqlandi!</b>\n\n"
            f"ðŸ“Š <b>Tasdiqlangan:</b> {approved_count:,} ta",
            reply_markup=Keyboards.back_button("admin_bulk_operations")
        )
        await callback.answer("âœ… Barcha yuklamalar tasdiqlandi!")
    
    @router.callback_query(F.data == "admin_bulk_premium")
    async def handle_admin_bulk_premium(callback: CallbackQuery):
        """Admin: Bulk premium (professional va tizimli)"""
        user_id = callback.from_user.id
        if not await check_is_admin(user_id, db):
            await callback.answer("Siz admin emassiz!")
            return
        
        await callback.message.edit_text(
            "ðŸ’Ž <b>BULK PREMIUM</b>\n\n"
            "âš ï¸ Bu funksiya keyingi versiyada qo'shiladi.\n\n"
            "Hozircha har bir kontentni alohida Premium qilish mumkin.",
            reply_markup=Keyboards.back_button("admin_bulk_operations"),
            parse_mode=ParseMode.HTML
        )
        await callback.answer()
    
    # ========== FOYDALANUVCHILAR UCHUN QO'SHIMCHA ==========
    
    # ========== SOCIAL FEATURES - IJTIMOIY FUNKSIYALAR ==========
    
    @router.callback_query(F.data == "social_features")
    async def handle_social_features(callback: CallbackQuery):
        """Ijtimoiy funksiyalar menyusi"""
        user_id = callback.from_user.id
        
        text = """
<b>IJTIMOIY FUNKSIYALAR</b>

<b>Nima qilishingiz mumkin:</b>
  â€¢ Do'stlar ro'yxati
  â€¢ Do'stlar statistikasi
  â€¢ Do'stlar bilan raqobat
  â€¢ Kontentni baham ko'rish
  â€¢ Sharhlar va baholash
  â€¢ Sevimlilar ro'yxati

<b>Quyidagilardan birini tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‘¥ Do'stlar", callback_data="social_friends")
        builder.button(text="ðŸ“Š Do'stlar statistikasi", callback_data="social_friends_stats")
        builder.button(text="ðŸ† Raqobat", callback_data="social_competition")
        builder.button(text="ðŸ“¤ Baham ko'rish", callback_data="social_share")
        builder.button(text="ðŸ’¬ Sharhlar", callback_data="social_comments")
        builder.button(text="â­ Sevimlilar", callback_data="social_favorites")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(2, 2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "social_friends")
    async def handle_social_friends(callback: CallbackQuery):
        """Do'stlar ro'yxati"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Referallar orqali do'stlar
            cursor = await conn.execute('''
                SELECT u.user_id, u.full_name, u.username, u.xp, u.subscription_type
                FROM referrals r
                JOIN users u ON r.referred_id = u.user_id
                WHERE r.referrer_id = ?
                ORDER BY u.xp DESC
                LIMIT 20
            ''', (user_id,))
            friends = await cursor.fetchall()
        
        if not friends:
            text = """
ðŸ‘¥ <b>DO'STLAR RO'YXATI</b>

âŒ Hozircha do'stlaringiz yo'q.

ðŸ’¡ <b>Do'st qo'shish:</b>
  â€¢ Referal link orqali do'stlarni taklif qiling
  â€¢ Har bir do'st uchun 75 XP bonus olasiz
  â€¢ Do'stlar ro'yxatida ko'rinadi
            """
        else:
            text = f"<b>DO'STLAR RO'YXATI</b>\n\n"
            text += f"<b>Jami do'stlar:</b> {len(friends)} ta\n\n"
            
            for i, (fid, name, username, xp, sub_type) in enumerate(friends[:10], 1):
                sub_name = DatabaseManager.get_subscription_name(sub_type or 0)
                text += f"{i}. <b>{name or username or 'Noma\'lum'}</b>\n"
                text += f"   {xp or 0:,} XP | {sub_name}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“Š Do'stlar statistikasi", callback_data="social_friends_stats")
        builder.button(text="ðŸ”— Referal link", callback_data="referral_menu")
        builder.button(text="ðŸ”™ Ijtimoiy funksiyalar", callback_data="social_features")
        builder.adjust(1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "social_friends_stats")
    async def handle_social_friends_stats(callback: CallbackQuery):
        """Do'stlar statistikasi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Do'stlar statistikasi
            cursor = await conn.execute('''
                SELECT 
                    COUNT(*) as total_friends,
                    SUM(CASE WHEN u.subscription_type > 0 THEN 1 ELSE 0 END) as premium_friends,
                    AVG(u.xp) as avg_xp,
                    MAX(u.xp) as max_xp
                FROM referrals r
                JOIN users u ON r.referred_id = u.user_id
                WHERE r.referrer_id = ?
            ''', (user_id,))
            stats = await cursor.fetchone()
            
            # Top 3 do'st
            cursor = await conn.execute('''
                SELECT u.full_name, u.xp, u.subscription_type
                FROM referrals r
                JOIN users u ON r.referred_id = u.user_id
                WHERE r.referrer_id = ?
                ORDER BY u.xp DESC
                LIMIT 3
            ''', (user_id,))
            top_friends = await cursor.fetchall()
        
        if not stats or stats[0] == 0:
            text = """
<b>DO'STLAR STATISTIKASI</b>

Hozircha do'stlaringiz yo'q.

Do'stlarni taklif qiling va statistikani ko'ring!
            """
        else:
            text = f"<b>DO'STLAR STATISTIKASI</b>\n\n"
            text += f"<b>Jami do'stlar:</b> {stats[0] or 0} ta\n"
            text += f"<b>Premium do'stlar:</b> {stats[1] or 0} ta\n"
            text += f"<b>O'rtacha XP:</b> {int(stats[2] or 0):,}\n"
            text += f"ðŸ† <b>Eng yuqori XP:</b> {stats[3] or 0:,}\n\n"
            
            if top_friends:
                text += f"ðŸ† <b>TOP 3 DO'ST:</b>\n"
                for i, (name, xp, sub_type) in enumerate(top_friends, 1):
                    sub_name = DatabaseManager.get_subscription_name(sub_type or 0)
                    text += f"{i}. <b>{name or 'Noma\'lum'}</b> - {xp or 0:,} XP ({sub_name})\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‘¥ Do'stlar ro'yxati", callback_data="social_friends")
        builder.button(text="ðŸ”™ Ijtimoiy funksiyalar", callback_data="social_features")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "social_competition")
    async def handle_social_competition(callback: CallbackQuery):
        """Raqobat - do'stlar bilan"""
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        async with db.connect() as conn:
            # Do'stlar bilan solishtirish
            cursor = await conn.execute('''
                SELECT u.user_id, u.full_name, u.xp, u.subscription_type
                FROM referrals r
                JOIN users u ON r.referred_id = u.user_id
                WHERE r.referrer_id = ?
                ORDER BY u.xp DESC
                LIMIT 10
            ''', (user_id,))
            friends = await cursor.fetchall()
        
        user_xp = user.get('xp', 0) if user else 0
        
        text = f"<b>DO'STLAR BILAN RAQOBAT</b>\n\n"
        text += f"<b>Sizning XP:</b> {user_xp:,}\n\n"
        
        if not friends:
            text += "Hozircha do'stlaringiz yo'q.\n\n"
            text += "Do'stlarni taklif qiling va raqobat qiling!"
        else:
            text += f"<b>REYTING:</b>\n\n"
            position = 1
            for fid, name, xp, sub_type in friends:
                if xp and xp > user_xp:
                    position += 1
            
            text += f"{position}. <b>Siz</b> - {user_xp:,} XP\n\n"
            
            for i, (fid, name, xp, sub_type) in enumerate(friends[:5], 1):
                if xp and xp <= user_xp:
                    position += 1
                rank = f"{position}."
                text += f"{rank} <b>{name or 'Noma\'lum'}</b> - {xp or 0:,} XP\n"
                position += 1
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“ˆ Reyting jadvali", callback_data="leaderboard")
        builder.button(text="ðŸ‘¥ Do'stlar", callback_data="social_friends")
        builder.button(text="ðŸ”™ Ijtimoiy funksiyalar", callback_data="social_features")
        builder.adjust(1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "leaderboard")
    async def handle_leaderboard(callback: CallbackQuery):
        """Global reyting jadvali - Leagues tizimi bilan"""
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        # Foydalanuvchining ligasi va o'rni
        league_info = await db.get_user_league_rank(user_id)
        
        if not league_info:
            await callback.answer("âŒ Ma'lumot topilmadi!")
            return
        
        league = league_info.get('league', {})
        rank = league_info.get('rank', 0)
        total_players = league_info.get('total_players', 0)
        level = league_info.get('level', 0)
        xp = league_info.get('xp', 0)
        
        # Liga bo'yicha top 10
        leaderboard = await db.get_league_leaderboard(league.get('name', 'Bronza'), 10)
        
        text = f"ðŸ† <b>REYTING JADVALI</b>\n\n"
        text += f"{league.get('emoji', 'ðŸ¥‰')} <b>Liga:</b> {league.get('name', 'Bronza')}\n"
        text += f"ðŸ“Š <b>Sizning o'rningiz:</b> {rank}/{total_players}\n"
        text += f"ðŸ† <b>Daraja:</b> {level}\n"
        text += f"ðŸ’° <b>XP:</b> {xp:,}\n\n"
        
        if leaderboard:
            text += f"<b>TOP 10 - {league.get('name', 'Bronza')} Liga:</b>\n\n"
            for i, player in enumerate(leaderboard, 1):
                medal = "ðŸ¥‡" if i == 1 else "ðŸ¥ˆ" if i == 2 else "ðŸ¥‰" if i == 3 else f"{i}."
                name = player.get('full_name', 'Noma\'lum')[:20]
                player_xp = player.get('xp', 0)
                player_level = player.get('level', 0)
                is_premium = player.get('subscription_type', 0) > 0
                premium_icon = "ðŸ’Ž" if is_premium else ""
                
                if player.get('user_id') == user_id:
                    text += f"{medal} <b>{name}</b> {premium_icon} - {player_xp:,} XP (Lvl {player_level}) â­\n"
                else:
                    text += f"{medal} {name} {premium_icon} - {player_xp:,} XP (Lvl {player_level})\n"
        else:
            text += "âŒ Hozircha reyting bo'sh.\n"
        
        # Liga mukofotlari
        rewards = await db.get_league_rewards(league.get('name', 'Bronza'))
        text += f"\nðŸŽ <b>Liga mukofotlari:</b>\n"
        text += f"  ðŸ’° {rewards.get('xp', 0):,} XP\n"
        text += f"  ðŸ¤– {rewards.get('ai_limit', 0)} AI limit\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ¥‰ Bronza", callback_data="league_bronza")
        builder.button(text="ðŸ¥ˆ Kumush", callback_data="league_kumush")
        builder.button(text="ðŸ¥‡ Oltin", callback_data="league_oltin")
        builder.button(text="ðŸ’Ž Platina", callback_data="league_platina")
        builder.button(text="ðŸ’  Brilliant", callback_data="league_brilliant")
        builder.button(text="ðŸ‘‘ Legend", callback_data="league_legend")
        builder.button(text="ðŸ”„ Yangilash", callback_data="leaderboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(2, 2, 2, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("league_"))
    async def handle_league_view(callback: CallbackQuery):
        """Liga bo'yicha reyting ko'rish"""
        league_name = callback.data.replace("league_", "").capitalize()
        
        # Liga nomini to'g'rilash
        league_names = {
            'Bronza': 'Bronza',
            'Kumush': 'Kumush',
            'Oltin': 'Oltin',
            'Platina': 'Platina',
            'Brilliant': 'Brilliant',
            'Legend': 'Legend'
        }
        league_name = league_names.get(league_name, 'Bronza')
        
        # Liga bo'yicha top 20
        leaderboard = await db.get_league_leaderboard(league_name, 20)
        
        league_emojis = {
            'Bronza': 'ðŸ¥‰',
            'Kumush': 'ðŸ¥ˆ',
            'Oltin': 'ðŸ¥‡',
            'Platina': 'ðŸ’Ž',
            'Brilliant': 'ðŸ’ ',
            'Legend': 'ðŸ‘‘'
        }
        
        text = f"{league_emojis.get(league_name, 'ðŸ¥‰')} <b>{league_name.upper()} LIGA</b>\n\n"
        text += f"ðŸ“Š <b>Jami o'yinchilar:</b> {len(leaderboard)}\n\n"
        
        if leaderboard:
            text += f"<b>TOP 20:</b>\n\n"
            for i, player in enumerate(leaderboard, 1):
                medal = "ðŸ¥‡" if i == 1 else "ðŸ¥ˆ" if i == 2 else "ðŸ¥‰" if i == 3 else f"{i}."
                name = player.get('full_name', 'Noma\'lum')[:20]
                player_xp = player.get('xp', 0)
                player_level = player.get('level', 0)
                is_premium = player.get('subscription_type', 0) > 0
                premium_icon = "ðŸ’Ž" if is_premium else ""
                
                text += f"{medal} {name} {premium_icon} - {player_xp:,} XP (Lvl {player_level})\n"
        else:
            text += "âŒ Bu ligada hozircha o'yinchilar yo'q.\n"
        
        # Liga mukofotlari
        rewards = await db.get_league_rewards(league_name)
        text += f"\nðŸŽ <b>Liga mukofotlari:</b>\n"
        text += f"  ðŸ’° {rewards.get('xp', 0):,} XP\n"
        text += f"  ðŸ¤– {rewards.get('ai_limit', 0)} AI limit\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Reyting", callback_data="leaderboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "social_share")
    async def handle_social_share(callback: CallbackQuery):
        """Kontentni baham ko'rish"""
        user_id = callback.from_user.id
        
        text = """
<b>BAHAM KO'RISH</b>

<b>Nima baham ko'rishingiz mumkin:</b>
  â€¢ Kitoblar
  â€¢ Filmlar
  â€¢ Kurslar
  â€¢ AI javoblar
  â€¢ Statistika

<b>Qanday ishlaydi:</b>
  â€¢ Kontentni tanlang
  â€¢ Baham ko'rish tugmasini bosing
  â€¢ Do'stlaringizga yuboring
  â€¢ Har bir baham ko'rish uchun 10 XP bonus!

<b>Quyidagilardan birini tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitob baham ko'rish", callback_data="share_books")
        builder.button(text="ðŸŽ¬ Film baham ko'rish", callback_data="share_movies")
        builder.button(text="ðŸŽ“ Kurs baham ko'rish", callback_data="share_courses")
        builder.button(text="ðŸ“Š Statistika baham ko'rish", callback_data="share_stats")
        builder.button(text="ðŸ”™ Ijtimoiy funksiyalar", callback_data="social_features")
        builder.adjust(1, 1, 1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.in_(["share_books", "share_movies", "share_courses", "share_stats"]))
    async def handle_share_content(callback: CallbackQuery):
        """Kontentni baham ko'rish"""
        user_id = callback.from_user.id
        share_type = callback.data.replace("share_", "")
        
        # Baham ko'rish uchun referal link
        referral_link = f"https://t.me/{bot.username}?start=ref_{user_id}"
        
        share_texts = {
            "books": "<b>KITOBLAR BAHAM KO'RISH</b>\n\n",
            "movies": "<b>FILMLAR BAHAM KO'RISH</b>\n\n",
            "courses": "<b>KURSLAR BAHAM KO'RISH</b>\n\n",
            "stats": "<b>STATISTIKA BAHAM KO'RISH</b>\n\n"
        }
        
        text = share_texts.get(share_type, "<b>BAHAM KO'RISH</b>\n\n")
        text += f"<b>Referal link:</b>\n<code>{referral_link}</code>\n\n"
        text += "<b>Qanday ishlaydi:</b>\n"
        text += "1. Linkni do'stlaringizga yuboring\n"
        text += "2. Do'stlar botga qo'shilsa, siz 75 XP olasiz\n"
        text += "3. Har bir baham ko'rish uchun 10 XP bonus!\n\n"
        text += "Linkni nusxalash uchun ustiga bosing!"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“‹ Linkni nusxalash", url=referral_link)
        builder.button(text="ðŸ”™ Baham ko'rish", callback_data="social_share")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer("âœ… Link tayyor!")
    
    @router.callback_query(F.data == "social_comments")
    async def handle_social_comments(callback: CallbackQuery):
        """Sharhlar va baholash"""
        user_id = callback.from_user.id
        
        text = """
<b>SHARHLAR VA BAHOLASH</b>

<b>Nima qilishingiz mumkin:</b>
  â€¢ Kitoblarni baholash
  â€¢ Filmlarga sharh qoldirish
  â€¢ Kurslarga izoh yozish
  â€¢ Boshqa foydalanuvchilar sharhlariga like berish

<b>Qanday ishlaydi:</b>
  â€¢ Kontentni oching
  â€¢ "Baholash" tugmasini bosing
  â€¢ 1-5 yulduzcha baholang
  â€¢ Sharh yozing (ixtiyoriy)
  â€¢ Har bir baholash uchun 5 XP bonus!

<b>Quyidagilardan birini tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="library_menu")
        builder.button(text="ðŸŽ¬ Filmlar", callback_data="cinema_menu")
        builder.button(text="ðŸŽ“ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ”™ Ijtimoiy funksiyalar", callback_data="social_features")
        builder.adjust(1, 1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "social_favorites")
    async def handle_social_favorites(callback: CallbackQuery):
        """Sevimlilar ro'yxati"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Sevimlilar
            cursor = await conn.execute('''
                SELECT f.item_type, f.item_id, 
                       COALESCE(b.caption, m.caption, c.title, 'Noma\'lum') as name
                FROM favorites f
                LEFT JOIN books b ON f.item_type = 'book' AND f.item_id = b.id
                LEFT JOIN movies m ON f.item_type = 'movie' AND f.item_id = m.id
                LEFT JOIN courses c ON f.item_type = 'course' AND f.item_id = c.id
                WHERE f.user_id = ?
                ORDER BY f.created_date DESC
                LIMIT 20
            ''', (user_id,))
            favorites = await cursor.fetchall()
        
        if not favorites:
            text = """
<b>SEVIMLILAR RO'YXATI</b>

Hozircha sevimlilar yo'q.

<b>Qanday qo'shish:</b>
  â€¢ Kitob, film yoki kursni oching
  â€¢ "Sevimlilarga qo'shish" tugmasini bosing
  â€¢ Bu yerda ko'rinadi
            """
        else:
            text = f"<b>SEVIMLILAR RO'YXATI</b>\n\n"
            text += f"<b>Jami:</b> {len(favorites)} ta\n\n"
            
            for i, (item_type, item_id, name) in enumerate(favorites[:10], 1):
                text += f"{i}. <b>{name or 'Noma\'lum'}</b>\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="library_menu")
        builder.button(text="ðŸŽ¬ Filmlar", callback_data="cinema_menu")
        builder.button(text="ðŸ”™ Ijtimoiy funksiyalar", callback_data="social_features")
        builder.adjust(1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== PROGRESS TRACKING - TARAQQIYOT KUZATISH ==========
    
    @router.callback_query(F.data == "progress_tracking")
    async def handle_progress_tracking(callback: CallbackQuery):
        """Taraqqiyot kuzatish menyusi"""
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        user_xp = user.get('xp', 0)
        user_level = user_xp // 1000 + 1 if user_xp else 1
        next_level_xp = user_level * 1000
        progress = (user_xp % 1000) / 1000 * 100 if user_xp else 0
        
        async with db.connect() as conn:
            # Kunlik statistika
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM download_history
                WHERE user_id = ? AND DATE(download_date) = DATE('now')
            ''', (user_id,))
            daily_downloads = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM user_courses
                WHERE user_id = ? AND DATE(purchase_date) = DATE('now')
            ''', (user_id,))
            daily_courses = (await cursor.fetchone())[0] or 0
        
        text = f"""
<b>TARAQQIYOT KUZATISH</b>

<b>XP:</b> {user_xp:,} / {next_level_xp:,}
<b>Level:</b> {user_level}
<b>Progress:</b> {progress:.1f}%

<b>BUGUN:</b>
  Yuklashlar: {daily_downloads} ta
  Kurslar: {daily_courses} ta

<b>Quyidagilardan birini tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“Š Batafsil statistika", callback_data="detailed_stats")
        builder.button(text="ðŸ“ˆ XP tarixi", callback_data="progress_xp_history")
        builder.button(text="ðŸ“¥ Yuklash tarixi", callback_data="progress_download_history")
        builder.button(text="ðŸŽ“ Kurslar tarixi", callback_data="progress_courses_history")
        builder.button(text="ðŸ† Yutuqlar", callback_data="my_achievements")
        builder.button(text="ðŸ“Š Dashboard", callback_data="my_dashboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(2, 2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "progress_xp_history")
    async def handle_progress_xp_history(callback: CallbackQuery):
        """XP tarixi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT amount, description, created_date
                FROM xp_transactions
                WHERE user_id = ?
                ORDER BY created_date DESC
                LIMIT 20
            ''', (user_id,))
            transactions = await cursor.fetchall()
        
        if not transactions:
            text = """
ðŸ’° <b>XP TARIXI</b>

âŒ Hozircha XP transaksiyalari yo'q.

ðŸ’¡ <b>XP qanday olinadi:</b>
  â€¢ Kitob yuklash - 50 XP
  â€¢ Film ko'rish - 100 XP
  â€¢ Kurs sotib olish - 500 XP
  â€¢ Kunlik bonus - 100 XP
  â€¢ Referal - 75 XP
            """
        else:
            text = f"<b>XP TARIXI</b>\n\n"
            text += f"<b>Oxirgi {len(transactions)} ta:</b>\n\n"
            
            for amount, desc, date in transactions[:10]:
                sign = "+" if amount > 0 else ""
                text += f"{sign}{amount} XP - {desc or 'Noma\'lum'}\n"
                text += f"   ðŸ“… {date[:10] if date else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“Š Batafsil statistika", callback_data="detailed_stats")
        builder.button(text="ðŸ”™ Taraqqiyot kuzatish", callback_data="progress_tracking")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "progress_download_history")
    async def handle_progress_download_history(callback: CallbackQuery):
        """Yuklash tarixi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT item_type, item_id, created_date
                FROM download_history
                WHERE user_id = ?
                ORDER BY created_date DESC
                LIMIT 20
            ''', (user_id,))
            downloads = await cursor.fetchall()
        
        if not downloads:
            text = """
ðŸ“¥ <b>YUKLASH TARIXI</b>

âŒ Hozircha yuklashlar yo'q.

ðŸ’¡ <b>Qanday yuklash:</b>
  â€¢ Kitoblar bo'limiga kiring
  â€¢ Kitobni tanlang va yuklang
  â€¢ Bu yerda ko'rinadi
            """
        else:
            text = f"<b>YUKLASH TARIXI</b>\n\n"
            text += f"ðŸ“Š <b>Oxirgi {len(downloads)} ta:</b>\n\n"
            
            for item_type, item_id, date in downloads[:10]:
                emoji = "ðŸ“š" if item_type == "book" else "ðŸŽ¬" if item_type == "movie" else "ðŸŽ“"
                text += f"{emoji} {item_type.capitalize()} #{item_id}\n"
                text += f"   ðŸ“… {date[:10] if date else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="library_menu")
        builder.button(text="ðŸ”™ Taraqqiyot kuzatish", callback_data="progress_tracking")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "progress_courses_history")
    async def handle_progress_courses_history(callback: CallbackQuery):
        """Kurslar tarixi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT c.title, c.category, COALESCE(uc.purchase_date, datetime('now')) as purchase_date, uc.progress
                FROM user_courses uc
                JOIN courses c ON uc.course_id = c.id
                WHERE uc.user_id = ?
                ORDER BY COALESCE(uc.purchase_date, datetime('now')) DESC
                LIMIT 20
            ''', (user_id,))
            courses = await cursor.fetchall()
        
        if not courses:
            text = """
ðŸŽ“ <b>KURSLAR TARIXI</b>

âŒ Hozircha kurslar yo'q.

ðŸ’¡ <b>Qanday sotib olish:</b>
  â€¢ Kurslar bo'limiga kiring
  â€¢ Kursni tanlang va sotib oling
  â€¢ Bu yerda ko'rinadi
            """
        else:
            text = f"<b>KURSLAR TARIXI</b>\n\n"
            text += f"ðŸ“Š <b>Jami kurslar:</b> {len(courses)} ta\n\n"
            
            for title, category, date, progress in courses[:10]:
                text += f"ðŸ“š <b>{title or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ“‚ {category or 'Noma\'lum'}\n"
                text += f"   ðŸ“ˆ Progress: {progress or 0}%\n"
                text += f"   ðŸ“… {date[:10] if date else 'N/A'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ“ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ”™ Taraqqiyot kuzatish", callback_data="progress_tracking")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== YANGI FUNKSIYALAR HANDLER'LARI ==========
    
    @router.callback_query(F.data == "my_dashboard")
    async def handle_my_dashboard(callback: CallbackQuery):
        """Shaxsiylashtirilgan Dashboard"""
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        user_xp = user.get('xp', 0)
        user_level = user_xp // 1000 + 1 if user_xp else 1
        subscription_type = user.get('subscription_type', 0)
        subscription_name = DatabaseManager.get_subscription_name(subscription_type)
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT COUNT(*) FROM download_history WHERE user_id = ?', (user_id,))
            total_downloads = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM user_courses WHERE user_id = ?', (user_id,))
            total_courses = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM favorites WHERE user_id = ?', (user_id,))
            total_favorites = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('SELECT COUNT(*) FROM referrals WHERE referrer_id = ?', (user_id,))
            total_referrals = (await cursor.fetchone())[0] or 0
        
        achievements_count = 0
        achievements = user.get('achievements', '[]')
        try:
            import json
            achievements_list = json.loads(achievements) if achievements else []
            achievements_count = len(achievements_list)
        except:
            achievements_count = 0
        
        text = f"""
<b>SHAXSIYLASHTIRILGAN DASHBOARD</b>

<b>Foydalanuvchi:</b> {user.get('full_name', 'Noma\'lum')}
<b>XP:</b> {user_xp:,} | <b>Level:</b> {user_level}
<b>Status:</b> {subscription_name}

<b>STATISTIKA:</b>
  Yuklashlar: {total_downloads} ta
  Kurslar: {total_courses} ta
  Sevimlilar: {total_favorites} ta
  Referrallar: {total_referrals} ta
  Yutuqlar: {achievements_count} ta

<b>QUICK ACTIONS:</b>
  â€¢ Kitoblar yuklash
  â€¢ Filmlar ko'rish
  â€¢ Kurslar sotib olish
  â€¢ AI Mentor bilan suhbat
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="library_menu")
        builder.button(text="ðŸŽ¬ Filmlar", callback_data="cinema_menu")
        builder.button(text="ðŸŽ“ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ¤– AI Mentor", callback_data="ai_menu")
        builder.button(text="ðŸ† Yutuqlar", callback_data="my_achievements")
        builder.button(text="ðŸ“ˆ Reyting", callback_data="leaderboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(2, 2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "my_achievements")
    async def handle_my_achievements(callback: CallbackQuery):
        """Foydalanuvchi yutuqlari - to'liq ishlaydigan"""
        user_id = callback.from_user.id
        
        # Yutuqlarni tekshirish va berish
        awarded = await db.check_and_award_achievements(user_id)
        
        # Yutuqlarni olish
        achievements_data = await db.get_user_achievements(user_id)
        unlocked = achievements_data.get('unlocked', [])
        locked = achievements_data.get('locked', [])
        
        text = f"ðŸ† <b>MENING YUTUQLARIM</b>\n\n"
        text += f"âœ… <b>Ochilgan:</b> {len(unlocked)} ta\n"
        text += f"ðŸ”’ <b>Qulflangan:</b> {len(locked)} ta\n\n"
        
        if unlocked:
            text += "âœ… <b>OCHILGAN YUTUQLAR:</b>\n"
            for ach in unlocked:
                text += f"  {ach['name']}\n"
                text += f"  ðŸ’° {ach['xp']} XP | {ach['desc']}\n\n"
        
        if locked:
            text += "ðŸ”’ <b>QULFLANGAN YUTUQLAR:</b>\n"
            for ach in locked[:5]:  # Faqat 5 tasini ko'rsatish
                text += f"  {ach['name']}\n"
                text += f"  ðŸ’° {ach['xp']} XP | {ach['desc']}\n\n"
        
        # Agar yangi yutuq berilgan bo'lsa
        if awarded:
            text += f"\nðŸŽ‰ <b>YANGI YUTUQLAR:</b>\n"
            for ach_name in awarded:
                text += f"  âœ¨ {ach_name}\n"
        
        text += "\nðŸ’¡ <b>Maslahat:</b> Ko'proq faollik ko'rsating va yutuqlar oching!"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="my_achievements")
        builder.button(text="ðŸ“Š Dashboard", callback_data="my_dashboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        
        if awarded:
            await callback.answer(f"ðŸŽ‰ Yangi yutuq: {', '.join(awarded)}", show_alert=True)
        else:
            await callback.answer()
    
    @router.callback_query(F.data == "daily_challenges")
    async def handle_daily_challenges_redirect(callback: CallbackQuery):
        """Eski daily_challenges -> yangi daily_challenge ga yo'naltirish"""
        # Yangi gamification daily_challenge ga yo'naltirish
        await callback.answer("ðŸŽ¯ Kunlik Challenge bo'limiga o'ting!", show_alert=False)
        # Gamification hub ga yo'naltirish
        from aiogram.types import CallbackQuery as CQ
        callback.data = "daily_challenge"
        await handle_daily_challenge(callback)
    
    @router.callback_query(F.data == "smart_recommendations")
    async def handle_smart_recommendations(callback: CallbackQuery):
        """Aqlli takliflar - AI orqali oxirgi harakatlari asosida (1 kunda 1 marta limit)"""
        user_id = callback.from_user.id
        
        # Kunlik limit tekshiruvi
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT last_ai_recommendation_date
                FROM users
                WHERE user_id = ?
            ''', (user_id,))
            user_row = await cursor.fetchone()
            
            if user_row and user_row[0]:
                from datetime import datetime as dt
                try:
                    # ISO format stringni parse qilish
                    date_str = str(user_row[0]).replace('Z', '').split('.')[0]
                    last_recommendation = dt.fromisoformat(date_str)
                except (ValueError, AttributeError):
                    # Agar fromisoformat ishlamasa yoki xato bo'lsa, strptime ishlatish
                    try:
                        date_str = str(user_row[0]).replace('Z', '').split('.')[0]
                        last_recommendation = dt.strptime(date_str, '%Y-%m-%d %H:%M:%S')
                    except:
                        # Agar bu ham ishlamasa, bugungi sana bilan solishtirish
                        last_recommendation = None
                
                today = dt.now().date()
                
                if last_recommendation.date() == today:
                    await callback.answer(
                        "â° Siz bugun allaqachon AI tavsiyasini olgansiz!\n\n"
                        "ðŸ’¡ Ertaga qaytib keling va yangi tavsiyalar oling.",
                        show_alert=True
                    )
                    return
        
        # Oxirgi harakatlarni olish (oxirgi 7 kun)
        async with db.connect() as conn:
            # Oxirgi yuklab olingan kitoblar
            cursor = await conn.execute('''
                SELECT DISTINCT dh.item_id, b.caption, b.author, b.genre
                FROM download_history dh
                JOIN books b ON dh.item_type = 'book' AND dh.item_id = b.id
                WHERE dh.user_id = ? 
                AND DATE(dh.download_date) >= DATE('now', '-7 days')
                AND b.is_active = 1
                ORDER BY dh.download_date DESC
                LIMIT 5
            ''', (user_id,))
            recent_books = await cursor.fetchall()
            
            # Oxirgi ko'rilgan filmlar
            cursor = await conn.execute('''
                SELECT DISTINCT dh.item_id, m.caption, m.genre, m.language
                FROM download_history dh
                JOIN movies m ON dh.item_type = 'movie' AND dh.item_id = m.id
                WHERE dh.user_id = ? 
                AND DATE(dh.download_date) >= DATE('now', '-7 days')
                AND m.is_active = 1
                ORDER BY dh.download_date DESC
                LIMIT 5
            ''', (user_id,))
            recent_movies = await cursor.fetchall()
            
            # Oxirgi sotib olingan kurslar
            cursor = await conn.execute('''
                SELECT DISTINCT uc.course_id, c.title, c.category
                FROM user_courses uc
                JOIN courses c ON uc.course_id = c.id
                WHERE uc.user_id = ? 
                AND DATE(COALESCE(uc.purchase_date, datetime('now'))) >= DATE('now', '-7 days')
                AND c.is_active = 1
                ORDER BY COALESCE(uc.purchase_date, datetime('now')) DESC
                LIMIT 5
            ''', (user_id,))
            recent_courses = await cursor.fetchall()
        
        # AI orqali tavsiyalar (oxirgi harakatlar asosida)
        text = f"<b>AI TAKLIFLAR</b>\n\n"
        text += f"<b>Sizning oxirgi harakatlaringizga asoslangan tavsiyalar:</b>\n\n"
        
        # Kitoblar tavsiyasi
        if recent_books:
            book_genres = [book[3] for book in recent_books if book[3]]
            if book_genres:
                most_common_genre = max(set(book_genres), key=book_genres.count)
                async with db.connect() as conn:
                    cursor = await conn.execute('''
                        SELECT code, caption, author, downloads
                        FROM books
                        WHERE is_active = 1 
                        AND genre = ?
                        AND id NOT IN (SELECT item_id FROM download_history WHERE user_id = ? AND item_type = 'book')
                        ORDER BY downloads DESC
                        LIMIT 3
                    ''', (most_common_genre, user_id))
                    recommended_books = await cursor.fetchall()
                    
                    if recommended_books:
                        text += f"ðŸ“š <b>TAVSIYA ETILGAN KITOBLAR ({most_common_genre}):</b>\n"
                        for code, caption, author, downloads in recommended_books:
                            text += f"  â€¢ {caption or 'Noma\'lum'}\n"
                            text += f"    ðŸ‘¤ {author or 'Noma\'lum'} | ðŸ“¥ {downloads or 0} yuklash\n"
                        text += "\n"
        
        # Filmlar tavsiyasi
        if recent_movies:
            movie_genres = [movie[2] for movie in recent_movies if movie[2]]
            if movie_genres:
                most_common_genre = max(set(movie_genres), key=movie_genres.count)
                async with db.connect() as conn:
                    cursor = await conn.execute('''
                        SELECT id, caption, genre, views
                        FROM movies
                        WHERE is_active = 1 
                        AND genre = ?
                        AND id NOT IN (SELECT item_id FROM download_history WHERE user_id = ? AND item_type = 'movie')
                        ORDER BY views DESC
                        LIMIT 3
                    ''', (most_common_genre, user_id))
                    recommended_movies = await cursor.fetchall()
                    
                    if recommended_movies:
                        text += f"ðŸŽ¬ <b>TAVSIYA ETILGAN FILMLAR ({most_common_genre}):</b>\n"
                        for id, caption, genre, views in recommended_movies:
                            text += f"  â€¢ {caption or 'Noma\'lum'}\n"
                            text += f"    ðŸ“‚ {genre or 'Noma\'lum'} | ðŸ‘ï¸ {views or 0} ko'rish\n"
                        text += "\n"
        
        # Kurslar tavsiyasi
        if recent_courses:
            course_categories = [course[2] for course in recent_courses if course[2]]
            if course_categories:
                most_common_category = max(set(course_categories), key=course_categories.count)
                async with db.connect() as conn:
                    cursor = await conn.execute('''
                        SELECT id, title, category, COALESCE(students_count, 0) as students_count
                        FROM courses
                        WHERE is_active = 1 
                        AND category = ?
                        AND id NOT IN (SELECT course_id FROM user_courses WHERE user_id = ?)
                        ORDER BY COALESCE(students_count, 0) DESC
                        LIMIT 3
                    ''', (most_common_category, user_id))
                    recommended_courses = await cursor.fetchall()
                    
                    if recommended_courses:
                        text += f"ðŸŽ“ <b>TAVSIYA ETILGAN KURSLAR ({most_common_category}):</b>\n"
                        for id, title, category, students in recommended_courses:
                            text += f"  â€¢ {title or 'Noma\'lum'}\n"
                            text += f"    ðŸ“‚ {category or 'Noma\'lum'} | ðŸ‘¥ {students or 0} talaba\n"
                        text += "\n"
        
        # Agar hech qanday tavsiya topilmasa
        if not text.endswith("\n\n"):
            text += "ðŸ’¡ <b>Hozircha tavsiyalar yo'q.</b>\n"
            text += "ðŸ“š Kitoblar, filmlar yoki kurslar bilan shug'ullaning, keyin AI sizga tavsiyalar beradi!\n\n"
        
        text += "â° <b>Eslatma:</b> AI tavsiyalar kuniga 1 marta mavjud."
        
        # last_ai_recommendation_date ni yangilash
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE users 
                SET last_ai_recommendation_date = datetime('now')
                WHERE user_id = ?
            ''', (user_id,))
            await conn.commit()
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kitoblar", callback_data="library_menu")
        builder.button(text="ðŸŽ¬ Filmlar", callback_data="cinema_menu")
        builder.button(text="ðŸŽ“ Kurslar", callback_data="courses_menu")
        builder.button(text="ðŸ“Š Dashboard", callback_data="my_dashboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 1, 1, 1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer("âœ… AI tavsiyalar tayyorlandi!")
    
    @router.callback_query(F.data == "help_menu")
    async def handle_help_menu(callback: CallbackQuery):
        """Yordam menyusi"""
        user_id = callback.from_user.id
        
        text = """
ðŸ†˜ <b>YORDAM & SUPPORT</b>

ðŸ“š <b>Qo'llanma:</b>
  â€¢ Botdan qanday foydalanish
  â€¢ Barcha funksiyalar haqida

ðŸ”§ <b>Troubleshooter:</b>
  â€¢ Muammolarni hal qilish
  â€¢ Tez yechimlar

ðŸŽ« <b>Support Ticket:</b>
  â€¢ Adminlarga xabar yuborish
  â€¢ Muammolarni hal qilish

ðŸ“¡ <b>Status sahifasi:</b>
  â€¢ Bot holati
  â€¢ Tizim statistikasi

ðŸ‘‡ <b>Quyidagilardan birini tanlang:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Qo'llanma", callback_data="user_guide")
        builder.button(text="ðŸ”§ Troubleshooter", callback_data="troubleshooter")
        builder.button(text="ðŸŽ« Support ticket", callback_data="support_ticket")
        builder.button(text="ðŸ“¡ Status sahifasi", callback_data="status_page")
        builder.button(text="ðŸ‘¨â€ðŸ’¼ Admin bilan bog'lanish", url=f"https://t.me/{Config.SUPPORT_USERNAME.replace('@', '')}")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "detailed_stats")
    async def handle_detailed_stats(callback: CallbackQuery):
        """Foydalanuvchi: Batafsil statistika (AJOYIB!)"""
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        # Batafsil statistika
        async with db.connect() as conn:
            # Janrlar bo'yicha statistika
            cursor = await conn.execute('''
                SELECT b.genre, COUNT(*) as count
                FROM download_history dh
                JOIN books b ON dh.item_id = b.id AND dh.item_type = 'book'
                WHERE dh.user_id = ?
                GROUP BY b.genre
                ORDER BY count DESC
                LIMIT 5
            ''', (user_id,))
            genre_stats = await cursor.fetchall()
            
            # Kategoriyalar bo'yicha statistika
            cursor = await conn.execute('''
                SELECT c.category, COUNT(*) as count
                FROM user_courses uc
                JOIN courses c ON uc.course_id = c.id
                WHERE uc.user_id = ?
                GROUP BY c.category
                ORDER BY count DESC
                LIMIT 5
            ''', (user_id,))
            category_stats = await cursor.fetchall()
        
        text = f"ðŸ“Š <b>BATAFSIL STATISTIKA</b>\n\n"
        
        if genre_stats:
            text += f"ðŸ“š <b>SEVIMLI JANRLAR:</b>\n"
            for genre, count in genre_stats:
                text += f"   ðŸ“‚ {genre}: {count} ta\n"
            text += "\n"
        
        if category_stats:
            text += f"ðŸŽ“ <b>SEVIMLI KATEGORIYALAR:</b>\n"
            for category, count in category_stats:
                text += f"   ðŸ“‚ {category}: {count} ta\n"
            text += "\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“Š Dashboard", callback_data="my_dashboard")
        builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
        builder.adjust(1, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ==========================================================================
    # AI QUIZ MAKER HANDLERS
    # ==========================================================================
    # Barcha Quiz funksiyalari: Test yaratish, SRS, Duel, Streak, Sertifikat
    # ==========================================================================
    
    # ========== QUIZ CREATION LIMITS FUNKSIYASI ==========
    async def get_user_quiz_creation_limits(user_id: int) -> dict:
        """Foydalanuvchi quiz yaratish limitlarini olish"""
        try:
            user = await db.get_user(user_id)
            if not user:
                return {
                    "can_create": False,
                    "created_count": 0,
                    "max_quizzes": 2,
                    "max_questions_per_quiz": 20,
                    "tier": "Free"
                }
            
            subscription_type = user.get('subscription_type', 0)
            
            # Subscription turiga qarab limitlar
            if subscription_type >= 4:  # PRO
                tier = "Pro"
                max_quizzes = 999
                max_questions = 999
            elif subscription_type >= 2:  # Premium/Exclusive
                tier = "Premium"
                max_quizzes = 999
                max_questions = 100
            elif subscription_type == 1:  # Trial
                tier = "Trial"
                max_quizzes = 10
                max_questions = 30
            else:  # Free
                tier = "Free"
                max_quizzes = 2
                max_questions = 20
            
            # Yaratilgan testlar sonini olish
            async with db.connect() as conn:
                cursor = await conn.execute(
                    'SELECT COUNT(*) FROM quizzes WHERE user_id = ?',
                    (user_id,)
                )
                created_count = (await cursor.fetchone())[0] or 0
            
            can_create = created_count < max_quizzes or max_quizzes >= 999
            
            return {
                "can_create": can_create,
                "created_count": created_count,
                "max_quizzes": max_quizzes,
                "max_questions_per_quiz": max_questions,
                "tier": tier
            }
        except Exception as e:
            logger.error(f"get_user_quiz_creation_limits error: {e}")
            return {
                "can_create": True,
                "created_count": 0,
                "max_quizzes": 2,
                "max_questions_per_quiz": 20,
                "tier": "Free"
            }
    
    # ========== AI QUIZ GENERATOR FUNKSIYASI ==========
    async def generate_quiz_with_ai(topic: str, difficulty: str = "medium", count: int = 5, category: str = "Umumiy") -> dict:
        """AI orqali test yaratish (OpenAI GPT)"""
        if not Config.OPENAI_API_KEY:
            return None
        
        difficulty_map = {
            "easy": "oson (boshlang'ich daraja)",
            "medium": "o'rta (o'rta daraja)",
            "hard": "qiyin (yuqori daraja)"
        }
        diff_text = difficulty_map.get(difficulty, "o'rta")
        
        prompt = f"""Quyidagi mavzu bo'yicha {count} ta test savoli yarat:

MAVZU: {topic}
KATEGORIYA: {category}
QIYINLIK: {diff_text}

Har bir savol uchun:
1. Savol matni (aniq va tushunarli)
2. 4 ta javob varianti (A, B, C, D)
3. To'g'ri javob indeksi (0-3)
4. Qisqa tushuntirish (nega bu javob to'g'ri)

MUHIM:
- Savollar o'zbek tilida bo'lsin
- Javob variantlari mantiqiy va o'xshash bo'lsin
- Faqat bitta to'g'ri javob bo'lsin
- Javob variantlarida A, B, C, D harflarini YOZMA, faqat variant matnini yoz

JSON formatida javob ber:
{{
    "title": "Test nomi",
    "questions": [
        {{
            "question": "Savol matni?",
            "options": ["Birinchi variant", "Ikkinchi variant", "Uchinchi variant", "To'rtinchi variant"],
            "correct": 0,
            "explanation": "Tushuntirish"
        }}
    ]
}}"""
        
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
                    "Content-Type": "application/json"
                }
                data = {
                    "model": Config.OPENAI_MODEL,
                    "messages": [
                        {"role": "system", "content": "Sen professional o'qituvchisan. Test savollarini yaratishda mutaxassissan."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.7,
                    "max_tokens": 3000
                }
                
                async with session.post(Config.OPENAI_API_URL, headers=headers, json=data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        content = result['choices'][0]['message']['content']
                        # JSON ni parse qilish
                        import re
                        json_match = re.search(r'\{[\s\S]*\}', content)
                        if json_match:
                            quiz_data = json.loads(json_match.group())
                            return quiz_data
                    else:
                        logger.error(f"OpenAI API error: {resp.status}")
                        return None
        except Exception as e:
            logger.error(f"generate_quiz_with_ai error: {e}")
            return None
    
    # ========== SRS ALGORITMI (SuperMemo-2) ==========
    def calculate_srs_interval(quality: int, easiness: float, repetition: int, interval: int) -> tuple:
        """SRS interval hisoblash (SM-2 algoritmi)
        quality: 0-5 (0=noto'g'ri, 5=mukammal)
        Returns: (new_easiness, new_interval, new_repetition)
        """
        if quality < 3:
            # Noto'g'ri javob - qaytadan boshlash
            new_easiness = max(1.3, easiness - 0.2)
            new_interval = 1
            new_repetition = 0
        else:
            # To'g'ri javob
            new_easiness = easiness + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
            new_easiness = max(1.3, new_easiness)
            
            if repetition == 0:
                new_interval = 1
            elif repetition == 1:
                new_interval = 6
            else:
                new_interval = int(interval * new_easiness)
            
            new_repetition = repetition + 1
        
        return new_easiness, new_interval, new_repetition
    
    # ========== SERTIFIKAT GENERATOR (PIL) ==========
    async def generate_certificate_image(
        user_name: str,
        quiz_title: str,
        score: int,
        total: int,
        date_str: str,
        certificate_id: str
    ) -> Optional[BytesIO]:
        """Chiroyli sertifikat rasmi yaratish"""
        if not PIL_AVAILABLE:
            logger.warning("PIL mavjud emas, sertifikat yaratilmadi")
            return None
        
        try:
            # Sertifikat o'lchamlari (A4 landscape)
            width, height = 1200, 850
            
            # Gradient background yaratish
            img = Image.new('RGB', (width, height), color=(255, 255, 255))
            draw = ImageDraw.Draw(img)
            
            # Gradient effekt (yuqoridan pastga)
            for y in range(height):
                # Oltin-oq gradient
                r = int(255 - (y / height) * 30)
                g = int(250 - (y / height) * 40)
                b = int(240 - (y / height) * 60)
                draw.line([(0, y), (width, y)], fill=(r, g, b))
            
            # Ramka chizish (ikki qatlamli)
            # Tashqi ramka (qora)
            draw.rectangle([20, 20, width-20, height-20], outline=(50, 50, 50), width=3)
            # Ichki ramka (oltin)
            draw.rectangle([35, 35, width-35, height-35], outline=(218, 165, 32), width=2)
            # Dekorativ ramka
            draw.rectangle([50, 50, width-50, height-50], outline=(139, 69, 19), width=1)
            
            # Shriftlar (default shrift ishlatamiz)
            try:
                # Windows shriftlari
                title_font = ImageFont.truetype("arial.ttf", 48)
                subtitle_font = ImageFont.truetype("arial.ttf", 32)
                name_font = ImageFont.truetype("arial.ttf", 56)
                text_font = ImageFont.truetype("arial.ttf", 24)
                small_font = ImageFont.truetype("arial.ttf", 18)
            except:
                # Default shrift
                title_font = ImageFont.load_default()
                subtitle_font = ImageFont.load_default()
                name_font = ImageFont.load_default()
                text_font = ImageFont.load_default()
                small_font = ImageFont.load_default()
            
            # Sarlavha
            title = "SERTIFIKAT"
            title_bbox = draw.textbbox((0, 0), title, font=title_font)
            title_width = title_bbox[2] - title_bbox[0]
            draw.text(((width - title_width) // 2, 80), title, fill=(139, 69, 19), font=title_font)
            
            # Dekorativ chiziq
            line_y = 145
            draw.line([(150, line_y), (width-150, line_y)], fill=(218, 165, 32), width=2)
            
            # Subtitle
            subtitle = "BILIM VA MAHORAT UCHUN"
            sub_bbox = draw.textbbox((0, 0), subtitle, font=subtitle_font)
            sub_width = sub_bbox[2] - sub_bbox[0]
            draw.text(((width - sub_width) // 2, 165), subtitle, fill=(100, 100, 100), font=subtitle_font)
            
            # "Berildi" matni
            given_text = "Ushbu sertifikat quyidagi shaxsga berildi:"
            given_bbox = draw.textbbox((0, 0), given_text, font=text_font)
            given_width = given_bbox[2] - given_bbox[0]
            draw.text(((width - given_width) // 2, 230), given_text, fill=(80, 80, 80), font=text_font)
            
            # Foydalanuvchi ismi (katta va ajralib turuvchi)
            name_bbox = draw.textbbox((0, 0), user_name, font=name_font)
            name_width = name_bbox[2] - name_bbox[0]
            draw.text(((width - name_width) // 2, 280), user_name, fill=(0, 100, 0), font=name_font)
            
            # Chiziq
            draw.line([(200, 360), (width-200, 360)], fill=(218, 165, 32), width=1)
            
            # Test nomi
            quiz_text = f'"{quiz_title}" testi bo\'yicha'
            quiz_bbox = draw.textbbox((0, 0), quiz_text, font=subtitle_font)
            quiz_width = quiz_bbox[2] - quiz_bbox[0]
            draw.text(((width - quiz_width) // 2, 390), quiz_text, fill=(50, 50, 50), font=subtitle_font)
            
            # Natija
            percentage = int((score / total) * 100)
            result_text = f"Natija: {score}/{total} ({percentage}%)"
            result_bbox = draw.textbbox((0, 0), result_text, font=subtitle_font)
            result_width = result_bbox[2] - result_bbox[0]
            
            # Natija rangini aniqlash
            if percentage >= 90:
                result_color = (0, 128, 0)  # Yashil
                grade = "A'LO DARAJA"
            elif percentage >= 70:
                result_color = (0, 100, 200)  # Ko'k
                grade = "YAXSHI DARAJA"
            else:
                result_color = (200, 150, 0)  # Sariq
                grade = "QONIQARLI"
            
            draw.text(((width - result_width) // 2, 450), result_text, fill=result_color, font=subtitle_font)
            
            # Daraja
            grade_bbox = draw.textbbox((0, 0), grade, font=title_font)
            grade_width = grade_bbox[2] - grade_bbox[0]
            draw.text(((width - grade_width) // 2, 510), grade, fill=result_color, font=title_font)
            
            # Dekorativ yulduzlar (90%+ uchun)
            if percentage >= 90:
                star = "â˜…"
                for i, x in enumerate([width//2 - 100, width//2, width//2 + 100]):
                    draw.text((x - 15, 580), star, fill=(255, 215, 0), font=subtitle_font)
            
            # Sana
            date_text = f"Sana: {date_str}"
            date_bbox = draw.textbbox((0, 0), date_text, font=text_font)
            draw.text((100, height - 120), date_text, fill=(100, 100, 100), font=text_font)
            
            # Sertifikat ID
            id_text = f"ID: {certificate_id}"
            id_bbox = draw.textbbox((0, 0), id_text, font=small_font)
            id_width = id_bbox[2] - id_bbox[0]
            draw.text((width - 100 - id_width, height - 120), id_text, fill=(150, 150, 150), font=small_font)
            
            # Bot nomi
            bot_text = "NEXUS MEDIA - AI Quiz Maker"
            bot_bbox = draw.textbbox((0, 0), bot_text, font=text_font)
            bot_width = bot_bbox[2] - bot_bbox[0]
            draw.text(((width - bot_width) // 2, height - 80), bot_text, fill=(100, 100, 100), font=text_font)
            
            # Rasmni BytesIO ga saqlash
            img_bytes = BytesIO()
            img.save(img_bytes, format='PNG', quality=95)
            img_bytes.seek(0)
            
            return img_bytes
            
        except Exception as e:
            logger.error(f"Sertifikat yaratishda xatolik: {e}")
            return None
    
    # ========== AI TUTOR (XATO TUSHUNTIRISH) ==========
    async def explain_wrong_answer(question: str, user_answer: str, correct_answer: str, topic: str) -> str:
        """AI orqali noto'g'ri javobni tushuntirish"""
        if not Config.OPENAI_API_KEY:
            return "AI tushuntirish mavjud emas."
        
        prompt = f"""Foydalanuvchi quyidagi savolga noto'g'ri javob berdi. Unga tushuntirish ber:

SAVOL: {question}
FOYDALANUVCHI JAVOBI: {user_answer}
TO'G'RI JAVOB: {correct_answer}
MAVZU: {topic}

Quyidagilarni qil:
1. Nega foydalanuvchi javobi noto'g'ri ekanini tushuntir
2. To'g'ri javobni batafsil izohla
3. Bu mavzuni yaxshiroq tushunish uchun maslahat ber
4. Qisqa va tushunarli yoz (maksimum 200 so'z)

O'zbek tilida javob ber."""

        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
                    "Content-Type": "application/json"
                }
                data = {
                    "model": Config.OPENAI_MODEL,
                    "messages": [
                        {"role": "system", "content": "Sen professional o'qituvchisan. Talabaga xatosini tushuntirib, to'g'ri yo'lga yo'naltirasan."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.7,
                    "max_tokens": 500
                }
                
                async with session.post(Config.OPENAI_API_URL, headers=headers, json=data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result['choices'][0]['message']['content']
                    else:
                        return "Tushuntirish olishda xatolik yuz berdi."
        except Exception as e:
            logger.error(f"explain_wrong_answer error: {e}")
            return "Tushuntirish olishda xatolik yuz berdi."
    
    # ========== PODCAST MODE (TTS) ==========
    async def generate_podcast_dialog(topic: str, content: str = None) -> dict:
        """AI orqali podcast dialog yaratish (2 ta personaj)"""
        if not Config.OPENAI_API_KEY:
            return None
        
        prompt = f"""Quyidagi mavzu bo'yicha 2 ta personaj o'rtasida qiziqarli dialog yoz:

MAVZU: {topic}
{"KONTENT: " + content[:2000] if content else ""}

PERSONAJLAR:
1. USTOZ - Tajribali o'qituvchi, mavzuni yaxshi biladi
2. SHOGIRD - Qiziquvchan talaba, savollar beradi

QOIDALAR:
1. Dialog 5-7 ta almashuvdan iborat bo'lsin
2. Har bir javob 2-3 gapdan iborat bo'lsin
3. Mavzuni sodda va qiziqarli tushuntir
4. O'zbek tilida yoz
5. Oxirida xulosa bo'lsin

JSON formatida javob ber:
{{
    "title": "Podcast nomi",
    "dialogs": [
        {{"speaker": "USTOZ", "text": "..."}},
        {{"speaker": "SHOGIRD", "text": "..."}},
        ...
    ]
}}"""

        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
                    "Content-Type": "application/json"
                }
                data = {
                    "model": Config.OPENAI_MODEL,
                    "messages": [
                        {"role": "system", "content": "Sen professional podcast yozuvchisisan."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.8,
                    "max_tokens": 2000
                }
                
                async with session.post(Config.OPENAI_API_URL, headers=headers, json=data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        content = result['choices'][0]['message']['content']
                        json_match = re.search(r'\{[\s\S]*\}', content)
                        if json_match:
                            return json.loads(json_match.group())
                    return None
        except Exception as e:
            logger.error(f"generate_podcast_dialog error: {e}")
            return None
    
    async def text_to_speech(text: str, voice: str = "alloy") -> Optional[BytesIO]:
        """OpenAI TTS orqali matnni ovozga aylantirish"""
        if not Config.OPENAI_API_KEY:
            return None
        
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
                    "Content-Type": "application/json"
                }
                data = {
                    "model": "tts-1",
                    "input": text,
                    "voice": voice  # alloy, echo, fable, onyx, nova, shimmer
                }
                
                async with session.post("https://api.openai.com/v1/audio/speech", headers=headers, json=data) as resp:
                    if resp.status == 200:
                        audio_bytes = BytesIO(await resp.read())
                        audio_bytes.seek(0)
                        return audio_bytes
                    else:
                        logger.error(f"TTS error: {resp.status}")
                        return None
        except Exception as e:
            logger.error(f"text_to_speech error: {e}")
            return None
    
    # ========== ADAPTIVE LEARNING ==========
    def get_next_difficulty(current_difficulty: str, is_correct: bool, consecutive_correct: int, consecutive_wrong: int) -> str:
        """Moslashuvchan qiyinlik - keyingi savol qiyinligini aniqlash"""
        difficulties = ["easy", "medium", "hard"]
        current_idx = difficulties.index(current_difficulty) if current_difficulty in difficulties else 1
        
        if is_correct:
            # 2 ta ketma-ket to'g'ri javob - qiyinlashtirish
            if consecutive_correct >= 2 and current_idx < 2:
                return difficulties[current_idx + 1]
        else:
            # 2 ta ketma-ket noto'g'ri javob - osonlashtirish
            if consecutive_wrong >= 2 and current_idx > 0:
                return difficulties[current_idx - 1]
        
        return current_difficulty
    
    # ========== RPG TIZIMI ==========
    def calculate_rpg_level(xp: int) -> dict:
        """RPG darajasini hisoblash"""
        levels = [
            (0, "Novice", "ðŸŒ±"),
            (100, "Apprentice", "ðŸ“š"),
            (300, "Student", "ðŸŽ“"),
            (600, "Scholar", "ðŸ“–"),
            (1000, "Expert", "â­"),
            (1500, "Master", "ðŸ†"),
            (2500, "Grandmaster", "ðŸ‘‘"),
            (4000, "Legend", "ðŸŒŸ"),
            (6000, "Mythic", "ðŸ’Ž"),
            (10000, "Immortal", "ðŸ”¥")
        ]
        
        current_level = levels[0]
        next_level = levels[1] if len(levels) > 1 else None
        
        for i, (req_xp, name, icon) in enumerate(levels):
            if xp >= req_xp:
                current_level = (req_xp, name, icon)
                if i + 1 < len(levels):
                    next_level = levels[i + 1]
                else:
                    next_level = None
        
        level_num = levels.index(current_level) + 1
        
        return {
            "level": level_num,
            "name": current_level[1],
            "icon": current_level[2],
            "current_xp": xp,
            "level_xp": current_level[0],
            "next_level": next_level[1] if next_level else "MAX",
            "next_xp": next_level[0] if next_level else xp,
            "progress": ((xp - current_level[0]) / (next_level[0] - current_level[0]) * 100) if next_level else 100
        }
    
    def calculate_quiz_rewards(score: int, total: int, difficulty: str, streak: int) -> dict:
        """Quiz uchun XP va Oltin hisoblash"""
        percentage = (score / total) * 100 if total > 0 else 0
        
        # Bazaviy XP
        base_xp = score * 10
        
        # Qiyinlik bonusi
        diff_multiplier = {"easy": 1.0, "medium": 1.5, "hard": 2.0}
        xp = int(base_xp * diff_multiplier.get(difficulty, 1.0))
        
        # Streak bonusi (har 7 kunda +50%)
        streak_bonus = (streak // 7) * 0.5
        xp = int(xp * (1 + streak_bonus))
        
        # Mukammal natija bonusi
        if percentage == 100:
            xp = int(xp * 1.5)
        
        # Oltin (10 XP = 1 Oltin)
        gold = xp // 10
        
        # Bonus oltin (90%+ uchun)
        if percentage >= 90:
            gold += 5
        
        return {
            "xp": xp,
            "gold": gold,
            "streak_bonus": int(streak_bonus * 100),
            "perfect_bonus": percentage == 100
        }
    
    # ========== QUIZ MENU HANDLER ==========
    @router.message(F.text.in_(["ðŸ§  AI Quiz", "AI Quiz", "Quiz", "Test"]))
    async def handle_quiz_menu_message(message: Message):
        """AI Quiz asosiy menyu (message)"""
        user_id = message.from_user.id
        
        # Streak olish
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT current_streak FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            streak = row[0] if row else 0
        
        text = """
ðŸ§  <b>AI QUIZ MAKER</b>

<b>Xush kelibsiz!</b> Bu yerda siz:
â€¢ AI yordamida test yaratishingiz
â€¢ Bilimlaringizni sinashingiz
â€¢ Do'stlaringiz bilan bellashishingiz mumkin!

<b>ðŸ”¥ Streak tizimi:</b>
Har kuni test ishlang va streak'ingizni oshiring!
Streak bonus: Har 7 kunda +100 XP

<b>ðŸ† Reyting:</b>
Eng ko'p ball yig'gan foydalanuvchilar haftalik reytingda!

<b>ðŸ“š SRS (Interval takrorlash):</b>
Xato qilgan savollaringiz avtomatik takrorlanadi.

Quyidagi funksiyalardan birini tanlang:
        """
        
        await message.answer(text, reply_markup=Keyboards.quiz_menu(user_id, streak), parse_mode=ParseMode.HTML)
    
    @router.callback_query(F.data == "quiz_menu")
    async def handle_quiz_menu_callback(callback: CallbackQuery):
        """AI Quiz asosiy menyu (callback)"""
        user_id = callback.from_user.id
        
        # Streak olish
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT current_streak FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            streak = row[0] if row else 0
        
        text = """
ðŸ§  <b>AI QUIZ MAKER</b>

<b>Funksiyalar:</b>
â€¢ ðŸŽ¯ <b>Test yaratish</b> - AI mavzu bo'yicha test yaratadi
â€¢ ðŸ“„ <b>Fayldan test</b> - PDF/DOCX dan test
â€¢ ðŸŽ¬ <b>YouTube'dan</b> - Video asosida test
â€¢ âš”ï¸ <b>Duel</b> - Do'stlar bilan bellashuv
â€¢ ðŸ” <b>SRS</b> - Interval takrorlash
â€¢ ðŸŽ“ <b>Sertifikat</b> - 90%+ natijada

Tanlang:
        """
        
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_menu(user_id, streak))
        await callback.answer()
    
    # ========== TEST YARATISH ==========
    @router.callback_query(F.data == "quiz_ai_test")
    async def handle_ai_test_menu(callback: CallbackQuery):
        """AI Test yaratish menyusi - barcha usullar 1 joyda"""
        user_id = callback.from_user.id
        
        # Test yaratish limitlarini tekshirish
        limits = await get_user_quiz_creation_limits(user_id)
        
        if not limits["can_create"]:
            text = f"""
âŒ <b>TEST YARATISH LIMITI TUGADI!</b>

ðŸ“Š <b>Sizning holatiz:</b>
â€¢ Yaratilgan testlar: {limits['created_count']}/{limits['max_quizzes']}
â€¢ Tarif: {limits['tier']}

<b>ðŸ†“ Free foydalanuvchilar:</b>
â€¢ Faqat 2 ta test yaratishi mumkin
â€¢ Har bir testda maksimal 20 ta savol

<b>ðŸ’Ž Premium afzalliklari:</b>
â€¢ Cheksiz test yaratish
â€¢ Har bir testda 100 ta savolgacha
â€¢ Live Battle'da AI test

<b>ðŸ‘‘ Pro afzalliklari:</b>
â€¢ Hamma narsa cheksiz!

ðŸ’Ž Premium olish uchun /premium buyrug'ini yuboring!
            """
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸ’Ž Premium olish", callback_data="premium_menu")
            builder.button(text="ðŸ”™ Orqaga", callback_data="quiz_menu")
            builder.adjust(1)
            
            await safe_edit_text(callback, text, reply_markup=builder.as_markup())
            await callback.answer("âŒ Test yaratish limiti tugadi!", show_alert=True)
            return
        
        text = f"""
ðŸŽ¯ <b>AI TEST YARATISH</b>

ðŸ“Š <b>Sizning limitlaringiz ({limits['tier']}):</b>
â€¢ Testlar: {limits['created_count']}/{limits['max_quizzes'] if limits['max_quizzes'] < 999 else 'âˆž'}
â€¢ Har bir testda: max {limits['max_questions_per_quiz'] if limits['max_questions_per_quiz'] < 999 else 'âˆž'} savol

Test yaratish usulini tanlang:

<b>ðŸ“š Kategoriyadan</b> - Tayyor mavzulardan test
<b>âœï¸ Mavzudan</b> - O'z mavzuingizni kiriting
<b>ðŸ“„ Fayldan</b> - PDF/DOCX fayldan test
<b>ðŸŽ§ Podcast</b> - Audio formatda o'rganish
<b>ðŸ“ˆ Adaptive</b> - Moslashuvchan qiyinlik
        """
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“š Kategoriyadan test", callback_data="quiz_create")
        builder.button(text="âœï¸ Mavzudan test", callback_data="quiz_from_topic")
        builder.button(text="ðŸ“„ Fayldan test (PDF/DOCX)", callback_data="quiz_from_file")
        builder.button(text="ðŸŽ§ Podcast Mode", callback_data="quiz_podcast")
        builder.button(text="ðŸ“ˆ Adaptive Test", callback_data="quiz_adaptive")
        builder.button(text="ðŸ”™ Orqaga", callback_data="quiz_menu")
        builder.adjust(1, 2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "quiz_create")
    async def handle_quiz_create(callback: CallbackQuery):
        """Test yaratish - kategoriya tanlash"""
        text = """
ðŸŽ¯ <b>YANGI TEST YARATISH</b>

Kategoriyani tanlang:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_categories_menu())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("qcat_"))
    async def handle_quiz_category(callback: CallbackQuery, state: FSMContext):
        """Kategoriya tanlangandan keyin test yaratish"""
        category = callback.data.replace("qcat_", "")
        
        category_names = {
            "adabiyot": "Adabiyot",
            "fan": "Fan va Texnologiya",
            "tarix": "Tarix",
            "biznes": "Biznes va Moliya",
            "psixologiya": "Psixologiya",
            "dasturlash": "Dasturlash",
            "english": "Ingliz tili",
            "umumiy": "Umumiy bilim",
            "kino": "Kino va San'at",
            "sport": "Sport"
        }
        
        topic = category_names.get(category, "Umumiy bilim")
        await state.update_data(quiz_topic=topic)
        
        text = f"""
ðŸ“š <b>Kategoriya:</b> {topic}

Qiyinlik darajasini tanlang:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_difficulty_menu())
        await state.set_state(UserStates.waiting_quiz_difficulty)
        await callback.answer()
    
    @router.callback_query(F.data == "quiz_from_topic")
    async def handle_quiz_from_topic(callback: CallbackQuery, state: FSMContext):
        """Mavzudan test yaratish"""
        text = """
ðŸ“š <b>MAVZUDAN TEST</b>

Test mavzusini kiriting:
<i>Masalan: "O'zbekiston tarixi", "Python dasturlash", "Ingliz tili grammatikasi"</i>
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_menu"))
        await state.set_state(UserStates.waiting_quiz_topic)
        await callback.answer()
    
    @router.callback_query(F.data == "quiz_from_file")
    async def handle_quiz_from_file(callback: CallbackQuery, state: FSMContext):
        """Fayldan test yaratish"""
        text = """
ðŸ“„ <b>FAYLDAN TEST</b>

PDF yoki DOCX fayl yuboring.
AI fayl mazmunidan savollar yaratadi.

<b>Qo'llab-quvvatlanadigan formatlar:</b>
â€¢ PDF (.pdf)
â€¢ Word (.docx)
â€¢ Matn (.txt)

<b>Maslahat:</b> Fayl 10 MB dan kichik bo'lishi kerak.
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_menu"))
        await state.set_state(UserStates.waiting_quiz_file)
        await callback.answer()
    
    @router.message(UserStates.waiting_quiz_file, F.document)
    async def handle_quiz_file_upload(message: Message, state: FSMContext):
        """Fayl yuklangandan keyin test yaratish"""
        document = message.document
        
        # Fayl turini tekshirish
        allowed_types = ['.pdf', '.docx', '.txt']
        file_ext = None
        for ext in allowed_types:
            if document.file_name.lower().endswith(ext):
                file_ext = ext
                break
        
        if not file_ext:
            await message.answer("âŒ Faqat PDF, DOCX yoki TXT fayllar qabul qilinadi!")
            return
        
        # Fayl hajmini tekshirish (10 MB)
        if document.file_size > 10 * 1024 * 1024:
            await message.answer("âŒ Fayl juda katta! Maksimum 10 MB.")
            return
        
        await message.answer("â³ Fayl yuklanmoqda va tahlil qilinmoqda...")
        
        try:
            # Faylni yuklab olish
            file = await message.bot.get_file(document.file_id)
            file_bytes = await message.bot.download_file(file.file_path)
            
            # Fayl mazmunini o'qish
            content = ""
            if file_ext == '.txt':
                content = file_bytes.read().decode('utf-8', errors='ignore')
            elif file_ext == '.pdf':
                try:
                    import PyPDF2
                    import io
                    pdf_reader = PyPDF2.PdfReader(io.BytesIO(file_bytes.read()))
                    for page in pdf_reader.pages:
                        content += page.extract_text() + "\n"
                except ImportError:
                    await message.answer("âŒ PDF o'qish uchun PyPDF2 kutubxonasi kerak: pip install PyPDF2")
                    await state.clear()
                    return
            elif file_ext == '.docx':
                try:
                    import docx
                    import io
                    doc = docx.Document(io.BytesIO(file_bytes.read()))
                    for para in doc.paragraphs:
                        content += para.text + "\n"
                except ImportError:
                    await message.answer("âŒ DOCX o'qish uchun python-docx kutubxonasi kerak: pip install python-docx")
                    await state.clear()
                    return
            
            if len(content) < 100:
                await message.answer("âŒ Fayl mazmuni juda qisqa. Kamida 100 ta belgi kerak.")
                await state.clear()
                return
            
            # Mazmunni qisqartirish (maksimum 4000 belgi)
            if len(content) > 4000:
                content = content[:4000]
            
            await state.update_data(quiz_topic=f"Fayl: {document.file_name}", file_content=content)
            
            text = f"""
ðŸ“„ <b>Fayl yuklandi!</b>

<b>Fayl:</b> {document.file_name}
<b>Mazmun:</b> {len(content)} belgi

Qiyinlik darajasini tanlang:
            """
            await message.answer(text, reply_markup=Keyboards.quiz_difficulty_menu(), parse_mode=ParseMode.HTML)
            await state.set_state(UserStates.waiting_quiz_difficulty)
            
        except Exception as e:
            logger.error(f"Fayl yuklashda xatolik: {e}")
            await message.answer("âŒ Faylni o'qishda xatolik yuz berdi.")
            await state.clear()
    
    @router.callback_query(F.data == "podcast_file")
    async def handle_podcast_file(callback: CallbackQuery, state: FSMContext):
        """Fayldan podcast yaratish"""
        text = """
ðŸ“„ <b>FAYLDAN PODCAST</b>

PDF yoki DOCX fayl yuboring.
AI fayl mazmunidan podcast dialog yaratadi.

<b>Qo'llab-quvvatlanadigan formatlar:</b>
â€¢ PDF (.pdf)
â€¢ Word (.docx)
â€¢ Matn (.txt)
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_podcast"))
        await state.set_state(UserStates.waiting_quiz_file)
        await state.update_data(file_mode="podcast")
        await callback.answer()
    
    @router.message(UserStates.waiting_quiz_topic)
    async def handle_quiz_topic_input(message: Message, state: FSMContext):
        """Mavzu kiritilgandan keyin"""
        topic = message.text.strip()
        if len(topic) < 3:
            await message.answer("âŒ Mavzu juda qisqa. Kamida 3 ta belgi kiriting.")
            return
        
        await state.update_data(quiz_topic=topic)
        
        text = f"""
ðŸ“š <b>Mavzu:</b> {topic}

Qiyinlik darajasini tanlang:
        """
        await message.answer(text, reply_markup=Keyboards.quiz_difficulty_menu(), parse_mode=ParseMode.HTML)
        await state.set_state(UserStates.waiting_quiz_difficulty)
    
    @router.callback_query(F.data.startswith("quiz_diff_"))
    async def handle_quiz_difficulty(callback: CallbackQuery, state: FSMContext):
        """Qiyinlik tanlangandan keyin"""
        difficulty = callback.data.replace("quiz_diff_", "")
        await state.update_data(quiz_difficulty=difficulty)
        
        diff_names = {"easy": "ðŸŸ¢ Oson", "medium": "ðŸŸ¡ O'rta", "hard": "ðŸ”´ Qiyin"}
        
        text = f"""
<b>Qiyinlik:</b> {diff_names.get(difficulty, "O'rta")}

Savollar sonini tanlang:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_count_menu())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("quiz_count_"))
    async def handle_quiz_count(callback: CallbackQuery, state: FSMContext):
        """Savollar soni tanlangandan keyin - test yaratish"""
        count = int(callback.data.replace("quiz_count_", ""))
        user_id = callback.from_user.id
        data = await state.get_data()
        topic = data.get('quiz_topic', 'Umumiy')
        difficulty = data.get('quiz_difficulty', 'medium')
        
        # Limitlarni tekshirish
        limits = await get_user_quiz_creation_limits(user_id)
        
        if not limits["can_create"]:
            await callback.answer("âŒ Test yaratish limiti tugadi! Premium oling.", show_alert=True)
            await state.clear()
            return
        
        # Maksimal savol sonini cheklash
        max_q = limits["max_questions_per_quiz"]
        if count > max_q:
            count = max_q
            await callback.answer(f"âš ï¸ {limits['tier']} tarifda max {max_q} savol!", show_alert=True)
        
        await callback.answer("â³ Test yaratilmoqda...")
        
        # Loading xabari
        loading_msg = await callback.message.edit_text(
            f"ðŸ¤– <b>AI test yaratmoqda...</b>\n\n"
            f"ðŸ“š Mavzu: {topic}\n"
            f"ðŸ“Š Savollar: {count} ta\n\n"
            f"â³ Iltimos, kuting...",
            parse_mode=ParseMode.HTML
        )
        
        # AI orqali test yaratish
        quiz_data = await generate_quiz_with_ai(topic, difficulty, count)
        
        if not quiz_data or 'questions' not in quiz_data:
            await loading_msg.edit_text(
                "âŒ <b>Test yaratishda xatolik!</b>\n\n"
                "AI hozirda band. Keyinroq urinib ko'ring.",
                reply_markup=Keyboards.back_button("quiz_menu"),
                parse_mode=ParseMode.HTML
            )
            await state.clear()
            return
        
        # Testni database'ga saqlash
        user_id = callback.from_user.id
        async with db.connect() as conn:
            cursor = await conn.execute('''
                INSERT INTO quizzes (user_id, title, description, category, difficulty, questions_json, total_questions)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, quiz_data.get('title', topic), f"AI tomonidan yaratilgan test: {topic}", 
                  "Umumiy", difficulty, json.dumps(quiz_data['questions']), len(quiz_data['questions'])))
            quiz_id = cursor.lastrowid
            await conn.commit()
        
        # State'ga saqlash
        await state.update_data(
            current_quiz_id=quiz_id,
            current_questions=quiz_data['questions'],
            current_question_index=0,
            correct_count=0,
            wrong_count=0,
            answers=[],
            start_time=time.time()
        )
        
        # Birinchi savolni ko'rsatish
        question = quiz_data['questions'][0]
        text = f"""
ðŸ§  <b>TEST BOSHLANDI!</b>

<b>Mavzu:</b> {topic}
<b>Savollar:</b> {len(quiz_data['questions'])} ta

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Savol 1/{len(quiz_data['questions'])}</b>

{question['question']}
        """
        
        await loading_msg.edit_text(
            text,
            reply_markup=Keyboards.quiz_answer_keyboard(question['options'], 0),
            parse_mode=ParseMode.HTML
        )
    
    # ========== JAVOB BERISH ==========
    @router.callback_query(F.data.startswith("quiz_ans_"))
    async def handle_quiz_answer(callback: CallbackQuery, state: FSMContext):
        """Test javobini qabul qilish"""
        parts = callback.data.split("_")
        question_index = int(parts[2])
        answer_index = int(parts[3])
        
        data = await state.get_data()
        questions = data.get('current_questions', [])
        quiz_id = data.get('current_quiz_id')
        correct_count = data.get('correct_count', 0)
        wrong_count = data.get('wrong_count', 0)
        answers = data.get('answers', [])
        
        if question_index >= len(questions):
            await callback.answer("âŒ Savol topilmadi!")
            return
        
        question = questions[question_index]
        correct_answer = question.get('correct', 0)
        is_correct = answer_index == correct_answer
        
        # Javobni saqlash
        answers.append({
            'question_index': question_index,
            'user_answer': answer_index,
            'correct_answer': correct_answer,
            'is_correct': is_correct
        })
        
        if is_correct:
            correct_count += 1
            result_text = "âœ… <b>To'g'ri!</b>"
        else:
            wrong_count += 1
            result_text = f"âŒ <b>Noto'g'ri!</b>\n\nTo'g'ri javob: <b>{question['options'][correct_answer]}</b>"
            
            # Xatoni database'ga saqlash (SRS uchun)
            user_id = callback.from_user.id
            async with db.connect() as conn:
                await conn.execute('''
                    INSERT OR REPLACE INTO quiz_mistakes 
                    (user_id, quiz_id, question_index, question_text, correct_answer, user_answer, mistake_count, last_mistake_at)
                    VALUES (?, ?, ?, ?, ?, ?, 
                            COALESCE((SELECT mistake_count FROM quiz_mistakes WHERE user_id = ? AND quiz_id = ? AND question_index = ?), 0) + 1,
                            datetime('now'))
                ''', (user_id, quiz_id, question_index, question['question'], 
                      question['options'][correct_answer], question['options'][answer_index],
                      user_id, quiz_id, question_index))
                await conn.commit()
        
        # Tushuntirish (agar mavjud bo'lsa)
        if 'explanation' in question:
            result_text += f"\n\nðŸ’¡ <b>Tushuntirish:</b> {question['explanation']}"
        
        await state.update_data(correct_count=correct_count, wrong_count=wrong_count, answers=answers)
        
        # Keyingi savol yoki natija
        next_index = question_index + 1
        if next_index < len(questions):
            # Keyingi savol
            next_question = questions[next_index]
            text = f"""
{result_text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Savol {next_index + 1}/{len(questions)}</b>

{next_question['question']}
            """
            await callback.message.edit_text(
                text,
                reply_markup=Keyboards.quiz_answer_keyboard(next_question['options'], next_index),
                parse_mode=ParseMode.HTML
            )
        else:
            # Test tugadi - natijani ko'rsatish
            await show_quiz_result(callback, state, quiz_id, questions, correct_count, wrong_count, answers)
        
        await callback.answer("âœ… To'g'ri!" if is_correct else "âŒ Noto'g'ri!")
    
    async def show_quiz_result(callback: CallbackQuery, state: FSMContext, quiz_id: int, questions: list, correct: int, wrong: int, answers: list):
        """Test natijasini ko'rsatish"""
        user_id = callback.from_user.id
        total = len(questions)
        score = int((correct / total) * 100) if total > 0 else 0
        
        # Vaqtni hisoblash
        data = await state.get_data()
        start_time = data.get('start_time', time.time())
        time_spent = int(time.time() - start_time)
        minutes = time_spent // 60
        seconds = time_spent % 60
        
        # XP hisoblash
        base_xp = correct * 10  # Har bir to'g'ri javob uchun 10 XP
        bonus_xp = 0
        
        if score >= 90:
            bonus_xp = 100  # 90%+ uchun bonus
            grade = "ðŸ† A+ (Ajoyib!)"
        elif score >= 80:
            bonus_xp = 50
            grade = "ðŸ¥‡ A (Yaxshi!)"
        elif score >= 70:
            bonus_xp = 25
            grade = "ðŸ¥ˆ B (O'rtacha)"
        elif score >= 60:
            grade = "ðŸ¥‰ C (Qoniqarli)"
        else:
            grade = "ðŸ“š D (Ko'proq o'rganing)"
        
        total_xp = base_xp + bonus_xp
        
        # Database'ga saqlash
        async with db.connect() as conn:
            # Attempt saqlash
            await conn.execute('''
                INSERT INTO quiz_attempts (user_id, quiz_id, score, total_questions, correct_answers, wrong_answers, answers_json, time_spent, xp_earned, completed)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 1)
            ''', (user_id, quiz_id, score, total, correct, wrong, json.dumps(answers), time_spent, total_xp))
            
            # XP qo'shish
            await conn.execute('UPDATE users SET xp = xp + ? WHERE user_id = ?', (total_xp, user_id))
            
            # Streak yangilash
            today = datetime.now().strftime('%Y-%m-%d')
            cursor = await conn.execute('SELECT last_quiz_date, current_streak, longest_streak FROM quiz_streaks WHERE user_id = ?', (user_id,))
            streak_row = await cursor.fetchone()
            
            if streak_row:
                last_date = streak_row[0]
                current_streak = streak_row[1] or 0
                longest_streak = streak_row[2] or 0
                
                if last_date == today:
                    # Bugun allaqachon test ishlagan
                    pass
                elif last_date == (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d'):
                    # Kecha ishlagan - streak davom etadi
                    current_streak += 1
                    longest_streak = max(longest_streak, current_streak)
                else:
                    # Streak uzilgan
                    current_streak = 1
                
                await conn.execute('''
                    UPDATE quiz_streaks 
                    SET current_streak = ?, longest_streak = ?, last_quiz_date = ?, total_quizzes_taken = total_quizzes_taken + 1, total_correct_answers = total_correct_answers + ?
                    WHERE user_id = ?
                ''', (current_streak, longest_streak, today, correct, user_id))
            else:
                await conn.execute('''
                    INSERT INTO quiz_streaks (user_id, current_streak, longest_streak, last_quiz_date, total_quizzes_taken, total_correct_answers)
                    VALUES (?, 1, 1, ?, 1, ?)
                ''', (user_id, today, correct))
            
            # Quiz statistikasini yangilash
            await conn.execute('''
                UPDATE quizzes SET plays_count = plays_count + 1, avg_score = (avg_score * plays_count + ?) / (plays_count + 1) WHERE id = ?
            ''', (score, quiz_id))
            
            await conn.commit()
        
        # Daily challenge progress tracking
        challenge_result = await db.track_daily_challenge_progress(user_id, 'quiz')
        challenge_msg = ""
        if challenge_result.get('completed'):
            challenge_msg = f"\n\nðŸŽ¯ <b>KUNLIK CHALLENGE BAJARILDI!</b>\n+{challenge_result['xp_reward']} XP, +{challenge_result['gold_reward']} Gold"
        
        text = f"""
ðŸŽ‰ <b>TEST TUGADI!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š <b>NATIJA:</b> {score}%
{grade}{challenge_msg}

âœ… To'g'ri: {correct}/{total}
âŒ Noto'g'ri: {wrong}/{total}
â± Vaqt: {minutes}:{seconds:02d}

ðŸ’° <b>XP:</b> +{total_xp} XP
  â€¢ Asosiy: {base_xp} XP
  â€¢ Bonus: {bonus_xp} XP
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{"ðŸŽ“ Sertifikat olish uchun 90%+ ball kerak!" if score < 90 else "ðŸŽ“ Tabriklaymiz! Sertifikat olishingiz mumkin!"}
        """
        
        await callback.message.edit_text(
            text,
            reply_markup=Keyboards.quiz_result_keyboard(quiz_id, score),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    
    @router.callback_query(F.data.startswith("quiz_skip_"))
    async def handle_quiz_skip(callback: CallbackQuery, state: FSMContext):
        """Savolni o'tkazib yuborish"""
        question_index = int(callback.data.replace("quiz_skip_", ""))
        
        data = await state.get_data()
        questions = data.get('current_questions', [])
        answers = data.get('answers', [])
        quiz_id = data.get('current_quiz_id', 0)
        correct_count = data.get('correct_count', 0)
        wrong_count = data.get('wrong_count', 0)
        
        # O'tkazib yuborilgan deb belgilash
        answers.append({
            'question_index': question_index,
            'user_answer': -1,
            'correct_answer': questions[question_index].get('correct', 0) if question_index < len(questions) else 0,
            'is_correct': False,
            'skipped': True
        })
        wrong_count += 1
        
        await state.update_data(answers=answers, wrong_count=wrong_count)
        
        # Keyingi savolga o'tish
        next_index = question_index + 1
        
        if next_index >= len(questions):
            # Test tugadi
            await show_quiz_result(callback, state, quiz_id, questions, correct_count, wrong_count, answers)
        else:
            question = questions[next_index]
            text = f"""
ðŸ§  <b>TEST DAVOM ETMOQDA</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Savol {next_index + 1}/{len(questions)}</b>

{question['question']}
            """
            await callback.message.edit_text(
                text,
                reply_markup=Keyboards.quiz_answer_keyboard(question['options'], next_index),
                parse_mode=ParseMode.HTML
            )
        
        await callback.answer("â­ï¸ Savol o'tkazib yuborildi")
    
    @router.callback_query(F.data == "quiz_end")
    async def handle_quiz_end(callback: CallbackQuery, state: FSMContext):
        """Testni tugatish"""
        data = await state.get_data()
        
        if not data.get('current_questions'):
            await callback.answer("âŒ Faol test yo'q!")
            return
        
        questions = data.get('current_questions', [])
        quiz_id = data.get('current_quiz_id', 0)
        correct_count = data.get('correct_count', 0)
        wrong_count = data.get('wrong_count', 0)
        answers = data.get('answers', [])
        
        # Natijani ko'rsatish
        await show_quiz_result(callback, state, quiz_id, questions, correct_count, wrong_count, answers)
        await callback.answer("Test tugatildi!")
    
    @router.callback_query(F.data.startswith("quiz_review_"))
    async def handle_quiz_review(callback: CallbackQuery):
        """Test xatolarini ko'rish"""
        quiz_id = int(callback.data.replace("quiz_review_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT question_text, correct_answer, user_answer
                FROM quiz_mistakes
                WHERE user_id = ? AND quiz_id = ?
                ORDER BY id DESC LIMIT 10
            ''', (user_id, quiz_id))
            mistakes = await cursor.fetchall()
        
        if not mistakes:
            text = "âœ… <b>Ajoyib!</b>\n\nBu testda xato qilmadingiz!"
        else:
            text = f"âŒ <b>XATOLAR ({len(mistakes)} ta)</b>\n\n"
            for i, (question, correct, user_ans) in enumerate(mistakes, 1):
                text += f"<b>{i}. {question[:80]}...</b>\n"
                text += f"   âŒ Sizning: {user_ans[:40]}\n"
                text += f"   âœ… To'g'ri: {correct[:40]}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ” Qayta ishlash", callback_data=f"quiz_retry_{quiz_id}")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("quiz_retry_"))
    async def handle_quiz_retry(callback: CallbackQuery, state: FSMContext):
        """Testni qayta ishlash"""
        quiz_id = int(callback.data.replace("quiz_retry_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT title, questions_json FROM quizzes WHERE id = ?', (quiz_id,))
            row = await cursor.fetchone()
        
        if not row:
            await callback.answer("âŒ Test topilmadi!")
            return
        
        title, questions_json = row
        questions = json.loads(questions_json) if questions_json else []
        
        if not questions:
            await callback.answer("âŒ Savollar topilmadi!")
            return
        
        # State'ga saqlash
        await state.update_data(
            current_quiz_id=quiz_id,
            current_questions=questions,
            current_question_index=0,
            correct_count=0,
            wrong_count=0,
            answers=[],
            start_time=time.time()
        )
        
        # Birinchi savolni ko'rsatish
        question = questions[0]
        text = f"""
ðŸ§  <b>TEST QAYTA BOSHLANDI!</b>

<b>Test:</b> {title}
<b>Savollar:</b> {len(questions)} ta

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Savol 1/{len(questions)}</b>

{question['question']}
        """
        
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_answer_keyboard(question['options'], 0))
        await callback.answer("ðŸ” Test qayta boshlandi!")
    
    @router.callback_query(F.data.startswith("quiz_share_"))
    async def handle_quiz_share(callback: CallbackQuery):
        """Test natijasini baham ko'rish"""
        quiz_id = int(callback.data.replace("quiz_share_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT q.title, qa.score, qa.correct_answers, qa.total_questions
                FROM quiz_attempts qa
                JOIN quizzes q ON qa.quiz_id = q.id
                WHERE qa.user_id = ? AND qa.quiz_id = ?
                ORDER BY qa.completed_at DESC LIMIT 1
            ''', (user_id, quiz_id))
            row = await cursor.fetchone()
        
        if not row:
            await callback.answer("âŒ Natija topilmadi!")
            return
        
        title, score, correct, total = row
        
        bot_info = await callback.bot.get_me()
        bot_username = bot_info.username
        
        share_text = f"""
ðŸ§  <b>AI QUIZ NATIJAM</b>

ðŸ“ <b>Test:</b> {title}
ðŸ† <b>Ball:</b> {score}%
âœ… <b>To'g'ri:</b> {correct}/{total}

Siz ham sinab ko'ring: @{bot_username}
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¤ Do'stlarga yuborish", switch_inline_query=f"Quiz natijam: {score}%")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, share_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== XATOLARIM (MISTAKES BANK) ==========
    @router.callback_query(F.data == "quiz_mistakes")
    async def handle_quiz_mistakes(callback: CallbackQuery):
        """Xatolar banki"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT qm.question_text, qm.correct_answer, qm.user_answer, qm.mistake_count, q.title
                FROM quiz_mistakes qm
                JOIN quizzes q ON qm.quiz_id = q.id
                WHERE qm.user_id = ? AND qm.is_resolved = 0
                ORDER BY qm.mistake_count DESC
                LIMIT 10
            ''', (user_id,))
            mistakes = await cursor.fetchall()
        
        if not mistakes:
            text = """
âŒ <b>XATOLARIM</b>

âœ… Ajoyib! Hozircha xatolar yo'q.

Test ishlang va xato qilgan savollaringiz bu yerda ko'rinadi.
            """
        else:
            text = f"âŒ <b>XATOLARIM</b>\n\n<b>Jami:</b> {len(mistakes)} ta xato\n\n"
            for i, (question, correct, user_ans, count, title) in enumerate(mistakes[:5], 1):
                text += f"<b>{i}. {question[:100]}...</b>\n"
                text += f"   âŒ Sizning javob: {user_ans[:50]}\n"
                text += f"   âœ… To'g'ri javob: {correct[:50]}\n"
                text += f"   ðŸ”„ Xato soni: {count}\n\n"
        
        builder = InlineKeyboardBuilder()
        if mistakes:
            builder.button(text="ðŸ” Xatolardan test", callback_data="quiz_from_mistakes")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== XATOLARDAN TEST ==========
    @router.callback_query(F.data == "quiz_from_mistakes")
    async def handle_quiz_from_mistakes(callback: CallbackQuery, state: FSMContext):
        """Xato qilgan savollardan test yaratish"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT qm.question_text, qm.correct_answer, qm.user_answer, q.title
                FROM quiz_mistakes qm
                JOIN quizzes q ON qm.quiz_id = q.id
                WHERE qm.user_id = ? AND qm.is_resolved = 0
                ORDER BY qm.mistake_count DESC
                LIMIT 5
            ''', (user_id,))
            mistakes = await cursor.fetchall()
        
        if not mistakes:
            await callback.answer("âŒ Xatolar topilmadi!")
            return
        
        # Xatolardan savollar yaratish
        questions = []
        for question_text, correct, user_ans, title in mistakes:
            questions.append({
                'question': question_text,
                'options': [correct, user_ans, f"Boshqa variant 1", f"Boshqa variant 2"],
                'correct': 0,
                'explanation': f"Bu savol '{title}' testidan"
            })
            # Variantlarni aralashtirish
            import random
            correct_ans = questions[-1]['options'][0]
            random.shuffle(questions[-1]['options'])
            questions[-1]['correct'] = questions[-1]['options'].index(correct_ans)
        
        await state.update_data(
            current_questions=questions,
            current_question_index=0,
            correct_count=0,
            wrong_count=0,
            answers=[],
            start_time=time.time()
        )
        
        question = questions[0]
        text = f"""
ðŸ” <b>XATOLARDAN TEST</b>

<b>Savollar:</b> {len(questions)} ta

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Savol 1/{len(questions)}</b>

{question['question']}
        """
        
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_answer_keyboard(question['options'], 0))
        await callback.answer()
    
    # ========== FLASHCARDS ==========
    @router.callback_query(F.data == "quiz_flashcards")
    async def handle_quiz_flashcards(callback: CallbackQuery):
        """Flashcards - xato qilgan savollardan flashcard"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM quiz_flashcards WHERE user_id = ?
            ''', (user_id,))
            total_cards = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM quiz_flashcards WHERE user_id = ? AND is_learned = 1
            ''', (user_id,))
            learned_cards = (await cursor.fetchone())[0] or 0
        
        text = f"""
ðŸ“‡ <b>FLASHCARDS</b>

<b>Jami kartalar:</b> {total_cards} ta
<b>O'rganilgan:</b> {learned_cards} ta
<b>Qolgan:</b> {total_cards - learned_cards} ta

<b>Flashcard nima?</b>
Xato qilgan savollaringiz avtomatik flashcard'ga aylanadi.
Ularni takrorlash orqali yaxshiroq eslab qolasiz!

<b>Qanday ishlaydi:</b>
â€¢ Savol ko'rsatiladi
â€¢ "Javobni ko'rish" bosing
â€¢ "Bildim" yoki "Bilmadim" tanlang
â€¢ Bilmagan kartalar qayta ko'rsatiladi
        """
        
        builder = InlineKeyboardBuilder()
        if total_cards > learned_cards:
            builder.button(text=f"ðŸ“– O'rganishni boshlash ({total_cards - learned_cards})", callback_data="flashcard_start")
        builder.button(text="ðŸ”„ Hammasini qayta o'rganish", callback_data="flashcard_reset")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "flashcard_start")
    async def handle_flashcard_start(callback: CallbackQuery, state: FSMContext):
        """Flashcard o'rganishni boshlash"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT id, front_text, back_text FROM quiz_flashcards 
                WHERE user_id = ? AND is_learned = 0
                ORDER BY RANDOM() LIMIT 1
            ''', (user_id,))
            card = await cursor.fetchone()
        
        if not card:
            await callback.answer("âœ… Barcha kartalar o'rganilgan!")
            return
        
        card_id, front, back = card
        await state.update_data(current_flashcard_id=card_id, flashcard_back=back)
        
        text = f"""
ðŸ“‡ <b>FLASHCARD</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>SAVOL:</b>

{front}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Javobni o'ylab ko'ring, so'ng "Javobni ko'rish" bosing.
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‘ Javobni ko'rish", callback_data=f"flashcard_show_{card_id}")
        builder.button(text="ðŸ”™ Flashcards", callback_data="quiz_flashcards")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("flashcard_show_"))
    async def handle_flashcard_show(callback: CallbackQuery, state: FSMContext):
        """Flashcard javobini ko'rsatish"""
        card_id = int(callback.data.replace("flashcard_show_", ""))
        data = await state.get_data()
        back = data.get('flashcard_back', '')
        
        text = f"""
ðŸ“‡ <b>FLASHCARD - JAVOB</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>JAVOB:</b>

{back}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Bu javobni bildingizmi?
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Bildim", callback_data=f"flashcard_knew_{card_id}")
        builder.button(text="âŒ Bilmadim", callback_data=f"flashcard_didnt_{card_id}")
        builder.adjust(2)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("flashcard_knew_"))
    async def handle_flashcard_knew(callback: CallbackQuery, state: FSMContext):
        """Flashcard - bildim"""
        card_id = int(callback.data.replace("flashcard_knew_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            await conn.execute('UPDATE quiz_flashcards SET is_learned = 1 WHERE id = ? AND user_id = ?', (card_id, user_id))
            await conn.commit()
        
        await callback.answer("âœ… Ajoyib! Keyingi karta...")
        await handle_flashcard_start(callback, state)
    
    @router.callback_query(F.data.startswith("flashcard_didnt_"))
    async def handle_flashcard_didnt(callback: CallbackQuery, state: FSMContext):
        """Flashcard - bilmadim"""
        await callback.answer("ðŸ“š Keyingi safar eslab qolasiz!")
        await handle_flashcard_start(callback, state)
    
    @router.callback_query(F.data == "flashcard_reset")
    async def handle_flashcard_reset(callback: CallbackQuery):
        """Barcha flashcard'larni qayta o'rganish"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            await conn.execute('UPDATE quiz_flashcards SET is_learned = 0 WHERE user_id = ?', (user_id,))
            await conn.commit()
        
        await callback.answer("ðŸ”„ Barcha kartalar qayta o'rganish uchun tayyor!")
        await handle_quiz_flashcards(callback)
    
    # ========== SRS TAKRORLASH ==========
    @router.callback_query(F.data == "quiz_srs_review")
    async def handle_quiz_srs_review(callback: CallbackQuery):
        """SRS takrorlash - bugun takrorlanishi kerak savollar"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM quiz_srs 
                WHERE user_id = ? AND datetime(next_review_at) <= datetime('now') AND is_mastered = 0
            ''', (user_id,))
            due_count = (await cursor.fetchone())[0] or 0
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM quiz_srs WHERE user_id = ? AND is_mastered = 1
            ''', (user_id,))
            mastered_count = (await cursor.fetchone())[0] or 0
        
        text = f"""
ðŸ” <b>INTERVAL TAKRORLASH (SRS)</b>

<b>Bugun takrorlash kerak:</b> {due_count} ta savol
<b>O'zlashtirilgan:</b> {mastered_count} ta savol

<b>SRS qanday ishlaydi?</b>
â€¢ Xato qilgan savollaringiz avtomatik SRS ga qo'shiladi
â€¢ Har safar to'g'ri javob bersangiz, interval oshadi
â€¢ Xato qilsangiz, interval qaytadan boshlanadi
â€¢ Maqsad: Barcha savollarni "o'zlashtirilgan" holatiga o'tkazish

{"â° Hozir takrorlash uchun savollar bor!" if due_count > 0 else "âœ… Hozircha takrorlash kerak emas."}
        """
        
        builder = InlineKeyboardBuilder()
        if due_count > 0:
            builder.button(text=f"ðŸ” Takrorlashni boshlash ({due_count})", callback_data="srs_start_review")
        builder.button(text="ðŸ“Š SRS statistika", callback_data="srs_stats")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "srs_start_review")
    async def handle_srs_start_review(callback: CallbackQuery, state: FSMContext):
        """SRS takrorlashni boshlash"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT id, question_text, correct_answer, easiness, interval, repetition
                FROM quiz_srs 
                WHERE user_id = ? AND datetime(next_review_at) <= datetime('now') AND is_mastered = 0
                ORDER BY next_review_at ASC
                LIMIT 1
            ''', (user_id,))
            card = await cursor.fetchone()
        
        if not card:
            await callback.answer("âœ… Hozircha takrorlash kerak emas!")
            return
        
        srs_id, question, correct, easiness, interval, repetition = card
        await state.update_data(
            current_srs_id=srs_id,
            srs_correct_answer=correct,
            srs_easiness=easiness,
            srs_interval=interval,
            srs_repetition=repetition
        )
        
        text = f"""
ðŸ” <b>SRS TAKRORLASH</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>SAVOL:</b>

{question}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Javobni o'ylab ko'ring, so'ng "Javobni ko'rish" bosing.
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‘ Javobni ko'rish", callback_data=f"srs_show_{srs_id}")
        builder.button(text="ðŸ”™ SRS menyu", callback_data="quiz_srs_review")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("srs_show_"))
    async def handle_srs_show(callback: CallbackQuery, state: FSMContext):
        """SRS javobini ko'rsatish"""
        data = await state.get_data()
        correct = data.get('srs_correct_answer', '')
        srs_id = int(callback.data.replace("srs_show_", ""))
        
        text = f"""
ðŸ” <b>SRS - JAVOB</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>TO'G'RI JAVOB:</b>

{correct}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Qanchalik yaxshi esladingiz?
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ˜° Umuman bilmadim", callback_data=f"srs_rate_{srs_id}_0")
        builder.button(text="ðŸ˜• Qiyin bo'ldi", callback_data=f"srs_rate_{srs_id}_2")
        builder.button(text="ðŸ¤” O'rtacha", callback_data=f"srs_rate_{srs_id}_3")
        builder.button(text="ðŸ˜Š Yaxshi", callback_data=f"srs_rate_{srs_id}_4")
        builder.button(text="ðŸŽ¯ Mukammal", callback_data=f"srs_rate_{srs_id}_5")
        builder.adjust(2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("srs_rate_"))
    async def handle_srs_rate(callback: CallbackQuery, state: FSMContext):
        """SRS baholash va keyingi takrorlash vaqtini hisoblash"""
        parts = callback.data.replace("srs_rate_", "").split("_")
        srs_id = int(parts[0])
        quality = int(parts[1])
        user_id = callback.from_user.id
        
        data = await state.get_data()
        easiness = data.get('srs_easiness', 2.5)
        interval = data.get('srs_interval', 1)
        repetition = data.get('srs_repetition', 0)
        
        # SM-2 algoritmi - parametrlar: quality, easiness, repetition, interval
        new_easiness, new_interval, new_repetition = calculate_srs_interval(quality, easiness, repetition, interval)
        
        # Keyingi takrorlash vaqti
        next_review = datetime.now() + timedelta(days=new_interval)
        is_mastered = 1 if new_interval >= 21 else 0  # 21 kundan keyin o'zlashtirilgan
        
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE quiz_srs 
                SET easiness = ?, interval = ?, repetition = repetition + 1, 
                    next_review_at = ?, is_mastered = ?
                WHERE id = ? AND user_id = ?
            ''', (new_easiness, new_interval, next_review.isoformat(), is_mastered, srs_id, user_id))
            await conn.commit()
        
        quality_text = {0: "ðŸ˜° Umuman bilmadim", 2: "ðŸ˜• Qiyin", 3: "ðŸ¤” O'rtacha", 4: "ðŸ˜Š Yaxshi", 5: "ðŸŽ¯ Mukammal"}
        
        await callback.answer(f"{quality_text.get(quality, '')} - Keyingi: {new_interval} kundan keyin")
        
        # Keyingi savolga o'tish
        await handle_srs_start_review(callback, state)
    
    @router.callback_query(F.data == "srs_stats")
    async def handle_srs_stats(callback: CallbackQuery):
        """SRS statistikasi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT COUNT(*), SUM(repetition), AVG(easiness)
                FROM quiz_srs WHERE user_id = ?
            ''', (user_id,))
            row = await cursor.fetchone()
            total = row[0] or 0
            reviews = row[1] or 0
            avg_ease = row[2] or 2.5
            
            cursor = await conn.execute('''
                SELECT COUNT(*) FROM quiz_srs WHERE user_id = ? AND is_mastered = 1
            ''', (user_id,))
            mastered = (await cursor.fetchone())[0] or 0
        
        text = f"""
ðŸ“Š <b>SRS STATISTIKASI</b>

<b>Jami kartalar:</b> {total} ta
<b>O'zlashtirilgan:</b> {mastered} ta ({(mastered/total*100) if total > 0 else 0:.0f}%)
<b>Jami takrorlashlar:</b> {reviews} ta
<b>O'rtacha qiyinlik:</b> {avg_ease:.2f}

<b>SRS darajalari:</b>
â€¢ ðŸŸ¢ Oson (E > 2.5): Tez o'zlashtiriladi
â€¢ ðŸŸ¡ O'rta (E = 2.5): Normal tezlik
â€¢ ðŸ”´ Qiyin (E < 2.5): Ko'proq takrorlash kerak
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ” Takrorlash", callback_data="quiz_srs_review")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== STREAK ==========
    @router.callback_query(F.data == "quiz_streak")
    async def handle_quiz_streak(callback: CallbackQuery):
        """Streak statistikasi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT current_streak, longest_streak, total_quizzes_taken, total_correct_answers, last_quiz_date
                FROM quiz_streaks WHERE user_id = ?
            ''', (user_id,))
            row = await cursor.fetchone()
        
        if row:
            current, longest, total_quizzes, total_correct, last_date = row
            current = current or 0
            longest = longest or 0
            total_quizzes = total_quizzes or 0
            total_correct = total_correct or 0
        else:
            current, longest, total_quizzes, total_correct, last_date = 0, 0, 0, 0, None
        
        # Streak emoji
        streak_emoji = "ðŸ”¥" * min(current, 10) if current > 0 else "â„ï¸"
        
        text = f"""
ðŸ”¥ <b>STREAK TIZIMI</b>

{streak_emoji}

<b>Joriy streak:</b> {current} kun
<b>Eng uzun streak:</b> {longest} kun
<b>Jami testlar:</b> {total_quizzes} ta
<b>To'g'ri javoblar:</b> {total_correct} ta
<b>Oxirgi test:</b> {last_date or "Hali yo'q"}

<b>Streak bonuslari:</b>
â€¢ 7 kun: +100 XP
â€¢ 14 kun: +250 XP
â€¢ 30 kun: +500 XP + ðŸ† Medal
â€¢ 100 kun: +2000 XP + ðŸ‘‘ Crown

{"âš ï¸ Bugun test ishlang, streak saqlansin!" if last_date != datetime.now().strftime('%Y-%m-%d') else "âœ… Bugun test ishladingiz!"}
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ¯ Test ishlash", callback_data="quiz_create")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== DUEL ==========
    @router.callback_query(F.data == "quiz_duel")
    async def handle_quiz_duel(callback: CallbackQuery):
        """Duel menyusi"""
        text = """
âš”ï¸ <b>DUEL REJIMI</b>

Do'stlaringiz bilan bilim bellashuviga qo'shiling!

<b>Qoidalar:</b>
â€¢ Har ikkala o'yinchi bir xil savollarni oladi
â€¢ Kim tez va to'g'ri javob bersa, yutadi
â€¢ G'olib 50 XP oladi, mag'lub 25 XP yo'qotadi

<b>Duel turlari:</b>
â€¢ âš¡ Tezkor (5 savol, 30 sek/savol)
â€¢ ðŸ“š Klassik (10 savol, 60 sek/savol)
â€¢ ðŸ† Marafon (20 savol, 90 sek/savol)

Tanlang:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.duel_menu())
        await callback.answer()
    
    @router.callback_query(F.data == "duel_random")
    async def handle_duel_random(callback: CallbackQuery):
        """Tasodifiy raqib bilan duel"""
        user_id = callback.from_user.id
        
        # Kutayotgan duelni qidirish
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT id, player1_id FROM quiz_duels 
                WHERE status = 'waiting' AND player1_id != ?
                ORDER BY created_at ASC LIMIT 1
            ''', (user_id,))
            waiting_duel = await cursor.fetchone()
            
            if waiting_duel:
                # Mavjud duelga qo'shilish
                duel_id, player1_id = waiting_duel
                await conn.execute('''
                    UPDATE quiz_duels SET player2_id = ?, status = 'active', started_at = datetime('now')
                    WHERE id = ?
                ''', (user_id, duel_id))
                await conn.commit()
                
                await callback.answer("ðŸŽ® Raqib topildi! Duel boshlanmoqda...")
                
                # Duel boshlash logikasi
                text = f"""
âš”ï¸ <b>DUEL BOSHLANDI!</b>

ðŸ†” Duel ID: #{duel_id}
ðŸ‘¤ Siz vs Raqib

Birinchi savol kelmoqda...
                """
                await safe_edit_text(callback, text)
                # TODO: Duel savollarini yuborish
            else:
                # Yangi duel yaratish
                cursor = await conn.execute('''
                    INSERT INTO quiz_duels (player1_id, status) VALUES (?, 'waiting')
                ''', (user_id,))
                duel_id = cursor.lastrowid
                await conn.commit()
                
                text = f"""
âš”ï¸ <b>DUEL KUTILMOQDA</b>

ðŸ†” Duel ID: #{duel_id}
â³ Raqib kutilmoqda...

Boshqa foydalanuvchi qo'shilganda duel boshlanadi.
                """
                
                builder = InlineKeyboardBuilder()
                builder.button(text="âŒ Bekor qilish", callback_data=f"duel_cancel_{duel_id}")
                builder.button(text="ðŸ”™ Duel menyu", callback_data="quiz_duel")
                builder.adjust(1)
                
                await safe_edit_text(callback, text, reply_markup=builder.as_markup())
                await callback.answer("â³ Raqib kutilmoqda...")
    
    @router.callback_query(F.data == "duel_invite")
    async def handle_duel_invite(callback: CallbackQuery, state: FSMContext):
        """Do'stni duelga taklif qilish"""
        text = """
ðŸ‘¥ <b>DO'STNI TAKLIF QILISH</b>

Do'stingizning username yoki ID sini kiriting:
<i>Masalan: @username yoki 123456789</i>
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_duel"))
        await state.set_state(UserStates.waiting_duel_opponent)
        await callback.answer()
    
    @router.message(UserStates.waiting_duel_opponent)
    async def handle_duel_opponent_input(message: Message, state: FSMContext):
        """Duel raqibi kiritilgandan keyin"""
        opponent_input = message.text.strip()
        user_id = message.from_user.id
        
        # Username yoki ID ni aniqlash
        opponent_id = None
        if opponent_input.startswith('@'):
            username = opponent_input[1:]
            async with db.connect() as conn:
                cursor = await conn.execute('SELECT user_id FROM users WHERE username = ?', (username,))
                row = await cursor.fetchone()
                if row:
                    opponent_id = row[0]
        elif opponent_input.isdigit():
            opponent_id = int(opponent_input)
        
        if not opponent_id:
            await message.answer("âŒ Foydalanuvchi topilmadi. Qaytadan urinib ko'ring.")
            return
        
        if opponent_id == user_id:
            await message.answer("âŒ O'zingiz bilan duel qila olmaysiz!")
            return
        
        # Duel yaratish
        async with db.connect() as conn:
            cursor = await conn.execute('''
                INSERT INTO quiz_duels (player1_id, player2_id, status) VALUES (?, ?, 'pending')
            ''', (user_id, opponent_id))
            duel_id = cursor.lastrowid
            await conn.commit()
        
        # Raqibga xabar yuborish
        try:
            invite_text = f"""
âš”ï¸ <b>DUEL TAKLIFI!</b>

ðŸ‘¤ {message.from_user.full_name} sizni duelga taklif qilmoqda!

Qabul qilasizmi?
            """
            builder = InlineKeyboardBuilder()
            builder.button(text="âœ… Qabul qilish", callback_data=f"duel_accept_{duel_id}")
            builder.button(text="âŒ Rad etish", callback_data=f"duel_reject_{duel_id}")
            builder.adjust(2)
            
            await message.bot.send_message(opponent_id, invite_text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            await message.answer(f"âœ… Taklif yuborildi! Raqib javobini kuting.")
        except Exception as e:
            await message.answer("âŒ Raqibga xabar yuborib bo'lmadi. Ular botni ishga tushirmagan bo'lishi mumkin.")
        
        await state.clear()
    
    @router.callback_query(F.data.startswith("duel_accept_"))
    async def handle_duel_accept(callback: CallbackQuery):
        """Duel taklifini qabul qilish"""
        duel_id = int(callback.data.replace("duel_accept_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT player1_id, player2_id FROM quiz_duels WHERE id = ?', (duel_id,))
            duel = await cursor.fetchone()
            
            if not duel or duel[1] != user_id:
                await callback.answer("âŒ Bu duel sizga tegishli emas!")
                return
            
            await conn.execute('''
                UPDATE quiz_duels SET status = 'active', started_at = datetime('now') WHERE id = ?
            ''', (duel_id,))
            await conn.commit()
        
        await callback.answer("âœ… Duel boshlandi!")
        await callback.message.edit_text("âš”ï¸ <b>DUEL BOSHLANDI!</b>\n\nSavollar kelmoqda...", parse_mode=ParseMode.HTML)
        # TODO: Duel savollarini yuborish
    
    @router.callback_query(F.data.startswith("duel_reject_"))
    async def handle_duel_reject(callback: CallbackQuery):
        """Duel taklifini rad etish"""
        duel_id = int(callback.data.replace("duel_reject_", ""))
        
        async with db.connect() as conn:
            await conn.execute('UPDATE quiz_duels SET status = "rejected" WHERE id = ?', (duel_id,))
            await conn.commit()
        
        await callback.answer("âŒ Duel rad etildi")
        await callback.message.edit_text("âŒ Siz duelni rad etdingiz.", parse_mode=ParseMode.HTML)
    
    @router.callback_query(F.data.startswith("duel_cancel_"))
    async def handle_duel_cancel(callback: CallbackQuery):
        """Duelni bekor qilish"""
        duel_id = int(callback.data.replace("duel_cancel_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            await conn.execute('UPDATE quiz_duels SET status = "cancelled" WHERE id = ? AND player1_id = ?', (duel_id, user_id))
            await conn.commit()
        
        await callback.answer("âŒ Duel bekor qilindi")
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Duel menyu", callback_data="quiz_duel")
        
        await safe_edit_text(callback, "âŒ Duel bekor qilindi.", reply_markup=builder.as_markup())
    
    @router.callback_query(F.data == "duel_active")
    async def handle_duel_active(callback: CallbackQuery):
        """Faol duellar ro'yxati"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT d.id, d.status, d.created_at, u1.full_name as p1_name, u2.full_name as p2_name
                FROM quiz_duels d
                LEFT JOIN users u1 ON d.player1_id = u1.user_id
                LEFT JOIN users u2 ON d.player2_id = u2.user_id
                WHERE (d.player1_id = ? OR d.player2_id = ?) AND d.status IN ('waiting', 'pending', 'active')
                ORDER BY d.created_at DESC LIMIT 10
            ''', (user_id, user_id))
            duels = await cursor.fetchall()
        
        if not duels:
            text = "ðŸ“‹ <b>FAOL DUELLAR</b>\n\nâŒ Hozircha faol duellar yo'q."
        else:
            text = f"ðŸ“‹ <b>FAOL DUELLAR</b>\n\n<b>Jami:</b> {len(duels)} ta\n\n"
            for duel_id, status, created, p1_name, p2_name in duels:
                status_emoji = {"waiting": "â³", "pending": "ðŸ“¨", "active": "âš”ï¸"}.get(status, "â“")
                text += f"{status_emoji} <b>#{duel_id}</b>\n"
                text += f"   ðŸ‘¤ {p1_name or 'Noma\'lum'} vs {p2_name or 'Kutilmoqda'}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Duel menyu", callback_data="quiz_duel")
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "duel_history")
    async def handle_duel_history(callback: CallbackQuery):
        """Duel tarixi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT d.id, d.winner_id, d.finished_at, u1.full_name as p1_name, u2.full_name as p2_name,
                       d.player1_id, d.player2_id
                FROM quiz_duels d
                LEFT JOIN users u1 ON d.player1_id = u1.user_id
                LEFT JOIN users u2 ON d.player2_id = u2.user_id
                WHERE (d.player1_id = ? OR d.player2_id = ?) AND d.status = 'finished'
                ORDER BY d.finished_at DESC LIMIT 10
            ''', (user_id, user_id))
            duels = await cursor.fetchall()
        
        if not duels:
            text = "ðŸ† <b>DUEL TARIXI</b>\n\nâŒ Hozircha tugallangan duellar yo'q."
        else:
            wins = sum(1 for d in duels if d[1] == user_id)
            losses = len(duels) - wins
            
            text = f"ðŸ† <b>DUEL TARIXI</b>\n\n"
            text += f"âœ… G'alabalar: {wins} | âŒ Mag'lubiyatlar: {losses}\n\n"
            
            for duel_id, winner_id, finished, p1_name, p2_name, p1_id, p2_id in duels:
                if winner_id == user_id:
                    result = "ðŸ† G'alaba"
                elif winner_id:
                    result = "âŒ Mag'lubiyat"
                else:
                    result = "ðŸ¤ Durrang"
                
                opponent = p2_name if p1_id == user_id else p1_name
                text += f"{result} vs <b>{opponent or 'Noma\'lum'}</b>\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”™ Duel menyu", callback_data="quiz_duel")
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== STATISTIKA ==========
    @router.callback_query(F.data == "quiz_stats")
    async def handle_quiz_stats(callback: CallbackQuery):
        """Quiz statistikasi"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Umumiy statistika
            cursor = await conn.execute('''
                SELECT COUNT(*), SUM(correct_answers), SUM(wrong_answers), AVG(score), SUM(xp_earned)
                FROM quiz_attempts WHERE user_id = ?
            ''', (user_id,))
            row = await cursor.fetchone()
            total_attempts = row[0] or 0
            total_correct = row[1] or 0
            total_wrong = row[2] or 0
            avg_score = row[3] or 0
            total_xp = row[4] or 0
            
            # Sertifikatlar
            cursor = await conn.execute('SELECT COUNT(*) FROM quiz_certificates WHERE user_id = ?', (user_id,))
            certificates = (await cursor.fetchone())[0] or 0
        
        accuracy = (total_correct / (total_correct + total_wrong) * 100) if (total_correct + total_wrong) > 0 else 0
        
        text = f"""
ðŸ“Š <b>QUIZ STATISTIKASI</b>

<b>Umumiy:</b>
â€¢ Jami testlar: {total_attempts} ta
â€¢ To'g'ri javoblar: {total_correct} ta
â€¢ Noto'g'ri javoblar: {total_wrong} ta
â€¢ O'rtacha ball: {avg_score:.1f}%
â€¢ Aniqlik: {accuracy:.1f}%

<b>Yutuqlar:</b>
â€¢ Jami XP: {total_xp:,} XP
â€¢ Sertifikatlar: {certificates} ta

<b>Reyting:</b>
Haftalik reytingda o'rningizni ko'ring!
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ† Reyting", callback_data="quiz_leaderboard")
        builder.button(text="ðŸŽ“ Sertifikatlar", callback_data="quiz_certificates")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== REYTING ==========
    @router.callback_query(F.data == "quiz_leaderboard")
    async def handle_quiz_leaderboard(callback: CallbackQuery):
        """Quiz reytingi"""
        user_id = callback.from_user.id
        
        # Hafta boshini hisoblash
        today = datetime.now()
        week_start = (today - timedelta(days=today.weekday())).strftime('%Y-%m-%d')
        
        async with db.connect() as conn:
            # Top 10
            cursor = await conn.execute('''
                SELECT u.full_name, u.username, SUM(qa.xp_earned) as total_xp, COUNT(*) as quizzes
                FROM quiz_attempts qa
                JOIN users u ON qa.user_id = u.user_id
                WHERE DATE(qa.started_at) >= ?
                GROUP BY qa.user_id
                ORDER BY total_xp DESC
                LIMIT 10
            ''', (week_start,))
            top_users = await cursor.fetchall()
            
            # Foydalanuvchi o'rni
            cursor = await conn.execute('''
                SELECT COUNT(*) + 1 FROM (
                    SELECT SUM(xp_earned) as total_xp FROM quiz_attempts 
                    WHERE DATE(started_at) >= ? GROUP BY user_id
                ) WHERE total_xp > (
                    SELECT COALESCE(SUM(xp_earned), 0) FROM quiz_attempts 
                    WHERE user_id = ? AND DATE(started_at) >= ?
                )
            ''', (week_start, user_id, week_start))
            user_rank = (await cursor.fetchone())[0] or 0
        
        text = f"ðŸ† <b>HAFTALIK REYTING</b>\n\n"
        text += f"ðŸ“… Hafta: {week_start}\n"
        text += f"ðŸ“Š Sizning o'rningiz: #{user_rank}\n\n"
        
        if top_users:
            for i, (name, username, xp, quizzes) in enumerate(top_users, 1):
                medal = "ðŸ¥‡" if i == 1 else "ðŸ¥ˆ" if i == 2 else "ðŸ¥‰" if i == 3 else f"{i}."
                text += f"{medal} <b>{name or username or 'Noma\'lum'}</b>\n"
                text += f"   ðŸ’° {xp or 0:,} XP | ðŸ“ {quizzes} test\n\n"
        else:
            text += "âŒ Hozircha reyting bo'sh.\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”„ Yangilash", callback_data="quiz_leaderboard")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== SERTIFIKATLAR ==========
    @router.callback_query(F.data == "quiz_certificates")
    async def handle_quiz_certificates(callback: CallbackQuery):
        """Sertifikatlar ro'yxati"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT qc.certificate_id, qc.score, qc.grade, qc.issued_at, q.title
                FROM quiz_certificates qc
                JOIN quizzes q ON qc.quiz_id = q.id
                WHERE qc.user_id = ?
                ORDER BY qc.issued_at DESC
                LIMIT 10
            ''', (user_id,))
            certificates = await cursor.fetchall()
        
        if not certificates:
            text = """
ðŸŽ“ <b>SERTIFIKATLARIM</b>

âŒ Hozircha sertifikatlar yo'q.

<b>Sertifikat olish uchun:</b>
â€¢ Testdan 90% yoki undan yuqori ball oling
â€¢ "Sertifikat olish" tugmasini bosing

Sertifikatni do'stlaringiz bilan baham ko'ring!
            """
        else:
            text = f"ðŸŽ“ <b>SERTIFIKATLARIM</b>\n\n<b>Jami:</b> {len(certificates)} ta\n\n"
            for cert_id, score, grade, issued_at, title in certificates:
                text += f"ðŸ“œ <b>{title[:30]}...</b>\n"
                text += f"   ðŸ† Ball: {score}% | {grade}\n"
                text += f"   ðŸ“… {issued_at[:10]}\n\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ¯ Test ishlash", callback_data="quiz_create")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== SERTIFIKAT YARATISH ==========
    @router.callback_query(F.data.startswith("quiz_certificate_"))
    async def handle_create_certificate(callback: CallbackQuery):
        """Sertifikat yaratish"""
        quiz_id_str = callback.data.replace("quiz_certificate_", "")
        
        if not quiz_id_str or quiz_id_str == "None" or not quiz_id_str.isdigit():
            await callback.answer("âŒ Test ID topilmadi!", show_alert=True)
            return
        
        quiz_id = int(quiz_id_str)
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        # Oxirgi attempt ni olish
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT score, completed_at FROM quiz_attempts 
                WHERE user_id = ? AND quiz_id = ? AND completed = 1
                ORDER BY completed_at DESC LIMIT 1
            ''', (user_id, quiz_id))
            attempt = await cursor.fetchone()
            
            if not attempt or attempt[0] < 90:
                await callback.answer("âŒ Sertifikat olish uchun 90%+ ball kerak!", show_alert=True)
                return
            
            score = attempt[0]
            
            # Sertifikat allaqachon bormi
            cursor = await conn.execute('SELECT 1 FROM quiz_certificates WHERE user_id = ? AND quiz_id = ?', (user_id, quiz_id))
            if await cursor.fetchone():
                await callback.answer("âœ… Sertifikat allaqachon olingan!", show_alert=True)
                return
            
            # Quiz ma'lumotlari
            cursor = await conn.execute('SELECT title FROM quizzes WHERE id = ?', (quiz_id,))
            quiz_row = await cursor.fetchone()
            quiz_title = quiz_row[0] if quiz_row else "Test"
            
            # Sertifikat yaratish
            certificate_id = f"CERT-{user_id}-{quiz_id}-{int(time.time())}"
            grade = "A+" if score >= 95 else "A" if score >= 90 else "B"
            
            await conn.execute('''
                INSERT INTO quiz_certificates (user_id, quiz_id, certificate_id, score, grade)
                VALUES (?, ?, ?, ?, ?)
            ''', (user_id, quiz_id, certificate_id, score, grade))
            await conn.commit()
        
        # Sertifikat xabari
        text = f"""
ðŸŽ“ <b>SERTIFIKAT BERILDI!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“œ <b>NEXUS MEDIA SERTIFIKATI</b>

<b>Ism:</b> {user.get('full_name', 'Foydalanuvchi')}
<b>Test:</b> {quiz_title}
<b>Ball:</b> {score}%
<b>Daraja:</b> {grade}
<b>Sana:</b> {datetime.now().strftime('%Y-%m-%d')}
<b>ID:</b> <code>{certificate_id}</code>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸŽ‰ Tabriklaymiz! Sertifikatingizni do'stlaringiz bilan baham ko'ring!
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¤ Baham ko'rish", callback_data=f"share_cert_{certificate_id}")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer("ðŸŽ“ Sertifikat berildi!")
    
    @router.callback_query(F.data.startswith("share_cert_"))
    async def handle_share_certificate(callback: CallbackQuery):
        """Sertifikatni baham ko'rish"""
        cert_id = callback.data.replace("share_cert_", "")
        user_id = callback.from_user.id
        
        # Bot username olish
        bot_info = await callback.bot.get_me()
        bot_username = bot_info.username
        
        share_text = f"""
ðŸŽ“ <b>SERTIFIKAT</b>

Men {bot_username} botida testdan o'tdim va sertifikat oldim!

ðŸ†” Sertifikat ID: <code>{cert_id}</code>

Siz ham sinab ko'ring: @{bot_username}
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¤ Do'stlarga yuborish", switch_inline_query=f"Sertifikat: {cert_id}")
        builder.button(text="ðŸ–¼ Rasm olish", callback_data=f"cert_image_{cert_id}")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, share_text, reply_markup=builder.as_markup())
        await callback.answer()
    
    # ========== MENING TESTLARIM (PAGINATION BILAN) ==========
    @router.callback_query(F.data.regexp(r"^quiz_my_quizzes(_page_\d+)?$"))
    async def handle_my_quizzes(callback: CallbackQuery):
        """Foydalanuvchi testlari - pagination bilan"""
        user_id = callback.from_user.id
        
        # Sahifa raqamini olish
        page = 0
        if "_page_" in callback.data:
            try:
                page = int(callback.data.split("_page_")[1])
            except:
                page = 0
        
        per_page = 5  # Har sahifada 5 ta test
        offset = page * per_page
        
        async with db.connect() as conn:
            # Jami testlar soni
            cursor = await conn.execute('SELECT COUNT(*) FROM quizzes WHERE user_id = ?', (user_id,))
            total_count = (await cursor.fetchone())[0]
            
            # Sahifadagi testlar
            cursor = await conn.execute('''
                SELECT id, title, category, total_questions, plays_count, avg_score, created_at
                FROM quizzes WHERE user_id = ?
                ORDER BY created_at DESC LIMIT ? OFFSET ?
            ''', (user_id, per_page, offset))
            quizzes = await cursor.fetchall()
        
        total_pages = (total_count + per_page - 1) // per_page if total_count > 0 else 1
        
        if not quizzes and page == 0:
            text = """
ðŸ“š <b>MENING TESTLARIM</b>

âŒ Hozircha testlar yo'q.

AI yordamida yangi test yarating!
            """
        else:
            text = f"ðŸ“š <b>MENING TESTLARIM</b>\n\n"
            text += f"<b>Jami:</b> {total_count} ta | <b>Sahifa:</b> {page + 1}/{total_pages}\n\n"
            
            for i, (qid, title, category, total, plays, avg, created) in enumerate(quizzes, start=offset + 1):
                text += f"<b>{i}.</b> ðŸ“ <b>{title[:35]}{'...' if len(title) > 35 else ''}</b>\n"
                text += f"    ðŸ“‚ {category or 'Nomalum'} | â“ {total} savol\n"
                text += f"    â–¶ï¸ {plays or 0} marta | ðŸ“Š {avg or 0:.0f}%\n\n"
        
        builder = InlineKeyboardBuilder()
        
        # Test tugmalari
        for qid, title, *_ in quizzes:
            short_title = title[:20] + "..." if len(title) > 20 else title
            builder.button(text=f"ðŸ“ {short_title}", callback_data=f"view_my_quiz_{qid}")
        
        # Pagination tugmalari
        nav_buttons = []
        if page > 0:
            nav_buttons.append(("â¬…ï¸ Oldingi", f"quiz_my_quizzes_page_{page - 1}"))
        if page < total_pages - 1:
            nav_buttons.append(("Keyingi âž¡ï¸", f"quiz_my_quizzes_page_{page + 1}"))
        
        for text_btn, callback_data in nav_buttons:
            builder.button(text=text_btn, callback_data=callback_data)
        
        builder.button(text="ðŸŽ¯ Yangi test", callback_data="quiz_ai_test")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        
        # Adjust: testlar (1 qator), pagination (2 qator), boshqalar (1 qator)
        rows = [1] * len(quizzes)  # Har bir test alohida qatorda
        if nav_buttons:
            rows.append(len(nav_buttons))
        rows.extend([1, 1])
        builder.adjust(*rows)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("view_my_quiz_"))
    async def handle_view_my_quiz(callback: CallbackQuery):
        """O'z testini ko'rish"""
        quiz_id = callback.data.replace("view_my_quiz_", "")
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT id, title, category, total_questions, plays_count, avg_score, created_at
                FROM quizzes WHERE id = ? AND user_id = ?
            ''', (quiz_id, user_id))
            quiz = await cursor.fetchone()
        
        if not quiz:
            await callback.answer("âŒ Test topilmadi!", show_alert=True)
            return
        
        qid, title, category, total, plays, avg, created = quiz
        
        text = f"""
ðŸ“ <b>TEST MA'LUMOTLARI</b>

<b>Nomi:</b> {title}
<b>Kategoriya:</b> {category or 'Nomalum'}
<b>Savollar:</b> {total} ta
<b>O'ynalgan:</b> {plays or 0} marta
<b>O'rtacha ball:</b> {avg or 0:.0f}%
<b>Yaratilgan:</b> {created[:10] if created else 'Nomalum'}

<b>Amallar:</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="â–¶ï¸ O'ynash", callback_data=f"play_quiz_{qid}")
        builder.button(text="ðŸ“¤ Ulashish", callback_data=f"share_quiz_{qid}")
        builder.button(text="ðŸ“¥ Yuklab olish", callback_data=f"download_quiz_{qid}")
        builder.button(text="ðŸ—‘ O'chirish", callback_data=f"delete_my_quiz_{qid}")
        builder.button(text="ðŸ”™ Mening testlarim", callback_data="quiz_my_quizzes")
        builder.adjust(2, 2, 1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("play_quiz_"))
    async def handle_play_quiz(callback: CallbackQuery, state: FSMContext):
        """Testni o'ynash"""
        quiz_id = callback.data.replace("play_quiz_", "")
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Test ma'lumotlarini olish
            cursor = await conn.execute(
                'SELECT title, category, total_questions FROM quizzes WHERE id = ?',
                (quiz_id,)
            )
            quiz = await cursor.fetchone()
            
            if not quiz:
                await callback.answer("âŒ Test topilmadi!", show_alert=True)
                return
            
            title, category, total = quiz
            
            # Savollarni olish
            cursor = await conn.execute(
                'SELECT id, question, options, correct_answer FROM quiz_questions WHERE quiz_id = ? ORDER BY id',
                (quiz_id,)
            )
            questions_raw = await cursor.fetchall()
        
        if not questions_raw:
            await callback.answer("âŒ Savollar topilmadi!", show_alert=True)
            return
        
        # Savollarni formatlash
        import json
        questions = []
        for qid, question, options_json, correct in questions_raw:
            try:
                options = json.loads(options_json) if options_json else []
                questions.append({
                    'id': qid,
                    'question': question,
                    'options': options,
                    'correct': correct
                })
            except:
                pass
        
        if not questions:
            await callback.answer("âŒ Savollarni yuklashda xatolik!", show_alert=True)
            return
        
        # State'ga saqlash
        await state.update_data(
            current_quiz_id=quiz_id,
            current_questions=questions,
            current_question_index=0,
            correct_count=0,
            wrong_count=0,
            answers=[]
        )
        
        # Birinchi savolni ko'rsatish
        q = questions[0]
        text = f"ðŸ“ <b>{title}</b>\n\n"
        text += f"<b>Savol 1/{len(questions)}</b>\n\n"
        text += f"â“ {q['question']}\n\n"
        
        builder = InlineKeyboardBuilder()
        labels = ['A', 'B', 'C', 'D']
        for i, opt in enumerate(q['options'][:4]):
            builder.button(text=f"{labels[i]}) {opt[:50]}", callback_data=f"quiz_ans_{i}")
        builder.button(text="â­ï¸ O'tkazib yuborish", callback_data="quiz_skip")
        builder.button(text="âŒ Tugatish", callback_data="quiz_end")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("download_quiz_"))
    async def handle_download_quiz(callback: CallbackQuery):
        """Testni yuklab olish (TXT formatda)"""
        quiz_id = callback.data.replace("download_quiz_", "")
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Test ma'lumotlari
            cursor = await conn.execute(
                'SELECT title, category FROM quizzes WHERE id = ? AND user_id = ?',
                (quiz_id, user_id)
            )
            quiz = await cursor.fetchone()
            
            if not quiz:
                await callback.answer("âŒ Test topilmadi!", show_alert=True)
                return
            
            title, category = quiz
            
            # Savollarni olish
            cursor = await conn.execute(
                'SELECT question, options, correct_answer FROM quiz_questions WHERE quiz_id = ? ORDER BY id',
                (quiz_id,)
            )
            questions = await cursor.fetchall()
        
        if not questions:
            await callback.answer("âŒ Savollar topilmadi!", show_alert=True)
            return
        
        # TXT fayl yaratish
        content = f"TEST: {title}\n"
        content += f"Kategoriya: {category or 'Nomalum'}\n"
        content += f"Savollar soni: {len(questions)}\n"
        content += "=" * 50 + "\n\n"
        
        for i, (question, options_json, correct) in enumerate(questions, 1):
            content += f"{i}. {question}\n"
            try:
                import json
                options = json.loads(options_json) if options_json else []
                labels = ['A', 'B', 'C', 'D']
                for j, opt in enumerate(options[:4]):
                    marker = "âœ“" if j == correct else " "
                    content += f"   {labels[j]}) {opt} {marker}\n"
            except:
                pass
            content += "\n"
        
        content += "=" * 50 + "\n"
        content += f"To'g'ri javoblar soni: {len(questions)}\n"
        
        # Faylni yuborish
        from io import BytesIO
        file_bytes = BytesIO(content.encode('utf-8'))
        file_bytes.name = f"test_{quiz_id}.txt"
        
        from aiogram.types import BufferedInputFile
        from aiogram.exceptions import TelegramUnauthorizedError
        import os

        os.environ.pop("BOT_TOKEN", None)

        input_file = BufferedInputFile(file_bytes.getvalue(), filename=f"test_{title[:20]}.txt")
        
        await callback.message.answer_document(
            input_file,
            caption=f"ðŸ“¥ <b>{title}</b>\n\nTest yuklab olindi!",
            parse_mode=ParseMode.HTML
        )
        await callback.answer("âœ… Test yuklab olindi!")
    
    @router.callback_query(F.data.startswith("delete_my_quiz_"))
    async def handle_delete_my_quiz(callback: CallbackQuery):
        """O'z testini o'chirish"""
        quiz_id = callback.data.replace("delete_my_quiz_", "")
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            # Test mavjudligini tekshirish
            cursor = await conn.execute(
                'SELECT title FROM quizzes WHERE id = ? AND user_id = ?',
                (quiz_id, user_id)
            )
            quiz = await cursor.fetchone()
            
            if not quiz:
                await callback.answer("âŒ Test topilmadi!", show_alert=True)
                return
            
            title = quiz[0]
            
            # Savollarni o'chirish
            await conn.execute('DELETE FROM quiz_questions WHERE quiz_id = ?', (quiz_id,))
            # Testni o'chirish
            await conn.execute('DELETE FROM quizzes WHERE id = ? AND user_id = ?', (quiz_id, user_id))
            await conn.commit()
        
        await callback.answer(f"âœ… '{title}' testi o'chirildi!", show_alert=True)
        
        # Mening testlarim sahifasiga qaytish
        await handle_my_quizzes(callback)
    
    # ========== OLTIN DO'KONI ==========
    async def add_quiz_gold(user_id: int, amount: int) -> int:
        """Quiz RPG tizimi uchun oltin qo'shish"""
        if amount <= 0:
            return 0
        try:
            async with db.connect() as conn:
                cursor = await conn.execute('SELECT gold FROM quiz_streaks WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                if row:
                    await conn.execute('UPDATE quiz_streaks SET gold = gold + ? WHERE user_id = ?', (amount, user_id))
                else:
                    await conn.execute('INSERT INTO quiz_streaks (user_id, gold) VALUES (?, ?)', (user_id, amount))
                await conn.commit()
            return amount
        except Exception as e:
            logger.error(f"Oltin qo'shishda xatolik: {e}")
            return 0
    
    @router.callback_query(F.data == "gold_shop")
    async def handle_gold_shop(callback: CallbackQuery):
        """Oltin do'koni - oltin sotib olish"""
        user_id = callback.from_user.id
        
        # Foydalanuvchi oltinini olish
        gold = 0
        try:
            async with db.connect() as conn:
                cursor = await conn.execute('SELECT gold FROM quiz_streaks WHERE user_id = ?', (user_id,))
                row = await cursor.fetchone()
                if row:
                    gold = row[0] or 0
        except:
            pass
        
        text = f"""
ðŸ›’ <b>OLTIN DO'KONI</b>

ðŸ’° <b>Sizning oltiningiz:</b> {gold} ðŸª™

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>OLTIN PAKETLARI:</b>

ðŸª™ <b>1000 oltin</b> = 10,000 so'm
ðŸª™ <b>5000 oltin</b> = 45,000 so'm (10% chegirma)
ðŸª™ <b>10000 oltin</b> = 80,000 so'm (20% chegirma)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>TO'LOV USULLARI:</b>
ðŸ’³ Karta orqali (Click/Payme)

<i>To'lovdan keyin admin tasdiqlaydi</i>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸª™ 1000 oltin - 10,000 so'm", callback_data="buy_gold_1000")
        builder.button(text="ðŸª™ 5000 oltin - 45,000 so'm", callback_data="buy_gold_5000")
        builder.button(text="ðŸª™ 10000 oltin - 80,000 so'm", callback_data="buy_gold_10000")
        builder.button(text="ðŸ”™ Orqaga", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.regexp(r"^buy_gold_\d+$"))
    async def handle_buy_gold(callback: CallbackQuery, state: FSMContext):
        """Oltin sotib olish (pul bilan)"""
        gold_amount = int(callback.data.replace("buy_gold_", ""))
        user_id = callback.from_user.id
        
        prices = {
            1000: 10000,
            5000: 45000,
            10000: 80000
        }
        
        price = prices.get(gold_amount, 10000)
        
        # To'lov ID yaratish
        payment_id = f"GOLD_{user_id}_{gold_amount}_{int(time.time())}"
        
        # State'ga saqlash - payment_id ham kerak (chek handler uchun)
        await state.update_data(
            payment_id=payment_id,
            gold_payment_id=payment_id,
            gold_amount=gold_amount,
            gold_price=price,
            payment_type="gold"
        )
        
        # Bazaga to'lov qo'shish
        try:
            async with db.connect() as conn:
                await conn.execute('''
                    INSERT INTO payments (payment_id, user_id, amount, payment_method, description, status)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (payment_id, user_id, price, 'card', f'Oltin sotib olish: {gold_amount} ta', 'pending'))
                await conn.commit()
        except Exception as e:
            logger.error(f"Oltin to'lov yaratishda xatolik: {e}")
        
        payment_card = Config.PAYMENT_CARD
        payment_name = Config.PAYMENT_CARD_NAME
        
        text = f"""
ðŸ’³ <b>TO'LOV MA'LUMOTLARI</b>

ðŸª™ <b>Oltin:</b> {gold_amount} ta
ðŸ’° <b>Narxi:</b> {price:,} so'm

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>KARTA RAQAMI:</b>
<code>{payment_card}</code>

<b>Egasi:</b> {payment_name}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>To'lov ID:</b> <code>{payment_id}</code>

âš ï¸ <b>MUHIM:</b>
1. Yuqoridagi kartaga to'lang
2. To'lov chekini shu yerga yuboring
3. Admin tasdiqlaydi (1-24 soat)

<i>To'lov izohiga ID ni yozing!</i>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¸ Chek yuborish", callback_data="send_gold_receipt")
        builder.button(text="âŒ Bekor qilish", callback_data="gold_shop")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "send_gold_receipt")
    async def handle_send_gold_receipt(callback: CallbackQuery, state: FSMContext):
        """To'lov cheki yuborish"""
        await callback.message.answer(
            "ðŸ“¸ <b>To'lov chekini yuboring</b>\n\n"
            "Rasm yoki screenshot yuboring:",
            parse_mode=ParseMode.HTML
        )
        await state.set_state(UserStates.waiting_payment_receipt)
        await callback.answer()
    
    # ========== TEST SHARE QILISH ==========
    @router.callback_query(F.data.startswith("share_quiz_"))
    async def handle_share_quiz(callback: CallbackQuery):
        """Testni guruhlarga share qilish"""
        quiz_id = callback.data.replace("share_quiz_", "")
        user_id = callback.from_user.id
        
        # Bot username olish
        bot_info = await callback.bot.get_me()
        bot_username = bot_info.username
        
        # Test ma'lumotlarini olish
        async with db.connect() as conn:
            cursor = await conn.execute(
                'SELECT title, category, total_questions FROM quizzes WHERE id = ? AND user_id = ?',
                (quiz_id, user_id)
            )
            quiz = await cursor.fetchone()
        
        if not quiz:
            await callback.answer("âŒ Test topilmadi!", show_alert=True)
            return
        
        title, category, total = quiz
        
        share_link = f"https://t.me/{bot_username}?start=quiz_{quiz_id}"
        
        text = f"""
ðŸ“¤ <b>TESTNI BAHAM KO'RISH</b>

ðŸ“ <b>Test:</b> {title}
ðŸ“‚ <b>Kategoriya:</b> {category}
â“ <b>Savollar:</b> {total} ta

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Havola:</b>
<code>{share_link}</code>

Bu havolani guruhlarga yuboring!
Do'stlaringiz test ishlashi mumkin.
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¤ Guruhga yuborish", switch_inline_query=f"Test: {title}\n{share_link}")
        builder.button(text="ðŸ“‹ Havolani nusxalash", callback_data=f"copy_quiz_link_{quiz_id}")
        builder.button(text="ðŸ”™ Mening testlarim", callback_data="quiz_my_quizzes")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("copy_quiz_link_"))
    async def handle_copy_quiz_link(callback: CallbackQuery):
        """Test havolasini nusxalash uchun ko'rsatish"""
        quiz_id = callback.data.replace("copy_quiz_link_", "")
        
        bot_info = await callback.bot.get_me()
        share_link = f"https://t.me/{bot_info.username}?start=quiz_{quiz_id}"
        
        await callback.answer(f"ðŸ“‹ Havola: {share_link}", show_alert=True)
    
    # ========== KINO SHARE QILISH ==========
    @router.callback_query(F.data.startswith("share_movie_"))
    async def handle_share_movie(callback: CallbackQuery):
        """Kinoni guruhlarga share qilish"""
        movie_id = callback.data.replace("share_movie_", "")
        
        bot_info = await callback.bot.get_me()
        bot_username = bot_info.username
        
        async with db.connect() as conn:
            cursor = await conn.execute(
                'SELECT title, genre, year FROM movies WHERE id = ?',
                (movie_id,)
            )
            movie = await cursor.fetchone()
        
        if not movie:
            await callback.answer("âŒ Kino topilmadi!", show_alert=True)
            return
        
        title, genre, year = movie
        share_link = f"https://t.me/{bot_username}?start=movie_{movie_id}"
        
        text = f"""
ðŸ“¤ <b>KINONI BAHAM KO'RISH</b>

ðŸŽ¬ <b>Kino:</b> {title}
ðŸ“‚ <b>Janr:</b> {genre or 'Noma\'lum'}
ðŸ“… <b>Yil:</b> {year or 'Noma\'lum'}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Havola:</b>
<code>{share_link}</code>

Bu havolani do'stlaringizga yuboring!
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¤ Guruhga yuborish", switch_inline_query=f"ðŸŽ¬ {title}\n{share_link}")
        builder.button(text="ðŸ“‹ Havolani nusxalash", callback_data=f"copy_movie_link_{movie_id}")
        builder.button(text="ðŸŽ¬ Kinoteatr", callback_data="cinema_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("copy_movie_link_"))
    async def handle_copy_movie_link(callback: CallbackQuery):
        """Kino havolasini nusxalash"""
        movie_id = callback.data.replace("copy_movie_link_", "")
        bot_info = await callback.bot.get_me()
        share_link = f"https://t.me/{bot_info.username}?start=movie_{movie_id}"
        await callback.answer(f"ðŸ“‹ Havola: {share_link}", show_alert=True)
    
    # ========== KITOB SHARE QILISH ==========
    @router.callback_query(F.data.startswith("share_book_"))
    async def handle_share_book(callback: CallbackQuery):
        """Kitobni guruhlarga share qilish"""
        book_id = callback.data.replace("share_book_", "")
        
        bot_info = await callback.bot.get_me()
        bot_username = bot_info.username
        
        async with db.connect() as conn:
            cursor = await conn.execute(
                'SELECT caption, author, genre FROM books WHERE id = ?',
                (book_id,)
            )
            book = await cursor.fetchone()
        
        if not book:
            await callback.answer("âŒ Kitob topilmadi!", show_alert=True)
            return
        
        caption, author, genre = book
        title = caption or 'Nomsiz kitob'
        share_link = f"https://t.me/{bot_username}?start=book_{book_id}"
        
        text = f"""
ðŸ“¤ <b>KITOBNI BAHAM KO'RISH</b>

ðŸ“š <b>Kitob:</b> {title}
ðŸ‘¤ <b>Muallif:</b> {author or 'Noma\'lum'}
ðŸ“‚ <b>Janr:</b> {genre or 'Noma\'lum'}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Havola:</b>
<code>{share_link}</code>

Bu havolani do'stlaringizga yuboring!
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“¤ Guruhga yuborish", switch_inline_query=f"ðŸ“š {title}\n{share_link}")
        builder.button(text="ðŸ“‹ Havolani nusxalash", callback_data=f"copy_book_link_{book_id}")
        builder.button(text="ðŸ“š Kutubxona", callback_data="library_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data.startswith("copy_book_link_"))
    async def handle_copy_book_link(callback: CallbackQuery):
        """Kitob havolasini nusxalash"""
        book_id = callback.data.replace("copy_book_link_", "")
        bot_info = await callback.bot.get_me()
        share_link = f"https://t.me/{bot_info.username}?start=book_{book_id}"
        await callback.answer(f"ðŸ“‹ Havola: {share_link}", show_alert=True)
    
    # ========== SERTIFIKAT RASM YARATISH ==========
    @router.callback_query(F.data.startswith("cert_image_"))
    async def handle_certificate_image(callback: CallbackQuery):
        """Sertifikat rasmini yaratish va yuborish"""
        cert_id = callback.data.replace("cert_image_", "")
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        await callback.answer("â³ Sertifikat yaratilmoqda...")
        
        # Sertifikat ma'lumotlarini olish
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT qc.score, qc.grade, qc.issued_at, q.title, q.total_questions
                FROM quiz_certificates qc
                JOIN quizzes q ON qc.quiz_id = q.id
                WHERE qc.certificate_id = ? AND qc.user_id = ?
            ''', (cert_id, user_id))
            cert = await cursor.fetchone()
        
        if not cert:
            await callback.message.answer("âŒ Sertifikat topilmadi!")
            return
        
        score, grade, issued_at, quiz_title, total_questions = cert
        
        # Sertifikat rasmini yaratish
        img_bytes = await generate_certificate_image(
            user_name=user.get('full_name', 'Foydalanuvchi'),
            quiz_title=quiz_title,
            score=int(score * total_questions / 100),
            total=total_questions,
            date_str=issued_at[:10] if issued_at else datetime.now().strftime('%Y-%m-%d'),
            certificate_id=cert_id
        )
        
        if img_bytes:
            from aiogram.types import BufferedInputFile
            photo = BufferedInputFile(img_bytes.read(), filename=f"certificate_{cert_id}.png")
            
            await callback.message.answer_photo(
                photo=photo,
                caption=f"ðŸŽ“ <b>SERTIFIKAT</b>\n\n"
                        f"ðŸ‘¤ {user.get('full_name', 'Foydalanuvchi')}\n"
                        f"ðŸ“ {quiz_title}\n"
                        f"ðŸ† {score}% | {grade}\n"
                        f"ðŸ†” <code>{cert_id}</code>",
                parse_mode=ParseMode.HTML
            )
        else:
            await callback.message.answer("âŒ Sertifikat rasmini yaratishda xatolik. PIL kutubxonasini o'rnating: pip install Pillow")
    
    # ========== PODCAST MODE HANDLERS ==========
    @router.callback_query(F.data == "quiz_podcast")
    async def handle_podcast_menu(callback: CallbackQuery):
        """Podcast Mode menyusi"""
        text = """
ðŸŽ§ <b>PODCAST MODE</b>

<b>Nima bu?</b>
Mavzuni o'qish o'rniga, 2 ta AI personaj (Ustoz va Shogird) 
o'rtasidagi qiziqarli dialogni eshiting!

<b>Qanday ishlaydi:</b>
1. Mavzu kiriting
2. AI dialog yaratadi
3. Ovozli podcast oling

<b>Afzalliklari:</b>
â€¢ Yo'lda ketayotib o'rganing
â€¢ Quloq orqali eslab qoling
â€¢ Qiziqarli format

Mavzuni kiriting yoki fayl yuklang:
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“ Mavzu kiritish", callback_data="podcast_topic")
        builder.button(text="ðŸ“„ Fayldan podcast", callback_data="podcast_file")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "podcast_topic")
    async def handle_podcast_topic(callback: CallbackQuery, state: FSMContext):
        """Podcast uchun mavzu kiritish"""
        text = """
ðŸŽ§ <b>PODCAST YARATISH</b>

Mavzuni kiriting:
<i>Masalan: "Fotosintez jarayoni", "Python dasturlash asoslari"</i>
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_podcast"))
        await state.set_state(UserStates.waiting_podcast_topic)
        await callback.answer()
    
    @router.message(UserStates.waiting_podcast_topic)
    async def handle_podcast_topic_input(message: Message, state: FSMContext):
        """Podcast mavzusi kiritilgandan keyin"""
        topic = message.text.strip()
        user_id = message.from_user.id
        
        if len(topic) < 3:
            await message.answer("âŒ Mavzu juda qisqa. Kamida 3 ta belgi kiriting.")
            return
        
        await message.answer("â³ Podcast yaratilmoqda... (30-60 soniya)")
        
        # Dialog yaratish
        podcast_data = await generate_podcast_dialog(topic)
        
        if not podcast_data:
            await message.answer("âŒ Podcast yaratishda xatolik. Keyinroq urinib ko'ring.")
            await state.clear()
            return
        
        # Dialogni matn sifatida ko'rsatish
        dialogs = podcast_data.get('dialogs', [])
        text = f"ðŸŽ§ <b>{podcast_data.get('title', topic)}</b>\n\n"
        
        for dialog in dialogs:
            speaker = dialog.get('speaker', 'USTOZ')
            dialog_text = dialog.get('text', '')
            icon = "ðŸ‘¨â€ðŸ«" if speaker == "USTOZ" else "ðŸ§‘â€ðŸŽ“"
            text += f"{icon} <b>{speaker}:</b> {dialog_text}\n\n"
        
        # State'ga saqlash
        await state.update_data(podcast_data=podcast_data, podcast_topic=topic)
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”Š Ovozli podcast olish", callback_data="podcast_audio")
        builder.button(text="ðŸŽ¯ Bu mavzudan test", callback_data="podcast_to_quiz")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    @router.callback_query(F.data == "podcast_audio")
    async def handle_podcast_audio(callback: CallbackQuery, state: FSMContext):
        """Podcast audio yaratish"""
        data = await state.get_data()
        podcast_data = data.get('podcast_data')
        
        if not podcast_data:
            await callback.answer("âŒ Podcast ma'lumotlari topilmadi!")
            return
        
        await callback.answer("â³ Audio yaratilmoqda... (1-2 daqiqa)")
        
        dialogs = podcast_data.get('dialogs', [])
        
        # Har bir dialog uchun audio yaratish
        audio_files = []
        for i, dialog in enumerate(dialogs):
            speaker = dialog.get('speaker', 'USTOZ')
            text = dialog.get('text', '')
            
            # Ustoz uchun "onyx" (erkak), Shogird uchun "nova" (ayol) ovozi
            voice = "onyx" if speaker == "USTOZ" else "nova"
            
            audio = await text_to_speech(text, voice)
            if audio:
                audio_files.append((speaker, audio))
        
        if not audio_files:
            await callback.message.answer("âŒ Audio yaratishda xatolik. OpenAI TTS xizmati mavjud emasligini tekshiring.")
            return
        
        # Har bir audio faylni yuborish
        from aiogram.types import BufferedInputFile
        
        for i, (speaker, audio_bytes) in enumerate(audio_files):
            icon = "ðŸ‘¨â€ðŸ«" if speaker == "USTOZ" else "ðŸ§‘â€ðŸŽ“"
            audio_file = BufferedInputFile(audio_bytes.read(), filename=f"podcast_part_{i+1}.mp3")
            
            await callback.message.answer_audio(
                audio=audio_file,
                caption=f"{icon} <b>{speaker}</b> - Qism {i+1}",
                parse_mode=ParseMode.HTML
            )
        
        await callback.message.answer(
            "âœ… <b>Podcast tayyor!</b>\n\nBarcha qismlarni eshiting va mavzuni o'rganing!",
            reply_markup=Keyboards.back_button("quiz_menu"),
            parse_mode=ParseMode.HTML
        )
        await state.clear()
    
    @router.callback_query(F.data == "podcast_to_quiz")
    async def handle_podcast_to_quiz(callback: CallbackQuery, state: FSMContext):
        """Podcast mavzusidan test yaratish"""
        data = await state.get_data()
        topic = data.get('podcast_topic', '')
        
        if not topic:
            await callback.answer("âŒ Mavzu topilmadi!")
            return
        
        await state.update_data(quiz_topic=topic)
        
        text = f"""
ðŸ“š <b>Mavzu:</b> {topic}

Qiyinlik darajasini tanlang:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_difficulty_menu())
        await state.set_state(UserStates.waiting_quiz_difficulty)
        await callback.answer()
    
    # ========== AI TUTOR - XATO TUSHUNTIRISH ==========
    @router.callback_query(F.data.startswith("explain_mistake_"))
    async def handle_explain_mistake(callback: CallbackQuery):
        """Xatoni AI orqali tushuntirish"""
        mistake_id = int(callback.data.replace("explain_mistake_", ""))
        user_id = callback.from_user.id
        
        await callback.answer("â³ AI tushuntirish tayyorlanmoqda...")
        
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT qm.question_text, qm.correct_answer, qm.user_answer, q.title
                FROM quiz_mistakes qm
                JOIN quizzes q ON qm.quiz_id = q.id
                WHERE qm.id = ? AND qm.user_id = ?
            ''', (mistake_id, user_id))
            mistake = await cursor.fetchone()
        
        if not mistake:
            await callback.message.answer("âŒ Xato topilmadi!")
            return
        
        question, correct, user_answer, topic = mistake
        
        # AI tushuntirish olish
        explanation = await explain_wrong_answer(question, user_answer, correct, topic)
        
        text = f"""
ðŸ§  <b>AI TUTOR TUSHUNTIRISHI</b>

â“ <b>Savol:</b>
{question}

âŒ <b>Sizning javobingiz:</b> {user_answer}
âœ… <b>To'g'ri javob:</b> {correct}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“š <b>TUSHUNTIRISH:</b>

{explanation}
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Tushundim", callback_data=f"resolve_mistake_{mistake_id}")
        builder.button(text="ðŸ”™ Xatolarim", callback_data="quiz_mistakes")
        builder.adjust(1)
        
        await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    @router.callback_query(F.data.startswith("resolve_mistake_"))
    async def handle_resolve_mistake(callback: CallbackQuery):
        """Xatoni hal qilingan deb belgilash"""
        mistake_id = int(callback.data.replace("resolve_mistake_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            await conn.execute('UPDATE quiz_mistakes SET is_resolved = 1 WHERE id = ? AND user_id = ?', (mistake_id, user_id))
            await conn.commit()
        
        await callback.answer("âœ… Xato hal qilindi!")
        
        # Xatolar ro'yxatiga qaytish
        await handle_quiz_mistakes(callback)
    
    # ========== RPG TIZIMI HANDLERS ==========
    @router.callback_query(F.data == "quiz_rpg")
    async def handle_rpg_menu(callback: CallbackQuery):
        """RPG tizimi menyusi"""
        user_id = callback.from_user.id
        user = await db.get_user(user_id)
        
        if not user:
            await callback.answer("âŒ Foydalanuvchi topilmadi!")
            return
        
        # RPG ma'lumotlarini olish
        xp = user.get('xp', 0)
        rpg = calculate_rpg_level(xp)
        
        # Oltin va Hint olish
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT gold, hints, fifty_fifty FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            gold = row[0] if row else 0
            hints = row[1] if row else 0
            fifty_fifty = row[2] if row else 0
        
        progress_bar = "â–ˆ" * int(rpg['progress'] // 10) + "â–‘" * (10 - int(rpg['progress'] // 10))
        
        text = f"""
ðŸ§›â€â™‚ï¸ <b>BILIM OVCHISI - RPG TIZIMI</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{rpg['icon']} <b>DARAJA {rpg['level']}: {rpg['name']}</b>

ðŸ’° <b>XP:</b> {xp:,}
ðŸª™ <b>Oltin:</b> {gold}

<b>Progress:</b> [{progress_bar}] {rpg['progress']:.0f}%
<b>Keyingi daraja:</b> {rpg['next_level']} ({rpg['next_xp']:,} XP)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸŽ’ <b>INVENTAR:</b>
ðŸ’¡ Maslahat (Hint): {hints} ta
ðŸŽ¯ 50/50: {fifty_fifty} ta

ðŸ›’ <b>DO'KON:</b>
â€¢ ðŸ’¡ Hint: 50 Oltin
â€¢ ðŸŽ¯ 50/50: 100 Oltin

<b>Qanday ishlaydi:</b>
â€¢ Test ishlang va XP/Oltin yig'ing
â€¢ Oltinlarga Hint va 50/50 sotib oling
â€¢ Darajangizni oshiring va yangi unvonlar oling!
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ’¡ Hint sotib olish (50 ðŸª™)", callback_data="buy_hint")
        builder.button(text="ðŸŽ¯ 50/50 sotib olish (100 ðŸª™)", callback_data="buy_fifty")
        builder.button(text="ðŸ† Reyting", callback_data="quiz_leaderboard")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "buy_hint")
    async def handle_buy_hint(callback: CallbackQuery):
        """Hint sotib olish"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT gold, hints FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            
            if not row:
                await callback.answer("âŒ Ma'lumotlar topilmadi!")
                return
            
            gold, hints = row
            
            if gold < 50:
                await callback.answer(f"âŒ Yetarli oltin yo'q! Sizda: {gold} ðŸª™", show_alert=True)
                return
            
            await conn.execute('UPDATE quiz_streaks SET gold = gold - 50, hints = hints + 1 WHERE user_id = ?', (user_id,))
            await conn.commit()
        
        await callback.answer("âœ… 1 ta Hint sotib olindi!")
        await handle_rpg_menu(callback)
    
    @router.callback_query(F.data == "buy_fifty")
    async def handle_buy_fifty(callback: CallbackQuery):
        """50/50 sotib olish"""
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT gold, fifty_fifty FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            
            if not row:
                await callback.answer("âŒ Ma'lumotlar topilmadi!")
                return
            
            gold, fifty = row
            
            if gold < 100:
                await callback.answer(f"âŒ Yetarli oltin yo'q! Sizda: {gold} ðŸª™", show_alert=True)
                return
            
            await conn.execute('UPDATE quiz_streaks SET gold = gold - 100, fifty_fifty = fifty_fifty + 1 WHERE user_id = ?', (user_id,))
            await conn.commit()
        
        await callback.answer("âœ… 1 ta 50/50 sotib olindi!")
        await handle_rpg_menu(callback)
    
    # ========== HINT VA 50/50 ISHLATISH ==========
    @router.callback_query(F.data.startswith("use_hint_"))
    async def handle_use_hint(callback: CallbackQuery, state: FSMContext):
        """Hint ishlatish - to'g'ri javobni ko'rsatish"""
        question_index = int(callback.data.replace("use_hint_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT hints FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            
            if not row or row[0] < 1:
                await callback.answer("âŒ Hint yo'q! RPG menyusidan sotib oling.", show_alert=True)
                return
            
            await conn.execute('UPDATE quiz_streaks SET hints = hints - 1 WHERE user_id = ?', (user_id,))
            await conn.commit()
        
        data = await state.get_data()
        questions = data.get('current_questions', [])
        
        if question_index >= len(questions):
            await callback.answer("âŒ Savol topilmadi!")
            return
        
        question = questions[question_index]
        correct_idx = question.get('correct', 0)
        correct_answer = question['options'][correct_idx]
        
        await callback.answer(f"ðŸ’¡ To'g'ri javob: {correct_answer}", show_alert=True)
    
    @router.callback_query(F.data.startswith("use_fifty_"))
    async def handle_use_fifty(callback: CallbackQuery, state: FSMContext):
        """50/50 ishlatish - 2 ta noto'g'ri javobni olib tashlash"""
        question_index = int(callback.data.replace("use_fifty_", ""))
        user_id = callback.from_user.id
        
        async with db.connect() as conn:
            cursor = await conn.execute('SELECT fifty_fifty FROM quiz_streaks WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            
            if not row or row[0] < 1:
                await callback.answer("âŒ 50/50 yo'q! RPG menyusidan sotib oling.", show_alert=True)
                return
            
            await conn.execute('UPDATE quiz_streaks SET fifty_fifty = fifty_fifty - 1 WHERE user_id = ?', (user_id,))
            await conn.commit()
        
        data = await state.get_data()
        questions = data.get('current_questions', [])
        
        if question_index >= len(questions):
            await callback.answer("âŒ Savol topilmadi!")
            return
        
        question = questions[question_index]
        correct_idx = question.get('correct', 0)
        options = question['options']
        
        # 2 ta noto'g'ri javobni topish
        wrong_indices = [i for i in range(len(options)) if i != correct_idx]
        removed = random.sample(wrong_indices, min(2, len(wrong_indices)))
        
        # Qolgan variantlarni ko'rsatish
        remaining_text = ""
        for i, opt in enumerate(options):
            if i in removed:
                remaining_text += f"âŒ {opt}\n"
            elif i == correct_idx:
                remaining_text += f"âœ… {opt}\n"
            else:
                remaining_text += f"â€¢ {opt}\n"
        
        await callback.answer(f"ðŸŽ¯ 2 ta noto'g'ri javob olib tashlandi!", show_alert=True)
    
    # ========== ADAPTIVE QUIZ ==========
    @router.callback_query(F.data == "quiz_adaptive")
    async def handle_adaptive_quiz(callback: CallbackQuery, state: FSMContext):
        """Adaptive (moslashuvchan) test boshlash"""
        text = """
ðŸ“ˆ <b>ADAPTIVE TEST</b>

<b>Nima bu?</b>
Qiyinlik sizning javoblaringizga qarab o'zgaradi!

â€¢ To'g'ri javob = Qiyinroq savol
â€¢ Noto'g'ri javob = Osonroq savol + Tushuntirish

<b>Maqsad:</b>
Sizni "Flow" holatida ushlab turish - 
juda oson ham emas, juda qiyin ham emas.

Mavzuni kiriting:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_menu"))
        await state.set_state(UserStates.waiting_adaptive_topic)
        await callback.answer()
    
    @router.message(UserStates.waiting_adaptive_topic)
    async def handle_adaptive_topic(message: Message, state: FSMContext):
        """Adaptive test mavzusi"""
        topic = message.text.strip()
        
        if len(topic) < 3:
            await message.answer("âŒ Mavzu juda qisqa.")
            return
        
        await state.update_data(
            adaptive_topic=topic,
            adaptive_difficulty="medium",
            consecutive_correct=0,
            consecutive_wrong=0,
            adaptive_score=0,
            adaptive_total=0
        )
        
        await message.answer("â³ Adaptive test yaratilmoqda...")
        
        # Birinchi savol (o'rta qiyinlik)
        quiz_data = await generate_quiz_with_ai(topic, "medium", 1)
        
        if not quiz_data or not quiz_data.get('questions'):
            await message.answer("âŒ Test yaratishda xatolik.")
            await state.clear()
            return
        
        question = quiz_data['questions'][0]
        await state.update_data(current_adaptive_question=question)
        
        text = f"""
ðŸ“ˆ <b>ADAPTIVE TEST</b>
<b>Mavzu:</b> {topic}
<b>Qiyinlik:</b> ðŸŸ¡ O'rta

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{question['question']}
        """
        
        await message.answer(text, reply_markup=Keyboards.quiz_answer_keyboard(question['options'], 0, adaptive=True), parse_mode=ParseMode.HTML)
        await state.set_state(UserStates.waiting_adaptive_answer)
    
    @router.callback_query(F.data.startswith("adaptive_ans_"))
    async def handle_adaptive_answer(callback: CallbackQuery, state: FSMContext):
        """Adaptive test javobini qayta ishlash"""
        parts = callback.data.replace("adaptive_ans_", "").split("_")
        question_index = int(parts[0])
        answer_index = int(parts[1])
        user_id = callback.from_user.id
        
        data = await state.get_data()
        question = data.get('current_adaptive_question')
        topic = data.get('adaptive_topic', '')
        current_difficulty = data.get('adaptive_difficulty', 'medium')
        consecutive_correct = data.get('consecutive_correct', 0)
        consecutive_wrong = data.get('consecutive_wrong', 0)
        adaptive_score = data.get('adaptive_score', 0)
        adaptive_total = data.get('adaptive_total', 0)
        
        if not question:
            await callback.answer("âŒ Savol topilmadi!")
            return
        
        correct_idx = question.get('correct', 0)
        is_correct = answer_index == correct_idx
        
        adaptive_total += 1
        
        if is_correct:
            adaptive_score += 1
            consecutive_correct += 1
            consecutive_wrong = 0
            result_text = "âœ… <b>To'g'ri!</b>"
        else:
            consecutive_wrong += 1
            consecutive_correct = 0
            correct_answer = question['options'][correct_idx]
            user_answer = question['options'][answer_index]
            
            # AI tushuntirish olish
            explanation = await explain_wrong_answer(question['question'], user_answer, correct_answer, topic)
            result_text = f"âŒ <b>Noto'g'ri!</b>\n\nâœ… To'g'ri javob: {correct_answer}\n\nðŸ“š <b>Tushuntirish:</b>\n{explanation}"
        
        # Keyingi qiyinlikni aniqlash
        new_difficulty = get_next_difficulty(current_difficulty, is_correct, consecutive_correct, consecutive_wrong)
        
        diff_icons = {"easy": "ðŸŸ¢ Oson", "medium": "ðŸŸ¡ O'rta", "hard": "ðŸ”´ Qiyin"}
        
        # 10 ta savoldan keyin tugatish
        if adaptive_total >= 10:
            percentage = int((adaptive_score / adaptive_total) * 100)
            xp_earned = adaptive_score * 15  # Adaptive test uchun ko'proq XP
            
            # XP qo'shish
            async with db.connect() as conn:
                await conn.execute('UPDATE users SET xp = xp + ? WHERE user_id = ?', (xp_earned, user_id))
                await conn.commit()
            
            text = f"""
ðŸŽ‰ <b>ADAPTIVE TEST TUGADI!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š <b>NATIJA:</b> {percentage}%
âœ… To'g'ri: {adaptive_score}/{adaptive_total}

ðŸ’° <b>XP:</b> +{xp_earned} XP

<b>Qiyinlik o'zgarishi:</b>
Boshlanish: ðŸŸ¡ O'rta
Tugash: {diff_icons.get(new_difficulty, "ðŸŸ¡ O'rta")}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{"ðŸ† Ajoyib natija!" if percentage >= 80 else "ðŸ“š Ko'proq mashq qiling!"}
            """
            
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸ” Qayta boshlash", callback_data="quiz_adaptive")
            builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
            builder.adjust(1)
            
            await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            await state.clear()
            await callback.answer()
            return
        
        # State yangilash
        await state.update_data(
            adaptive_difficulty=new_difficulty,
            consecutive_correct=consecutive_correct,
            consecutive_wrong=consecutive_wrong,
            adaptive_score=adaptive_score,
            adaptive_total=adaptive_total
        )
        
        await callback.answer("âœ… To'g'ri!" if is_correct else "âŒ Noto'g'ri!")
        
        # Keyingi savol yaratish
        await callback.message.edit_text(f"{result_text}\n\nâ³ Keyingi savol yaratilmoqda...", parse_mode=ParseMode.HTML)
        
        quiz_data = await generate_quiz_with_ai(topic, new_difficulty, 1)
        
        if not quiz_data or not quiz_data.get('questions'):
            await callback.message.edit_text("âŒ Keyingi savol yaratishda xatolik.", reply_markup=Keyboards.back_button("quiz_menu"))
            await state.clear()
            return
        
        next_question = quiz_data['questions'][0]
        await state.update_data(current_adaptive_question=next_question)
        
        text = f"""
{result_text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ˆ <b>ADAPTIVE TEST</b>
<b>Savol:</b> {adaptive_total + 1}/10
<b>Ball:</b> {adaptive_score}/{adaptive_total}
<b>Qiyinlik:</b> {diff_icons.get(new_difficulty, "ðŸŸ¡ O'rta")}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{next_question['question']}
        """
        
        await callback.message.edit_text(text, reply_markup=Keyboards.quiz_answer_keyboard(next_question['options'], adaptive_total, adaptive=True), parse_mode=ParseMode.HTML)
    
    # ========== LIVE BATTLE (TELEGRAM NATIVE QUIZ) ==========
    # Live Battle jadvali - Telegram poll quiz ishlatadi
    live_battles = {}  # {battle_id: {quiz_id, questions, scores, current_question, participants, timer, use_user_quiz}}
    
    # Credit tizimi: Free=5/kun, Premium=20/kun (100 savol), Pro=cheksiz
    # max_quizzes_total: Jami nechta test yaratishi mumkin (Free=2, Premium/Pro=cheksiz)
    # max_questions_per_quiz: Har bir testda maksimal savol soni
    QUIZ_CREDITS = {
        0: {"daily_credits": 5, "max_questions": 10, "max_questions_per_quiz": 20, "max_quizzes_total": 2, "name": "Free"},
        1: {"daily_credits": 10, "max_questions": 20, "max_questions_per_quiz": 30, "max_quizzes_total": 5, "name": "Trial"},
        2: {"daily_credits": 20, "max_questions": 100, "max_questions_per_quiz": 100, "max_quizzes_total": 999, "name": "Premium"},
        3: {"daily_credits": 999, "max_questions": 999, "max_questions_per_quiz": 999, "max_quizzes_total": 999, "name": "Pro"}  # Cheksiz
    }
    
    async def get_user_quiz_creation_limits(user_id: int) -> dict:
        """Foydalanuvchi test yaratish limitlarini olish"""
        async with db.connect() as conn:
            # Subscription type
            cursor = await conn.execute('SELECT subscription_type FROM users WHERE user_id = ?', (user_id,))
            row = await cursor.fetchone()
            sub_type = row[0] if row else 0
            
            # Foydalanuvchi yaratgan testlar soni
            cursor = await conn.execute('SELECT COUNT(*) FROM quizzes WHERE user_id = ?', (user_id,))
            count_row = await cursor.fetchone()
            created_count = count_row[0] if count_row else 0
            
            tier_info = QUIZ_CREDITS.get(sub_type, QUIZ_CREDITS[0])
            max_quizzes = tier_info["max_quizzes_total"]
            max_questions = tier_info["max_questions_per_quiz"]
            
            return {
                "created_count": created_count,
                "max_quizzes": max_quizzes,
                "remaining": max(0, max_quizzes - created_count),
                "max_questions_per_quiz": max_questions,
                "tier": tier_info["name"],
                "sub_type": sub_type,
                "can_create": created_count < max_quizzes or max_quizzes >= 999
            }
    
    async def get_user_quiz_credits(user_id: int) -> dict:
        """Foydalanuvchi quiz creditlarini olish"""
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT subscription_type, 
                       COALESCE(quiz_credits_used_today, 0) as used,
                       COALESCE(quiz_credits_date, date('now')) as credit_date
                FROM users WHERE user_id = ?
            ''', (user_id,))
            row = await cursor.fetchone()
            
            if not row:
                return {"remaining": 0, "max": 5, "tier": "Free"}
            
            sub_type = row[0] or 0
            used_today = row[1] or 0
            credit_date = row[2]
            
            # Yangi kun bo'lsa, creditlarni yangilash
            today = datetime.now().strftime('%Y-%m-%d')
            if credit_date != today:
                await conn.execute('''
                    UPDATE users SET quiz_credits_used_today = 0, quiz_credits_date = ? WHERE user_id = ?
                ''', (today, user_id))
                await conn.commit()
                used_today = 0
            
            tier_info = QUIZ_CREDITS.get(sub_type, QUIZ_CREDITS[0])
            remaining = max(0, tier_info["daily_credits"] - used_today)
            
            return {
                "remaining": remaining,
                "max": tier_info["daily_credits"],
                "max_questions": tier_info["max_questions"],
                "tier": tier_info["name"],
                "sub_type": sub_type
            }
    
    async def use_quiz_credit(user_id: int) -> bool:
        """Quiz credit ishlatish"""
        credits = await get_user_quiz_credits(user_id)
        if credits["remaining"] <= 0:
            return False
        
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE users SET quiz_credits_used_today = COALESCE(quiz_credits_used_today, 0) + 1 WHERE user_id = ?
            ''', (user_id,))
            await conn.commit()
        return True
    
    # ========== MIND MAP GENERATOR ==========
    @router.callback_query(F.data == "quiz_mindmap")
    async def handle_mindmap_menu(callback: CallbackQuery, state: FSMContext):
        """Mind Map yaratish menyusi"""
        text = """
ðŸ§  <b>MIND MAP GENERATOR</b>

<b>Nima bu?</b>
Mavzuni vizual sxema (aql xaritasi) ko'rinishida ko'ring!

<b>Qanday ishlaydi:</b>
1. Mavzu kiriting yoki fayl yuklang
2. AI asosiy tushunchalarni ajratadi
3. Vizual sxema yaratiladi

<b>Afzalliklari:</b>
â€¢ Murakkab mavzularni oson tushunish
â€¢ "Katta rasm"ni ko'rish
â€¢ Xotirada yaxshi saqlanadi

Mavzuni kiriting:
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“ Mavzu kiritish", callback_data="mindmap_topic")
        builder.button(text="ðŸ“„ Fayldan", callback_data="mindmap_file")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await safe_edit_text(callback, text, reply_markup=builder.as_markup())
        await callback.answer()
    
    @router.callback_query(F.data == "mindmap_topic")
    async def handle_mindmap_topic(callback: CallbackQuery, state: FSMContext):
        """Mind Map uchun mavzu kiritish"""
        text = """
ðŸ§  <b>MIND MAP YARATISH</b>

Mavzuni kiriting:
<i>Masalan: "Fotosintez", "Python OOP", "Ikkinchi jahon urushi"</i>
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.back_button("quiz_mindmap"))
        await state.set_state(UserStates.waiting_mindmap_topic)
        await callback.answer()
    
    @router.message(UserStates.waiting_mindmap_topic)
    async def handle_mindmap_topic_input(message: Message, state: FSMContext):
        """Mind Map mavzusi kiritilgandan keyin"""
        topic = message.text.strip()
        
        if len(topic) < 3:
            await message.answer("âŒ Mavzu juda qisqa.")
            return
        
        await message.answer("â³ Mind Map yaratilmoqda...")
        
        # AI orqali tushunchalarni olish
        mindmap_data = await generate_mindmap_data(topic)
        
        if not mindmap_data:
            await message.answer("âŒ Mind Map yaratishda xatolik.")
            await state.clear()
            return
        
        # Matnli Mind Map ko'rsatish
        text = f"ðŸ§  <b>MIND MAP: {topic}</b>\n\n"
        
        central = mindmap_data.get('central', topic)
        branches = mindmap_data.get('branches', [])
        
        text += f"ðŸŽ¯ <b>{central}</b>\n"
        text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        
        for i, branch in enumerate(branches):
            branch_name = branch.get('name', '')
            sub_items = branch.get('items', [])
            
            text += f"ðŸ“Œ <b>{branch_name}</b>\n"
            for item in sub_items:
                text += f"   â€¢ {item}\n"
            text += "\n"
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸŽ¯ Bu mavzudan test", callback_data="mindmap_to_quiz")
        builder.button(text="ðŸŽ§ Podcast yaratish", callback_data="mindmap_to_podcast")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await state.update_data(mindmap_topic=topic, mindmap_data=mindmap_data)
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    @router.callback_query(F.data == "mindmap_to_quiz")
    async def handle_mindmap_to_quiz(callback: CallbackQuery, state: FSMContext):
        """Mind Map mavzusidan test yaratish"""
        data = await state.get_data()
        topic = data.get('mindmap_topic', '')
        
        if not topic:
            await callback.answer("âŒ Mavzu topilmadi!")
            return
        
        await state.update_data(quiz_topic=topic)
        
        text = f"""
ðŸ“š <b>Mavzu:</b> {topic}

Qiyinlik darajasini tanlang:
        """
        await safe_edit_text(callback, text, reply_markup=Keyboards.quiz_difficulty_menu())
        await state.set_state(UserStates.waiting_quiz_difficulty)
        await callback.answer()
    
    @router.callback_query(F.data == "mindmap_to_podcast")
    async def handle_mindmap_to_podcast(callback: CallbackQuery, state: FSMContext):
        """Mind Map mavzusidan podcast yaratish"""
        data = await state.get_data()
        topic = data.get('mindmap_topic', '')
        
        if not topic:
            await callback.answer("âŒ Mavzu topilmadi!")
            return
        
        await callback.answer("â³ Podcast yaratilmoqda...")
        
        # Dialog yaratish
        podcast_data = await generate_podcast_dialog(topic)
        
        if not podcast_data:
            await callback.message.answer("âŒ Podcast yaratishda xatolik.")
            return
        
        # Dialogni matn sifatida ko'rsatish
        dialogs = podcast_data.get('dialogs', [])
        text = f"ðŸŽ§ <b>{podcast_data.get('title', topic)}</b>\n\n"
        
        for dialog in dialogs:
            speaker = dialog.get('speaker', 'USTOZ')
            dialog_text = dialog.get('text', '')
            icon = "ðŸ‘¨â€ðŸ«" if speaker == "USTOZ" else "ðŸ§‘â€ðŸŽ“"
            text += f"{icon} <b>{speaker}:</b> {dialog_text}\n\n"
        
        await state.update_data(podcast_data=podcast_data, podcast_topic=topic)
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ”Š Ovozli podcast olish", callback_data="podcast_audio")
        builder.button(text="ðŸ”™ Quiz menyu", callback_data="quiz_menu")
        builder.adjust(1)
        
        await callback.message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    # ========== GURUHDA COMMANDLAR ==========
    @router.message(Command("quiz"))
    async def handle_group_quiz_command(message: Message):
        """Guruhda /quiz komandasi"""
        user_id = message.from_user.id
        
        if message.chat.type in ["group", "supergroup"]:
            bot_info = await message.bot.get_me()
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸŽ¯ Test boshlash", url=f"https://t.me/{bot_info.username}?start=quiz_menu")
            builder.button(text="âš¡ Live Battle", callback_data="start_group_battle")
            builder.adjust(1)
            
            await message.answer(
                "ðŸŽ¯ <b>AI QUIZ</b>\n\n"
                "ðŸ“± Shaxsiy test uchun botga o'ting\n"
                "âš¡ Guruhda Live Battle o'ynang!",
                reply_markup=builder.as_markup(),
                parse_mode=ParseMode.HTML
            )
        else:
            # Shaxsiy chatda quiz menyu
            streak = 0
            try:
                async with db.connect() as conn:
                    cursor = await conn.execute('SELECT streak FROM quiz_streaks WHERE user_id = ?', (user_id,))
                    row = await cursor.fetchone()
                    if row:
                        streak = row[0] or 0
            except:
                pass
            await message.answer("ðŸŽ¯ <b>AI QUIZ</b>", reply_markup=Keyboards.quiz_menu(user_id, streak), parse_mode=ParseMode.HTML)
    
    @router.message(Command("book"))
    async def handle_group_book_command(message: Message):
        """Guruhda /book komandasi - kitob qidirish"""
        user_id = message.from_user.id
        args = message.text.split(maxsplit=1)
        
        if len(args) < 2:
            if message.chat.type in ["group", "supergroup"]:
                bot_info = await message.bot.get_me()
                builder = InlineKeyboardBuilder()
                builder.button(text="ðŸ“š Kutubxonaga o'tish", url=f"https://t.me/{bot_info.username}?start=library")
                await message.answer(
                    "ðŸ“š <b>KUTUBXONA</b>\n\n"
                    "Kitob qidirish: /book [kitob nomi]\n"
                    "Masalan: /book Alximik",
                    reply_markup=builder.as_markup(),
                    parse_mode=ParseMode.HTML
                )
            else:
                await message.answer("ðŸ“š Kitob nomini kiriting: /book [kitob nomi]")
            return
        
        search_query = args[1].strip()
        
        # Kitoblarni qidirish (caption = title)
        async with db.connect() as conn:
            cursor = await conn.execute('''
                SELECT id, caption, author, genre FROM books 
                WHERE caption LIKE ? OR author LIKE ?
                LIMIT 5
            ''', (f'%{search_query}%', f'%{search_query}%'))
            books = await cursor.fetchall()
        
        if not books:
            await message.answer(f"âŒ '{search_query}' bo'yicha kitob topilmadi")
            return
        
        bot_info = await message.bot.get_me()
        text = f"ðŸ“š <b>'{search_query}' bo'yicha natijalar:</b>\n\n"
        builder = InlineKeyboardBuilder()
        
        for book_id, caption, author, genre in books:
            title = caption or 'Nomsiz kitob'
            text += f"ðŸ“– <b>{title}</b>\nðŸ‘¤ {author or 'Noma`lum'}\n\n"
            builder.button(text=f"ðŸ“– {title[:30]}", url=f"https://t.me/{bot_info.username}?start=book_{book_id}")
        
        builder.adjust(1)
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    
    @router.message(Command("share"))
    async def handle_group_share_command(message: Message):
        """Guruhda /share komandasi - testni ulashish"""
        user_id = message.from_user.id
        args = message.text.split(maxsplit=1)
        
        if len(args) < 2:
            # Foydalanuvchi testlarini ko'rsatish
            async with db.connect() as conn:
                cursor = await conn.execute('''
                    SELECT id, title, total_questions FROM quizzes 
                    WHERE user_id = ? 
                    ORDER BY created_at DESC LIMIT 5
                ''', (user_id,))
                quizzes = await cursor.fetchall()
            
            if not quizzes:
                await message.answer("âŒ Sizda hali testlar yo'q. Avval test yarating!")
                return
            
            bot_info = await message.bot.get_me()
            text = "ðŸ“¤ <b>TESTLARINGIZ:</b>\n\n"
            
            for qid, title, total in quizzes:
                share_link = f"https://t.me/{bot_info.username}?start=quiz_{qid}"
                text += f"ðŸ“ <b>{title}</b> ({total} savol)\nðŸ”— <code>{share_link}</code>\n\n"
            
            await message.answer(text, parse_mode=ParseMode.HTML)
        else:
            # Test ID bo'yicha ulashish
            quiz_id = args[1].strip()
            bot_info = await message.bot.get_me()
            share_link = f"https://t.me/{bot_info.username}?start=quiz_{quiz_id}"
            await message.answer(f"ðŸ”— Test havolasi:\n<code>{share_link}</code>", parse_mode=ParseMode.HTML)
    
    # ========== INLINE MODE ==========
    from aiogram.types import InlineQuery, InlineQueryResultArticle, InputTextMessageContent
    
    @router.inline_query()
    async def handle_inline_query(inline_query: InlineQuery):
        """Inline mode - kitob, kino, kurs, test qidirish"""
        query = inline_query.query.strip().lower()
        user_id = inline_query.from_user.id
        results = []
        
        bot_info = await inline_query.bot.get_me()
        bot_username = bot_info.username
        
        if not query:
            # Bo'sh query - yordam ko'rsatish
            results.append(InlineQueryResultArticle(
                id="help",
                title="ðŸ” Qidirish bo'yicha yordam",
                description="kitob:, test: bilan qidiring",
                input_message_content=InputTextMessageContent(
                    message_text="ðŸ” <b>Inline qidirish:</b>\n\n"
                    "ðŸ“š <code>@{} kitob:Alximik</code>\n"
                    "ðŸ“ <code>@{} test:Matematika</code>".format(bot_username, bot_username),
                    parse_mode=ParseMode.HTML
                )
            ))
        elif query.startswith("kitob:") or query.startswith("book:"):
            # Kitob qidirish
            search = query.replace("kitob:", "").replace("book:", "").strip()
            if search:
                async with db.connect() as conn:
                    cursor = await conn.execute('''
                        SELECT id, title, author, genre FROM books 
                        WHERE title LIKE ? OR author LIKE ?
                        LIMIT 10
                    ''', (f'%{search}%', f'%{search}%'))
                    books = await cursor.fetchall()
                
                for book_id, title, author, genre in books:
                    share_link = f"https://t.me/{bot_username}?start=book_{book_id}"
                    results.append(InlineQueryResultArticle(
                        id=f"book_{book_id}",
                        title=f"ðŸ“š {title}",
                        description=f"ðŸ‘¤ {author or 'Noma`lum'} | ðŸ“‚ {genre or ''}",
                        input_message_content=InputTextMessageContent(
                            message_text=f"ðŸ“š <b>{title}</b>\nðŸ‘¤ Muallif: {author or 'Noma`lum'}\nðŸ“‚ Janr: {genre or ''}\n\nðŸ”— {share_link}",
                            parse_mode=ParseMode.HTML
                        )
                    ))
        
        elif query.startswith("test:") or query.startswith("quiz:"):
            # Test qidirish
            search = query.replace("test:", "").replace("quiz:", "").strip()
            if search:
                async with db.connect() as conn:
                    cursor = await conn.execute('''
                        SELECT id, title, category, total_questions FROM quizzes 
                        WHERE title LIKE ? OR category LIKE ?
                        LIMIT 10
                    ''', (f'%{search}%', f'%{search}%'))
                    quizzes = await cursor.fetchall()
                
                for quiz_id, title, category, total in quizzes:
                    share_link = f"https://t.me/{bot_username}?start=quiz_{quiz_id}"
                    results.append(InlineQueryResultArticle(
                        id=f"quiz_{quiz_id}",
                        title=f"ðŸ“ {title}",
                        description=f"ðŸ“‚ {category or ''} | â“ {total} savol",
                        input_message_content=InputTextMessageContent(
                            message_text=f"ðŸ“ <b>{title}</b>\nðŸ“‚ Kategoriya: {category or ''}\nâ“ Savollar: {total} ta\n\nðŸ”— {share_link}",
                            parse_mode=ParseMode.HTML
                        )
                    ))
        
        else:
            # Umumiy qidirish - faqat kitob va testlar
            async with db.connect() as conn:
                # Kitoblar
                cursor = await conn.execute('SELECT id, title, author FROM books WHERE title LIKE ? LIMIT 5', (f'%{query}%',))
                for book_id, title, author in await cursor.fetchall():
                    share_link = f"https://t.me/{bot_username}?start=book_{book_id}"
                    results.append(InlineQueryResultArticle(
                        id=f"book_{book_id}",
                        title=f"ðŸ“š {title}",
                        description=f"Kitob | {author or ''}",
                        input_message_content=InputTextMessageContent(
                            message_text=f"ðŸ“š <b>{title}</b>\nðŸ‘¤ {author or ''}\n\nðŸ”— {share_link}",
                            parse_mode=ParseMode.HTML
                        )
                    ))
                
                # Testlar
                cursor = await conn.execute('SELECT id, title, total_questions FROM quizzes WHERE title LIKE ? LIMIT 5', (f'%{query}%',))
                for quiz_id, title, total in await cursor.fetchall():
                    share_link = f"https://t.me/{bot_username}?start=quiz_{quiz_id}"
                    results.append(InlineQueryResultArticle(
                        id=f"quiz_{quiz_id}",
                        title=f"ðŸ“ {title}",
                        description=f"Test | {total} savol",
                        input_message_content=InputTextMessageContent(
                            message_text=f"ðŸ“ <b>{title}</b>\nâ“ {total} savol\n\nðŸ”— {share_link}",
                            parse_mode=ParseMode.HTML
                        )
                    ))
        
        await inline_query.answer(results, cache_time=60)
    
    async def generate_mindmap_data(topic: str) -> dict:
        """AI orqali Mind Map ma'lumotlarini yaratish"""
        if not Config.OPENAI_API_KEY:
            return None
        
        prompt = f"""Quyidagi mavzu bo'yicha Mind Map (aql xaritasi) uchun ma'lumotlar yarat:

MAVZU: {topic}

Quyidagi formatda JSON javob ber:
{{
    "central": "Markaziy tushuncha",
    "branches": [
        {{
            "name": "Asosiy bo'lim 1",
            "items": ["Tushuncha 1", "Tushuncha 2", "Tushuncha 3"]
        }},
        {{
            "name": "Asosiy bo'lim 2",
            "items": ["Tushuncha 1", "Tushuncha 2"]
        }}
    ]
}}

QOIDALAR:
1. 4-6 ta asosiy bo'lim bo'lsin
2. Har bir bo'limda 2-4 ta tushuncha
3. Qisqa va aniq so'zlar ishlat
4. O'zbek tilida yoz"""

        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
                    "Content-Type": "application/json"
                }
                data = {
                    "model": Config.OPENAI_MODEL,
                    "messages": [
                        {"role": "system", "content": "Sen professional o'qituvchisan. Mind Map yaratishda mutaxassissan."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.7,
                    "max_tokens": 1500
                }
                
                async with session.post(Config.OPENAI_API_URL, headers=headers, json=data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        content = result['choices'][0]['message']['content']
                        json_match = re.search(r'\{[\s\S]*\}', content)
                        if json_match:
                            return json.loads(json_match.group())
                    return None
        except Exception as e:
            logger.error(f"generate_mindmap_data error: {e}")
            return None
    
    dp.include_router(router)
    
    # ============================================
    # QUIZ MODULE INTEGRATSIYA
    # ============================================
    try:
        from quiz_module import setup_quiz_module
    except ImportError:
        logger.warning("quiz_module.py topilmadi, minimal quiz setup ishlatiladi")

        async def setup_quiz_module(*args, **kwargs):
            """Fallback quiz setup - hech narsa qilmaydi"""
            return

    try:
        # OpenAI client yaratish
        if Config.OPENAI_API_KEY and not getattr(Config, "IS_TERMUX", False):
            try:
                from openai import OpenAI
                openai_client = OpenAI(api_key=Config.OPENAI_API_KEY)
                logger.info("OpenAI client yaratildi (Quiz moduli uchun)")
            except Exception as e:
                logger.warning(f"OpenAI client yaratilmadi (SDK import muammosi): {e}")
                openai_client = None
        else:
            openai_client = None
            if Config.OPENAI_API_KEY and getattr(Config, "IS_TERMUX", False):
                logger.info("Termux muhiti: OpenAI SDK o'chirildi (compat muammolarini oldini olish uchun)")
        
        await setup_quiz_module(bot, dp, db, openai_client, Config)
        logger.info("Quiz moduli muvaffaqiyatli yuklandi")
    except Exception as e:
        logger.error(f"Quiz modulini yuklashda xatolik: {e}", exc_info=True)
    
    logger.info("Bot ishga tushmoqda...")
    
    # Push notification worker ishga tushirish (2 kun botga kirmaganlar uchun)
    push_task = asyncio.create_task(push_notification_worker(bot, db))
    logger.info("Push notification worker ishga tushirildi (2 kun botga kirmaganlar uchun)")
    
    # Premium auto-collect XP worker ishga tushirish
    premium_task = asyncio.create_task(premium_auto_collect_worker(bot, db))
    logger.info("Premium auto-collect XP worker ishga tushirildi (har soatda)")
    
    # Trial expiry checker worker ishga tushirish
    trial_task = asyncio.create_task(trial_expiry_checker_worker(bot, db))
    logger.info("Trial expiry checker worker ishga tushirildi (har 6 soatda)")
    
    # Mining farm reminder worker ishga tushirish (lazy calculation)
    mining_task = asyncio.create_task(mining_farm_auto_collect_worker(bot, db))
    logger.info("Mining farm reminder worker ishga tushirildi (har 6 soatda, lazy calculation)")
    
    # Leaderboard reset worker ishga tushirish
    leaderboard_task = asyncio.create_task(leaderboard_reset_worker(bot, db))
    logger.info("Leaderboard reset worker ishga tushirildi (haftalik/oylik)")
    
    # Polling ishga tushirish
    await dp.start_polling(bot, allowed_updates=["message", "callback_query", "inline_query", "poll_answer"])

# =============================================================================
#                    GAMIFICATION HUB - MARKAZIY BOSHQARUV
# =============================================================================

@router.callback_query(F.data == "gamification_hub")
async def handle_gamification_hub(callback: CallbackQuery):
    """Gamification Hub - WebApp redirect"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    xp = user.get('xp', 0)
    level = user.get('level', 1)
    
    text = f"""
ðŸŽ® <b>GAMIFICATION HUB</b>

ðŸ‘¤ <b>{user.get('full_name', 'Foydalanuvchi')}</b>
â­ï¸ <b>Level:</b> {level} | <b>XP:</b> {xp:,}

ðŸš€ <b>To'liq imkoniyatlar WebApp'da:</b>
â€¢ ðŸ† Jonli Leaderboard
â€¢ ðŸ… Yutuqlar va Badgelar
â€¢ âš”ï¸ Live Battle Arena
â€¢ ðŸŽ Do'kon va Bonuslar

<i>Pastdagi tugmani bosing:</i>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(
        text="ðŸš€ WebApp'ni ochish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=gamification&user_id={user_id}")
    )
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "leaderboard_menu")
async def handle_leaderboard_menu(callback: CallbackQuery):
    """Leaderboard menyusi"""
    user_id = callback.from_user.id
    
    # Haftalik leaderboard
    weekly_lb = await db.get_leaderboard("weekly", 10)
    user_rank = await db.get_user_rank(user_id, "weekly")
    
    text = "ðŸ† <b>LEADERBOARD</b>\n\n"
    text += "ðŸ“… <b>HAFTALIK REYTING:</b>\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    
    medals = {1: "ðŸ¥‡", 2: "ðŸ¥ˆ", 3: "ðŸ¥‰"}
    
    if weekly_lb:
        for i, user in enumerate(weekly_lb, 1):
            medal = medals.get(i, f"{i}.")
            name = user.get('full_name', 'Noma\'lum')[:15]
            xp = user.get('xp', 0)
            text += f"{medal} <b>{name}</b> - {xp:,} XP\n"
    else:
        text += "<i>Hali hech kim yo'q</i>\n"
    
    text += f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += f"ðŸ“ <b>Sizning o'rningiz:</b> #{user_rank}\n\n"
    text += "<b>ðŸŽ MUKOFOTLAR (Top 10):</b>\n"
    text += "ðŸ¥‡ 1-o'rin: 500 XP + 50 Gold\n"
    text += "ðŸ¥ˆ 2-o'rin: 300 XP + 30 Gold\n"
    text += "ðŸ¥‰ 3-o'rin: 200 XP + 20 Gold\n"
    text += "4-10: 20-100 XP + Gold"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“… Haftalik", callback_data="leaderboard_weekly")
    builder.button(text="ðŸ“† Oylik", callback_data="leaderboard_monthly")
    builder.button(text="ðŸŒŸ Barcha vaqt", callback_data="leaderboard_alltime")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(3, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.in_(["leaderboard_weekly", "leaderboard_monthly", "leaderboard_alltime"]))
async def handle_leaderboard_period(callback: CallbackQuery):
    """Leaderboard davri bo'yicha"""
    period = callback.data.replace("leaderboard_", "")
    user_id = callback.from_user.id
    
    period_names = {"weekly": "HAFTALIK", "monthly": "OYLIK", "alltime": "BARCHA VAQT"}
    period_name = period_names.get(period, "HAFTALIK")
    
    lb = await db.get_leaderboard(period, 10)
    user_rank = await db.get_user_rank(user_id, period)
    
    text = f"ðŸ† <b>{period_name} LEADERBOARD</b>\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    
    medals = {1: "ðŸ¥‡", 2: "ðŸ¥ˆ", 3: "ðŸ¥‰"}
    
    if lb:
        for i, user in enumerate(lb, 1):
            medal = medals.get(i, f"{i}.")
            name = user.get('full_name', 'Noma\'lum')[:15]
            xp = user.get('xp', 0)
            lvl = user.get('level', 1)
            text += f"{medal} <b>{name}</b> (Lv.{lvl}) - {xp:,} XP\n"
    else:
        text += "<i>Hali hech kim yo'q</i>\n"
    
    text += f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += f"ðŸ“ <b>Sizning o'rningiz:</b> #{user_rank}"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“… Haftalik", callback_data="leaderboard_weekly")
    builder.button(text="ðŸ“† Oylik", callback_data="leaderboard_monthly")
    builder.button(text="ðŸŒŸ Barcha vaqt", callback_data="leaderboard_alltime")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(3, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "achievements_menu")
async def handle_achievements_menu(callback: CallbackQuery):
    """Achievements menyusi"""
    user_id = callback.from_user.id
    
    # Foydalanuvchi achievementlari
    user_achievements = await db.get_user_achievements(user_id)
    
    # Handle both return formats (list of dicts or dict with unlocked/locked)
    earned_ids = []
    if isinstance(user_achievements, dict):
        # Format: {'unlocked': [...], 'locked': [...]}
        unlocked = user_achievements.get('unlocked', [])
        earned_ids = [a.get('id', a.get('achievement_id', '')) for a in unlocked]
        earned_count = len(unlocked)
    elif isinstance(user_achievements, list):
        # Format: [{'achievement_id': '...', ...}, ...]
        earned_ids = [a.get('achievement_id', a.get('id', '')) for a in user_achievements]
        earned_count = len(user_achievements)
    else:
        earned_count = 0
    
    total = len(db.ACHIEVEMENTS) if hasattr(db, 'ACHIEVEMENTS') else 20
    earned = earned_count
    
    text = f"ðŸ… <b>ACHIEVEMENTS</b>\n\n"
    text += f"ðŸ“Š <b>Progress:</b> {earned}/{total} ({int(earned/total*100) if total > 0 else 0}%)\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    
    # Kategoriyalar bo'yicha guruhlash
    categories = {
        "ðŸ”¥ Streak": ['streak_7', 'streak_30', 'streak_100'],
        "ðŸŽ¯ Quiz": ['quiz_master_10', 'quiz_master_50', 'quiz_master_100', 'perfect_score'],
        "ðŸ“š Kitoblar": ['bookworm_10', 'bookworm_50', 'bookworm_100'],
        "ðŸ‘¥ Referral": ['first_referral', 'referral_5', 'referral_10'],
        "â­ XP": ['xp_1000', 'xp_10000', 'xp_100000'],
        "ðŸ“ˆ Level": ['level_5', 'level_10', 'level_25'],
    }
    
    for cat_name, achievement_ids in categories.items():
        cat_earned = sum(1 for aid in achievement_ids if aid in earned_ids)
        text += f"<b>{cat_name}</b> ({cat_earned}/{len(achievement_ids)})\n"
        for aid in achievement_ids:
            ach = db.ACHIEVEMENTS.get(aid, {})
            status = "âœ…" if aid in earned_ids else "â¬œ"
            text += f"  {status} {ach.get('name', aid)}\n"
        text += "\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“œ Olingan yutuqlar", callback_data="my_achievements")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "my_achievements")
async def handle_my_achievements(callback: CallbackQuery):
    """Olingan achievementlar"""
    user_id = callback.from_user.id
    
    achievements_data = await db.get_user_achievements(user_id)
    
    text = "ðŸ“œ <b>OLINGAN YUTUQLAR</b>\n\n"
    
    # Handle both return formats
    achievements = []
    if isinstance(achievements_data, dict):
        # Format: {'unlocked': [...], 'locked': [...]}
        achievements = achievements_data.get('unlocked', [])
    elif isinstance(achievements_data, list):
        # Format: [{'achievement_id': '...', ...}, ...]
        achievements = achievements_data
    
    if achievements:
        for ach in achievements[:15]:  # Oxirgi 15 ta
            name = ach.get('achievement_name', ach.get('name', 'Yutuq'))
            xp = ach.get('xp_reward', ach.get('xp', 0))
            gold = ach.get('gold_reward', 0)
            earned = ach.get('earned_at', '')
            text += f"ðŸ… <b>{name}</b>\n"
            text += f"   +{xp} XP"
            if gold:
                text += f", +{gold} Gold"
            text += "\n"
            if earned:
                text += f"   ðŸ“… {str(earned)[:10]}\n"
            text += "\n"
    else:
        text += "<i>Hali yutuqlar yo'q. Faol bo'ling!</i>"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Achievements", callback_data="achievements_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "daily_challenge")
async def handle_daily_challenge(callback: CallbackQuery):
    """Kunlik challenge"""
    user_id = callback.from_user.id
    
    challenge = await db.get_daily_challenge()
    status = await db.check_daily_challenge_status(user_id)
    
    text = "ðŸŽ¯ <b>KUNLIK CHALLENGE</b>\n\n"
    text += f"ðŸ“… <b>Sana:</b> {challenge.get('date', 'Bugun')}\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    
    challenge_data = challenge.get('data', {})
    text += f"ðŸ“‹ <b>Vazifa:</b> {challenge_data.get('desc', 'Noma\'lum')}\n\n"
    
    # Progress ko'rsatish
    progress = status.get('progress', 0)
    target = status.get('target', 1)
    progress_bar = "â–“" * progress + "â–‘" * (target - progress)
    text += f"ðŸ“Š <b>Progress:</b> [{progress_bar}] {progress}/{target}\n\n"
    
    text += f"ðŸŽ <b>Mukofot:</b>\n"
    text += f"   â­ {challenge.get('xp_reward', 30)} XP\n"
    text += f"   ðŸª™ {challenge.get('gold_reward', 3)} Gold\n\n"
    
    if status.get('completed'):
        text += "âœ… <b>BAJARILDI!</b> Ertaga yangi challenge!"
    else:
        challenge_type = challenge.get('type', '')
        if 'download_book' in challenge_type:
            text += "ðŸ“š <i>Kutubxonadan kitob yuklab oling!</i>"
        elif 'watch_movie' in challenge_type:
            text += "ðŸŽ¬ <i>Kinoteatrdan kino ko'ring!</i>"
        elif challenge_type == 'quiz':
            text += "ðŸ§  <i>AI Quiz da test yeching!</i>"
        else:
            text += "â³ <i>Vazifani bajaring va mukofot oling!</i>"
    
    builder = InlineKeyboardBuilder()
    # Tegishli bo'limga yo'naltirish
    if not status.get('completed'):
        challenge_type = challenge.get('type', '')
        if 'download_book' in challenge_type:
            builder.button(text="ðŸ“š Kutubxonaga o'tish", callback_data="go_library")
        elif 'watch_movie' in challenge_type:
            builder.button(text="ðŸŽ¬ Kinoteatrga o'tish", callback_data="go_cinema")
        elif challenge_type == 'quiz':
            builder.button(text="ðŸ§  Quiz ga o'tish", callback_data="go_quiz")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.in_(["go_library", "go_cinema", "go_quiz"]))
async def handle_daily_challenge_redirect(callback: CallbackQuery):
    """Daily challenge uchun yo'naltirish"""
    action = callback.data
    
    if action == "go_library":
        await callback.answer("ðŸ“š Kutubxonaga o'ting va kitob yuklang!", show_alert=True)
    elif action == "go_cinema":
        await callback.answer("ðŸŽ¬ Kinoteatrga o'ting va kino ko'ring!", show_alert=True)
    elif action == "go_quiz":
        await callback.answer("ðŸ§  AI Quiz bo'limiga o'ting!", show_alert=True)

@router.callback_query(F.data == "gold_shop_menu")
async def handle_gold_shop_menu(callback: CallbackQuery):
    """Gold Shop - XP dan Gold va Gold dan Premium"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    xp = user.get('xp', 0) if user else 0
    gold = user.get('gold', 0) if user else 0
    
    text = f"""
ðŸª™ <b>GOLD SHOP</b>

ðŸ’° <b>Sizning hisobingiz:</b>
â­ XP: {xp:,}
ðŸª™ Gold: {gold:,}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>XP â†’ GOLD AYIRBOSHLASH:</b>
<i>100 XP = 1 Gold</i>

ðŸª™ 10 Gold = 1,000 XP
ðŸª™ 50 Gold = 5,000 XP
ðŸª™ 100 Gold = 10,000 XP
ðŸª™ 500 Gold = 50,000 XP

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>GOLD â†’ PREMIUM:</b>

ðŸ‘‘ 1 kun = 10 Gold
ðŸ‘‘ 3 kun = 25 Gold
ðŸ‘‘ 7 kun = 50 Gold
ðŸ‘‘ 15 kun = 90 Gold
ðŸ‘‘ 30 kun = 150 Gold
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’± XP â†’ Gold", callback_data="xp_to_gold")
    builder.button(text="ðŸ‘‘ Gold â†’ Premium", callback_data="gold_to_premium")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "xp_to_gold")
async def handle_xp_to_gold(callback: CallbackQuery):
    """XP dan Gold sotib olish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    xp = user.get('xp', 0) if user else 0
    
    text = f"""
ðŸ’± <b>XP â†’ GOLD AYIRBOSHLASH</b>

â­ <b>Sizning XP:</b> {xp:,}
<i>200 XP = 1 Gold</i>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Qancha Gold olmoqchisiz?
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸª™ 10 Gold (2,000 XP)", callback_data="buy_gold_xp_10")
    builder.button(text="ðŸª™ 50 Gold (10,000 XP)", callback_data="buy_gold_xp_50")
    builder.button(text="ðŸª™ 100 Gold (20,000 XP)", callback_data="buy_gold_xp_100")
    builder.button(text="ðŸª™ 500 Gold (100,000 XP)", callback_data="buy_gold_xp_500")
    builder.button(text="ðŸ”™ Gold Shop", callback_data="gold_shop_menu")
    builder.adjust(2, 2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("buy_gold_xp_"))
async def handle_buy_gold_xp(callback: CallbackQuery):
    """XP evaziga Gold sotib olish"""
    user_id = callback.from_user.id
    gold_amount = int(callback.data.replace("buy_gold_xp_", ""))
    
    result = await db.buy_gold_with_xp(user_id, gold_amount)
    
    if result.get('success'):
        text = f"""
âœ… <b>MUVAFFAQIYATLI!</b>

ðŸª™ <b>Sotib olingan Gold:</b> {result['gold_bought']}
â­ <b>Sarflangan XP:</b> {result['xp_spent']:,}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Yangi balans:</b>
â­ XP: {result['new_xp']:,}
ðŸª™ Gold: {result['new_gold']}
        """
        await callback.answer("ðŸŽ‰ Gold sotib olindi!", show_alert=True)
    else:
        text = f"âŒ <b>Xatolik:</b> {result.get('error', 'Noma\'lum')}"
        await callback.answer("âŒ Xatolik!", show_alert=True)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ’± Yana sotib olish", callback_data="xp_to_gold")
    builder.button(text="ðŸ”™ Gold Shop", callback_data="gold_shop_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())

@router.callback_query(F.data == "gold_to_premium")
async def handle_gold_to_premium(callback: CallbackQuery):
    """Gold dan Premium sotib olish"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    gold = user.get('gold', 0) if user else 0
    
    text = f"""
ðŸ‘‘ <b>GOLD â†’ PREMIUM</b>

ðŸª™ <b>Sizning Gold:</b> {gold}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>PREMIUM PAKETLARI:</b>

ðŸ‘‘ 1 kun = 50 Gold
ðŸ‘‘ 3 kun = 120 Gold
ðŸ‘‘ 7 kun = 250 Gold
ðŸ‘‘ 15 kun = 450 Gold
ðŸ‘‘ 30 kun = 800 Gold

ðŸ’¡ <i>200 XP = 1 Gold</i>
<i>Premium bilan barcha kontentga kirish!</i>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‘‘ 1 kun (50 Gold)", callback_data="buy_premium_gold_1")
    builder.button(text="ðŸ‘‘ 3 kun (120 Gold)", callback_data="buy_premium_gold_3")
    builder.button(text="ðŸ‘‘ 7 kun (250 Gold)", callback_data="buy_premium_gold_7")
    builder.button(text="ðŸ‘‘ 15 kun (450 Gold)", callback_data="buy_premium_gold_15")
    builder.button(text="ðŸ‘‘ 30 kun (800 Gold)", callback_data="buy_premium_gold_30")
    builder.button(text="ðŸ”™ Gold Shop", callback_data="gold_shop_menu")
    builder.adjust(2, 2, 1, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("buy_premium_gold_"))
async def handle_buy_premium_gold(callback: CallbackQuery):
    """Gold evaziga Premium sotib olish"""
    user_id = callback.from_user.id
    days = int(callback.data.replace("buy_premium_gold_", ""))
    
    result = await db.buy_premium_with_gold(user_id, days)
    
    if result.get('success'):
        text = f"""
âœ… <b>PREMIUM AKTIVLASHTIRILDI!</b>

ðŸ‘‘ <b>Muddat:</b> {result['days']} kun
ðŸª™ <b>Sarflangan Gold:</b> {result['gold_spent']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>Qolgan Gold:</b> {result['new_gold']}

Endi barcha premium kontentga kirish mumkin!
        """
        await callback.answer("ðŸŽ‰ Premium aktivlashtirildi!", show_alert=True)
    else:
        text = f"âŒ <b>Xatolik:</b> {result.get('error', 'Noma\'lum')}"
        await callback.answer("âŒ Xatolik!", show_alert=True)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Gold Shop", callback_data="gold_shop_menu")
    builder.button(text="ðŸ  Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())

@router.callback_query(F.data == "referral_dashboard")
async def handle_referral_dashboard(callback: CallbackQuery):
    """Referral Dashboard"""
    user_id = callback.from_user.id
    
    stats = await db.get_referral_stats(user_id)
    bot_info = await callback.bot.get_me()
    ref_link = f"https://t.me/{bot_info.username}?start=ref_{user_id}"
    
    text = f"""
ðŸ‘¥ <b>REFERRAL DASHBOARD</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š <b>STATISTIKA:</b>
ðŸ‘¥ <b>Jami referrallar:</b> {stats['total']}
ðŸ“… <b>Bu hafta:</b> {stats['weekly']}
ðŸ“† <b>Bu oy:</b> {stats['monthly']}
â­ <b>Yig'ilgan XP:</b> {stats['earned_xp']:,}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ”— <b>SIZNING HAVOLANGIZ:</b>
<code>{ref_link}</code>

<i>Har bir do'st uchun 75 XP!</i>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>OXIRGI REFERRALLAR:</b>
    """
    
    if stats['recent']:
        for ref in stats['recent'][:5]:
            name = ref.get('full_name', 'Noma\'lum')[:20]
            date = ref.get('joined_date', '')[:10]
            text += f"ðŸ‘¤ {name} - {date}\n"
    else:
        text += "<i>Hali referrallar yo'q</i>"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“¤ Ulashish", switch_inline_query=f"ref_{user_id}")
    builder.button(text="ðŸ“‹ Havolani nusxalash", callback_data="copy_ref_link")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(2, 1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "copy_ref_link")
async def handle_copy_ref_link(callback: CallbackQuery):
    """Referral havolasini nusxalash"""
    user_id = callback.from_user.id
    bot_info = await callback.bot.get_me()
    ref_link = f"https://t.me/{bot_info.username}?start=ref_{user_id}"
    
    await callback.answer(f"ðŸ“‹ Havola: {ref_link}", show_alert=True)

@router.callback_query(F.data == "notifications_menu")
async def handle_notifications_menu(callback: CallbackQuery):
    """Notifications menyusi"""
    user_id = callback.from_user.id
    
    notifications = await db.get_unread_notifications(user_id, 10)
    
    text = "ðŸ”” <b>BILDIRISHNOMALAR</b>\n\n"
    
    if notifications:
        for notif in notifications:
            text += f"ðŸ“Œ <b>{notif['title']}</b>\n"
            text += f"   {notif['message']}\n"
            text += f"   <i>{notif['created_at'][:16]}</i>\n\n"
    else:
        text += "<i>Yangi bildirishnomalar yo'q</i>"
    
    builder = InlineKeyboardBuilder()
    if notifications:
        builder.button(text="âœ… Barchasini o'qilgan deb belgilash", callback_data="mark_all_read")
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "mark_all_read")
async def handle_mark_all_read(callback: CallbackQuery):
    """Barcha notificationlarni o'qilgan deb belgilash"""
    user_id = callback.from_user.id
    
    await db.mark_notifications_read(user_id)
    await callback.answer("âœ… Barcha bildirishnomalar o'qildi!")
    
    # Qayta notifications menyusiga o'tish
    await handle_notifications_menu(callback)

@router.callback_query(F.data == "my_level")
async def handle_my_level(callback: CallbackQuery):
    """Foydalanuvchi darajasi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    xp = user.get('xp', 0)
    level_info = db.calculate_level(xp)
    
    # Progress bar
    progress = level_info['percent']
    filled = int(progress / 10)
    empty = 10 - filled
    progress_bar = "â–ˆ" * filled + "â–‘" * empty
    
    text = f"""
ðŸ“ˆ <b>SIZNING DARAJANGIZ</b>

{level_info['name']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š <b>PROGRESS:</b>
Level {level_info['level']} â†’ Level {level_info['next_level']}

[{progress_bar}] {progress}%

â­ <b>XP:</b> {level_info['level_xp']:,} / {level_info['next_level_xp']:,}
ðŸ’° <b>Jami XP:</b> {xp:,}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>KEYINGI DARAJALAR:</b>
    """
    
    current_level = level_info['level']
    for lvl in range(current_level + 1, min(current_level + 4, 31)):
        threshold = db.LEVEL_THRESHOLDS.get(lvl, 0)
        name = db.LEVEL_NAMES.get(lvl, f"Level {lvl}")
        text += f"ðŸ“ˆ Lv.{lvl} {name} - {threshold:,} XP\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”™ Gamification", callback_data="gamification_hub")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

# =============================================================================
#                    YO'QOLGAN HANDLERLAR
# =============================================================================

@router.callback_query(F.data == "bonus_menu")
async def handle_bonus_menu(callback: CallbackQuery):
    """Bonuslar menyusi"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    xp = user.get('xp', 0)
    gold = user.get('gold', 0)
    streak = user.get('streak_count', 0)
    
    text = "ðŸŽ <b>BONUSLAR</b>\n\n"
    text += f"â­ <b>XP:</b> {xp:,}\n"
    text += f"ðŸª™ <b>Gold:</b> {gold:,}\n"
    text += f"ðŸ”¥ <b>Streak:</b> {streak} kun\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += "ðŸŽ® <b>Gamification</b> - XP, Gold, Achievements\n"
    text += "ðŸ‘¥ <b>Referral</b> - Do'stlarni taklif qiling\n"
    text += "ðŸŽ¯ <b>Daily Challenge</b> - Kunlik vazifalar\n"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ® Gamification Hub", callback_data="gamification_hub")
    builder.button(text="ðŸ‘¥ Referral Dashboard", callback_data="referral_dashboard")
    builder.button(text="ðŸŽ¯ Daily Challenge", callback_data="daily_challenge")
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

# =============================================================================
#                    TIL SOZLAMALARI (Language Settings)
# =============================================================================

@router.callback_query(F.data == "change_language")
async def handle_change_language(callback: CallbackQuery):
    """Til o'zgartirish menyusi"""
    text = """
ðŸŒ <b>TIL SOZLAMALARI</b>

Quyidagi tillardan birini tanlang:
Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· ÑÐ·Ñ‹ÐºÐ¾Ð²:
Select one of the languages:
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‡ºðŸ‡¿ O'zbek tili", callback_data="set_lang_uz")
    builder.button(text="ðŸ‡·ðŸ‡º Ð ÑƒÑÑÐºÐ¸Ð¹", callback_data="set_lang_ru")
    builder.button(text="ðŸ‡¬ðŸ‡§ English", callback_data="set_lang_en")
    builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("set_lang_"))
async def handle_set_language(callback: CallbackQuery):
    """Tilni o'rnatish"""
    user_id = callback.from_user.id
    lang_code = callback.data.replace("set_lang_", "")
    
    # Tilni saqlash
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE users SET language = ? WHERE user_id = ?
        ''', (lang_code, user_id))
        await conn.commit()
    
    # Tasdiqlash xabari
    messages = {
        'uz': "âœ… Til o'zbekchaga o'zgartirildi!\n\nEndi bot o'zbek tilida javob beradi.",
        'ru': "âœ… Ð¯Ð·Ñ‹Ðº Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¸Ð¹!\n\nÐ¢ÐµÐ¿ÐµÑ€ÑŒ Ð±Ð¾Ñ‚ Ð¾Ñ‚Ð²ÐµÑ‡Ð°ÐµÑ‚ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼ ÑÐ·Ñ‹ÐºÐµ.",
        'en': "âœ… Language changed to English!\n\nBot will now respond in English."
    }
    
    await callback.answer(messages.get(lang_code, messages['uz']), show_alert=True)
    
    # Asosiy menyuga qaytish
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ  " + Translations.get('main_menu', lang_code), callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, messages.get(lang_code, messages['uz']), reply_markup=builder.as_markup())

@router.callback_query(F.data == "profile")
async def handle_profile(callback: CallbackQuery):
    """Profil sahifasi - WebApp redirect"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await callback.answer("âŒ Foydalanuvchi topilmadi!")
        return
    
    xp = user.get('xp', 0)
    level = user.get('level', 1)
    
    text = f"""
ðŸ‘¤ <b>MENING PROFILIM</b>

ðŸ†” <b>ID:</b> <code>{user_id}</code>
â­ï¸ <b>Level:</b> {level}
âœ¨ <b>XP:</b> {xp:,}

ðŸš€ <b>Batafsil statistika WebApp'da:</b>
â€¢ ðŸ“Š To'liq statistika va tahlil
â€¢ ðŸ… Yutuqlar va unvonlar
â€¢ ðŸ“… Kunlik faollik tarixi
â€¢ âš™ï¸ Sozlamalar

<i>Pastdagi tugmani bosing:</i>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(
        text="ðŸš€ WebApp'ni ochish",
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=profile&user_id={user_id}")
    )
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "referral_stats")
async def handle_referral_stats(callback: CallbackQuery):
    """Referral statistikasi"""
    # referral_dashboard ga yo'naltirish
    callback.data = "referral_dashboard"
    await handle_referral_dashboard(callback)

@router.callback_query(F.data == "copy_referral")
async def handle_copy_referral(callback: CallbackQuery):
    """Referral linkni nusxalash"""
    user_id = callback.from_user.id
    bot_info = await bot.get_me()
    referral_link = f"https://t.me/{bot_info.username}?start=ref_{user_id}"
    
    await callback.answer(f"ðŸ“‹ Link: {referral_link}", show_alert=True)

@router.callback_query(F.data == "use_promo_code")
async def handle_use_promo_code(callback: CallbackQuery, state: FSMContext):
    """Promo kod ishlatish"""
    await safe_edit_text(callback,
        "ðŸŽŸ <b>PROMO KOD</b>\n\n"
        "Promo kodingizni kiriting:",
        reply_markup=Keyboards.back_button("bonus_menu")
    )
    await state.set_state(UserStates.waiting_promo_code)
    await callback.answer()

@router.callback_query(F.data == "quiz_create_menu")
async def handle_quiz_create_menu(callback: CallbackQuery):
    """Quiz yaratish menyusi"""
    await callback.answer("ðŸ§  Quiz bo'limiga o'ting!", show_alert=False)

# =============================================================================
#                    TO'LOV TIZIMI VA PREMIUM
# =============================================================================

@router.callback_query(F.data == "premium_menu")
async def handle_premium_menu(callback: CallbackQuery):
    """Premium sotib olish menyusi - yangilangan narxlar"""
    user_id = callback.from_user.id
    user = await db.get_user(user_id)
    
    # Premium marketing matni
    text = """
ðŸ’Ž <b>PREMIUM & EXCLUSIVE TARIFLAR</b>

ðŸš€ <b>Imkoniyatlaringizni kengaytiring!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ‘‘ <b>PREMIUM TARIF</b>
â€¢ 100 ta AI savol/kun
â€¢ 2x XP bonus
â€¢ VIP status
â€¢ Barcha kitoblar

ðŸ“¦ <b>Narxlar:</b>
  â€¢ 1 haftalik: <b>12,990 so'm</b>
  â€¢ 1 oylik: <b>24,990 so'm</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ’Ž <b>EXCLUSIVE TARIF</b>
â€¢ 999 ta AI savol/kun
â€¢ 5x XP bonus
â€¢ Shaxsiy menejer
â€¢ Premium + HD Kinolar

ðŸ“¦ <b>Narxlar:</b>
  â€¢ 1 haftalik: <b>14,990 so'm</b>
  â€¢ 1 oylik: <b>34,990 so'm</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<i>ðŸ‘‡ Quyidan tanlang:</i>
    """
    
    builder = InlineKeyboardBuilder()
    # Premium options
    builder.button(text="ðŸ‘‘ Premium 1 hafta - 12,990", callback_data="buy_premium_week")
    builder.button(text="ðŸ‘‘ Premium 1 oy - 24,990", callback_data="buy_premium_1")
    # Exclusive options
    builder.button(text="ðŸ’Ž Exclusive 1 hafta - 14,990", callback_data="buy_exclusive_week")
    builder.button(text="ðŸ’Ž Exclusive 1 oy - 34,990", callback_data="buy_exclusive_1")
    # WebApp and back
    builder.button(
        text="ðŸš€ WebApp orqali sotib olish", 
        web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=premium&user_id={user_id}")
    )
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("buy_premium_") | F.data.startswith("buy_exclusive_"))
async def handle_buy_premium(callback: CallbackQuery, state: FSMContext):
    """Premium/Exclusive sotib olish - to'lov ma'lumotlari"""
    user_id = callback.from_user.id
    plan = callback.data.replace("buy_", "")
    
    # Narxlarni aniqlash (yangilangan narxlar)
    prices = {
        "premium_week": ("Premium 1 haftalik", 12990),
        "premium_1": ("Premium 1 oylik", 24990),
        "exclusive_week": ("Exclusive 1 haftalik", 14990),
        "exclusive_1": ("Exclusive 1 oylik", 34990)
    }
    
    plan_name, price = prices.get(plan, ("Premium", 25000))
    
    text = f"""
ðŸ’³ <b>TO'LOV MA'LUMOTLARI</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ“¦ Tanlangan paket:</b> {plan_name}
<b>ðŸ’° Narxi:</b> {price:,} so'm

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ¦ TO'LOV UCHUN KARTA:</b>

<code>{Config.PAYMENT_CARD}</code>
ðŸ‘¤ {Config.PAYMENT_HOLDER}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ“‹ YO'RIQNOMA:</b>

1ï¸âƒ£ Yuqoridagi kartaga <b>{price:,} so'm</b> o'tkazing
2ï¸âƒ£ To'lov chekini rasmga oling
3ï¸âƒ£ "ðŸ“¤ Chek yuborish" tugmasini bosing
4ï¸âƒ£ Chek rasmini yuboring

â° <i>Admin 24 soat ichida tekshirib, obunani aktivlashtiradi.</i>
    """
    
    # Statega saqlash
    await state.update_data(payment_plan=plan, payment_price=price)
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“‹ Kartani nusxalash", callback_data="copy_payment_card")
    builder.button(text="ðŸ“¤ Chek yuborish", callback_data="send_payment_receipt")
    builder.button(text="ðŸ”™ Premium menyu", callback_data="premium_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "copy_payment_card")
async def handle_copy_payment_card(callback: CallbackQuery):
    """Karta raqamini nusxalash"""
    await callback.answer(f"ðŸ“‹ Karta: {Config.PAYMENT_CARD}", show_alert=True)

@router.callback_query(F.data == "send_payment_receipt")
async def handle_send_payment_receipt(callback: CallbackQuery, state: FSMContext):
    """To'lov chekini yuborish"""
    text = """
ðŸ“¤ <b>CHEK YUBORISH</b>

Iltimos, to'lov chekining <b>rasmini</b> yuboring.

<i>Chekda quyidagilar ko'rinishi kerak:</i>
â€¢ To'lov summasi
â€¢ Sana va vaqt
â€¢ Tranzaksiya ID (agar mavjud bo'lsa)

âš ï¸ <b>Diqqat:</b> Faqat rasm formatida qabul qilinadi.
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âŒ Bekor qilish", callback_data="premium_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await state.set_state(UserStates.waiting_payment_receipt)
    await callback.answer()

@router.message(UserStates.waiting_payment_receipt, F.photo)
async def handle_payment_receipt_photo(message: Message, state: FSMContext):
    """To'lov cheki rasmini qabul qilish"""
    user_id = message.from_user.id
    data = await state.get_data()
    
    plan = data.get('payment_plan', 'premium_1')
    price = data.get('payment_price', 25000)
    
    # Chek rasmini saqlash
    photo = message.photo[-1]  # Eng katta o'lcham
    file_id = photo.file_id
    
    # Bazaga saqlash
    async with db.connect() as conn:
        await conn.execute('''
            INSERT INTO payment_requests (user_id, plan, amount, receipt_file_id, status, created_at)
            VALUES (?, ?, ?, ?, 'pending', datetime('now'))
        ''', (user_id, plan, price, file_id))
        await conn.commit()
    
    # Adminlarga xabar yuborish
    admin_text = f"""
ðŸ†• <b>YANGI TO'LOV SO'ROVI</b>

ðŸ‘¤ <b>Foydalanuvchi:</b> {message.from_user.full_name}
ðŸ†” <b>ID:</b> <code>{user_id}</code>
ðŸ“¦ <b>Paket:</b> {plan}
ðŸ’° <b>Summa:</b> {price:,} so'm
ðŸ“… <b>Sana:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}
    """
    
    admin_builder = InlineKeyboardBuilder()
    admin_builder.button(text="âœ… Tasdiqlash", callback_data=f"admin_approve_payment_{user_id}_{plan}")
    admin_builder.button(text="âŒ Rad etish", callback_data=f"admin_reject_payment_{user_id}")
    admin_builder.adjust(2)
    
    for admin_id in Config.ADMIN_IDS:
        try:
            await message.bot.send_photo(
                admin_id, 
                photo=file_id, 
                caption=admin_text,
                reply_markup=admin_builder.as_markup(),
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            logger.error(f"Admin {admin_id} ga xabar yuborishda xato: {e}")
    
    # Foydalanuvchiga tasdiqlash
    await message.answer(
        "âœ… <b>Chek qabul qilindi!</b>\n\n"
        "So'rovingiz adminga yuborildi.\n"
        "â° 24 soat ichida javob beramiz.\n\n"
        "<i>Telegram: @asadbek_osarov</i>",
        parse_mode=ParseMode.HTML
    )
    
    await state.clear()

@router.callback_query(F.data.startswith("admin_approve_payment_"))
async def handle_admin_approve_payment(callback: CallbackQuery):
    """Admin: To'lovni tasdiqlash"""
    admin_id = callback.from_user.id
    if not await check_is_admin(admin_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    # user_id va plan ni olish
    parts = callback.data.replace("admin_approve_payment_", "").split("_")
    user_id = int(parts[0])
    plan = "_".join(parts[1:]) if len(parts) > 1 else "premium_1"
    
    # Subscription turini aniqlash
    sub_type = 2 if "premium" in plan else 3  # 2=Premium, 3=Exclusive
    days = 30 if "_1" in plan else 90  # 1 oy yoki 3 oy
    
    # Premium aktivlashtirish
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE users 
            SET subscription_type = ?, 
                premium_until = datetime('now', '+' || ? || ' days'),
                updated_at = datetime('now')
            WHERE user_id = ?
        ''', (sub_type, days, user_id))
        
        await conn.execute('''
            UPDATE payment_requests 
            SET status = 'approved', approved_by = ?, approved_at = datetime('now')
            WHERE user_id = ? AND status = 'pending'
        ''', (admin_id, user_id))
        
        await conn.commit()
    
    # Foydalanuvchiga xabar
    plan_name = "Premium" if sub_type == 2 else "Exclusive"
    try:
        await callback.bot.send_message(
            user_id,
            f"ðŸŽ‰ <b>TABRIKLAYMIZ!</b>\n\n"
            f"Sizning <b>{plan_name}</b> obunangiz aktivlashtirildi!\n\n"
            f"ðŸ“… Muddat: <b>{days} kun</b>\n"
            f"â° Tugash: {(datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')}\n\n"
            f"Barcha premium imkoniyatlardan foydalanishingiz mumkin! ðŸš€",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Foydalanuvchiga xabar yuborishda xato: {e}")
    
    await callback.answer(f"âœ… {user_id} uchun {plan_name} aktivlashtirildi!", show_alert=True)
    
    # Xabarni yangilash
    await callback.message.edit_caption(
        caption=callback.message.caption + f"\n\nâœ… <b>TASDIQLANDI</b> - {callback.from_user.full_name}",
        parse_mode=ParseMode.HTML
    )

@router.callback_query(F.data.startswith("admin_reject_payment_"))
async def handle_admin_reject_payment(callback: CallbackQuery):
    """Admin: To'lovni rad etish"""
    admin_id = callback.from_user.id
    if not await check_is_admin(admin_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    user_id = int(callback.data.replace("admin_reject_payment_", ""))
    
    # Bazani yangilash
    async with db.connect() as conn:
        await conn.execute('''
            UPDATE payment_requests 
            SET status = 'rejected', approved_by = ?, approved_at = datetime('now')
            WHERE user_id = ? AND status = 'pending'
        ''', (admin_id, user_id))
        await conn.commit()
    
    # Foydalanuvchiga xabar
    try:
        await callback.bot.send_message(
            user_id,
            "âŒ <b>TO'LOV RAD ETILDI</b>\n\n"
            "Afsuski, to'lovingiz tasdiqlanmadi.\n\n"
            "<b>Mumkin sabablar:</b>\n"
            "â€¢ Chek noaniq yoki o'qib bo'lmaydi\n"
            "â€¢ To'lov summasi noto'g'ri\n"
            "â€¢ Boshqa texnik muammo\n\n"
            "Iltimos, qaytadan urinib ko'ring yoki admin bilan bog'laning.\n"
            "<i>Telegram: @asadbek_osarov</i>",
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Foydalanuvchiga xabar yuborishda xato: {e}")
    
    await callback.answer(f"âŒ {user_id} uchun to'lov rad etildi", show_alert=True)
    
    # Xabarni yangilash
    await callback.message.edit_caption(
        caption=callback.message.caption + f"\n\nâŒ <b>RAD ETILDI</b> - {callback.from_user.full_name}",
        parse_mode=ParseMode.HTML
    )

# =============================================================================
#                    WEBAPP DATA HANDLER (Premium Purchase Flow)
# =============================================================================

@router.message(F.web_app_data)
async def handle_webapp_data(message: Message, state: FSMContext):
    """WebApp'dan kelgan ma'lumotlarni qayta ishlash"""
    import json
    
    try:
        data = json.loads(message.web_app_data.data)
        action = data.get('action')
        user_id = message.from_user.id
        
        if action == 'premium_purchase':
            plan = data.get('plan', 'premium_week')
            price = data.get('price', 12990)
            
            # Plan nomlari
            plan_names = {
                'premium_week': 'Premium 1 haftalik',
                'premium_month': 'Premium 1 oylik',
                'exclusive_week': 'Exclusive 1 haftalik',
                'exclusive_month': 'Exclusive 1 oylik'
            }
            plan_name = plan_names.get(plan, 'Premium')
            
            # Use standardized price from Config if possible, or fallback to data
            if plan == 'premium_week':
                price = 12990
            elif plan == 'premium_month':
                price = 24990
            elif plan == 'exclusive_week':
                price = 14990
            elif plan == 'exclusive_month':
                price = 34990
            
            # Foydalanuvchiga to'lov ma'lumotlarini yuborish
            text = f"""
ðŸ’³ <b>TO'LOV MA'LUMOTLARI</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ“¦ Tanlangan paket:</b> {plan_name}
<b>ðŸ’° Narxi:</b> {price:,} so'm

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ¦ TO'LOV UCHUN KARTA:</b>

<code>{Config.PAYMENT_CARD}</code>
ðŸ‘¤ {Config.PAYMENT_HOLDER}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ“‹ YO'RIQNOMA:</b>

1ï¸âƒ£ Yuqoridagi kartaga <b>{price:,} so'm</b> o'tkazing
2ï¸âƒ£ To'lov chekini rasmga oling
3ï¸âƒ£ "ðŸ“¤ Chek yuborish" tugmasini bosing
4ï¸âƒ£ Chek rasmini yuboring

â° <i>Admin 24 soat ichida tekshirib, obunani aktivlashtiradi.</i>
            """
            
            # Statega saqlash
            await state.update_data(payment_plan=plan, payment_price=price)
            
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸ“‹ Kartani nusxalash", callback_data="copy_payment_card")
            builder.button(text="ðŸ“¤ Chek yuborish", callback_data="send_payment_receipt")
            builder.button(text="ðŸ”™ Premium menyu", callback_data="premium_menu")
            builder.adjust(1)
            
            await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            
        else:
            # Boshqa WebApp actionlar
            await message.answer(f"âœ… WebApp dan ma'lumot qabul qilindi: {action}")
            
    except json.JSONDecodeError:
        await message.answer("âŒ WebApp ma'lumotlarini o'qishda xatolik")
    except Exception as e:
        logger.error(f"WebApp data handler error: {e}")
        await message.answer("âŒ Xatolik yuz berdi")

# =============================================================================
#                    WEBAPP REDIRECT FUNKSIYALARI
# =============================================================================

@router.callback_query(F.data == "open_webapp")
async def handle_open_webapp(callback: CallbackQuery):
    """WebApp ochish"""
    bot_info = await callback.bot.get_me()
    
    text = """
ðŸ“± <b>NEXUS WEBAPP</b>

Zamonaviy interfeys orqali barcha funksiyalardan foydalaning:

âœ¨ AI Quiz - Sun'iy intellekt testlari
ðŸ“š Kutubxona - Kitoblar va audiolar
ðŸŽ¬ Kinoteatr - Filmlar va seriallar
ðŸŽ® Gamification - XP, Gold, Yutuqlar
âš¡ Live Battle - Jonli musobaqalar

<i>Quyidagi tugmani bosing:</i>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸš€ WebApp ochish", web_app=WebAppInfo(url=Config.WEBAPP_URL))
    builder.button(text="ðŸ”™ Asosiy menyu", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data == "webapp_quiz")
async def handle_webapp_quiz(callback: CallbackQuery):
    """WebApp Quiz bo'limiga yo'naltirish"""
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ§  AI Quiz ochish", web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=quiz"))
    builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback,
        "ðŸ§  <b>AI QUIZ</b>\n\n"
        "WebApp orqali zamonaviy interfeys bilan test yeching!\n\n"
        f"ðŸ“Š <b>Kunlik limit:</b> {Config.DAILY_AI_LIMITS.get(0, 10)} savol (Free)\n"
        f"ðŸ‘‘ <b>Premium:</b> {Config.DAILY_AI_LIMITS.get(2, 100)} savol/kun\n"
        f"ðŸ’Ž <b>Exclusive:</b> {Config.DAILY_AI_LIMITS.get(3, 999)} savol/kun",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "webapp_gamification")
async def handle_webapp_gamification(callback: CallbackQuery):
    """WebApp Gamification bo'limiga yo'naltirish"""
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ® Gamification ochish", web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=gamification"))
    builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback,
        "ðŸŽ® <b>GAMIFICATION HUB</b>\n\n"
        "WebApp orqali barcha gamification funksiyalarini ko'ring:\n\n"
        "ðŸ† Leaderboard - Haftalik reyting\n"
        "ðŸ… Achievements - Yutuqlar\n"
        "ðŸª™ Gold Shop - XP â†’ Gold\n"
        "ðŸŽ¯ Daily Challenge - Kunlik vazifalar",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "webapp_battle")
async def handle_webapp_battle(callback: CallbackQuery):
    """WebApp Battle bo'limiga yo'naltirish"""
    builder = InlineKeyboardBuilder()
    builder.button(text="âš¡ Live Battle ochish", web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=battle"))
    builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
    builder.adjust(1)
    
    await safe_edit_text(callback,
        "âš¡ <b>LIVE BATTLE QUIZ</b>\n\n"
        "Real vaqtda boshqalar bilan raqobatlashing!\n\n"
        "ðŸŽ¯ Tezkor savollar\n"
        "ðŸ† Haftalik g'oliblar\n"
        "ðŸ’° XP va Gold mukofotlar",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "admin_bulk_delete_books")
async def handle_admin_bulk_delete_books(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitoblarni bulk delete"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ—‘ <b>KITOBLARNI O'CHIRISH</b>\n\n"
        "O'chirmoqchi bo'lgan kitoblar ID larini vergul bilan ajratib yozing:\n\n"
        "Masalan: 1, 5, 10, 15",
        reply_markup=Keyboards.back_button("admin_bulk_delete")
    )
    await state.set_state(UserStates.waiting_bulk_delete_books)
    await callback.answer()

@router.callback_query(F.data == "admin_bulk_delete_movies")
async def handle_admin_bulk_delete_movies(callback: CallbackQuery, state: FSMContext):
    """Admin: Filmlarni bulk delete"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ—‘ <b>FILMLARNI O'CHIRISH</b>\n\n"
        "O'chirmoqchi bo'lgan filmlar ID larini vergul bilan ajratib yozing:\n\n"
        "Masalan: 1, 5, 10, 15",
        reply_markup=Keyboards.back_button("admin_bulk_delete")
    )
    await state.set_state(UserStates.waiting_bulk_delete_movies)
    await callback.answer()

@router.callback_query(F.data == "admin_bulk_delete_courses")
async def handle_admin_bulk_delete_courses(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurslarni bulk delete"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸ—‘ <b>KURSLARNI O'CHIRISH</b>\n\n"
        "O'chirmoqchi bo'lgan kurslar ID larini vergul bilan ajratib yozing:\n\n"
        "Masalan: 1, 5, 10, 15",
        reply_markup=Keyboards.back_button("admin_bulk_delete")
    )
    await state.set_state(UserStates.waiting_bulk_delete_courses)
    await callback.answer()

@router.callback_query(F.data == "admin_content_movies")
async def handle_admin_content_movies(callback: CallbackQuery):
    """Admin: Filmlar kontenti"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    # admin_movies ga yo'naltirish
    callback.data = "admin_movies"
    await callback.answer("ðŸŽ¬ Filmlar bo'limiga o'tilmoqda...")

@router.callback_query(F.data == "admin_edit_book_author")
async def handle_admin_edit_book_author(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitob muallifini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    book_id = data.get('editing_book_id')
    
    if not book_id:
        await callback.answer("âŒ Kitob tanlanmagan!", show_alert=True)
        return
    
    await safe_edit_text(callback,
        "âœï¸ <b>MUALLIF O'ZGARTIRISH</b>\n\n"
        "Yangi muallif ismini kiriting:",
        reply_markup=Keyboards.back_button("admin_books")
    )
    await state.set_state(UserStates.waiting_book_author)
    await callback.answer()

@router.callback_query(F.data == "admin_edit_book_genre")
async def handle_admin_edit_book_genre(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitob janrini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    book_id = data.get('editing_book_id')
    
    if not book_id:
        await callback.answer("âŒ Kitob tanlanmagan!", show_alert=True)
        return
    
    builder = InlineKeyboardBuilder()
    genres = ["Fantastika", "Roman", "Detektiv", "Tarix", "Ilmiy", "Biografiya", "Psixologiya", "Biznes", "She'riyat", "Boshqa"]
    for genre in genres:
        builder.button(text=genre, callback_data=f"set_book_genre_{genre}")
    builder.button(text="ðŸ”™ Orqaga", callback_data="admin_books")
    builder.adjust(2)
    
    await safe_edit_text(callback,
        "ðŸ“š <b>JANR TANLASH</b>\n\n"
        "Kitob uchun yangi janr tanlang:",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "admin_edit_book_name")
async def handle_admin_edit_book_name(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitob nomini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    book_id = data.get('editing_book_id')
    
    if not book_id:
        await callback.answer("âŒ Kitob tanlanmagan!", show_alert=True)
        return
    
    await safe_edit_text(callback,
        "âœï¸ <b>NOM O'ZGARTIRISH</b>\n\n"
        "Yangi kitob nomini kiriting:",
        reply_markup=Keyboards.back_button("admin_books")
    )
    await state.set_state(UserStates.waiting_book_name)
    await callback.answer()

@router.callback_query(F.data == "admin_edit_book_premium")
async def handle_admin_edit_book_premium(callback: CallbackQuery, state: FSMContext):
    """Admin: Kitob premium statusini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    book_id = data.get('editing_book_id')
    
    if not book_id:
        await callback.answer("âŒ Kitob tanlanmagan!", show_alert=True)
        return
    
    # Premium statusni toggle qilish
    async with db.connect() as conn:
        cursor = await conn.execute('SELECT is_premium FROM books WHERE id = ?', (book_id,))
        row = await cursor.fetchone()
        if row:
            new_status = 0 if row[0] else 1
            await conn.execute('UPDATE books SET is_premium = ? WHERE id = ?', (new_status, book_id))
            await conn.commit()
            status_text = "Premium" if new_status else "Bepul"
            await callback.answer(f"âœ… Kitob {status_text} qilindi!", show_alert=True)
        else:
            await callback.answer("âŒ Kitob topilmadi!", show_alert=True)

@router.callback_query(F.data == "admin_edit_course_category")
async def handle_admin_edit_course_category(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs kategoriyasini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    course_id = data.get('editing_course_id')
    
    if not course_id:
        await callback.answer("âŒ Kurs tanlanmagan!", show_alert=True)
        return
    
    builder = InlineKeyboardBuilder()
    categories = ["Dasturlash", "Dizayn", "Marketing", "Biznes", "Tillar", "Shaxsiy rivojlanish", "Boshqa"]
    for cat in categories:
        builder.button(text=cat, callback_data=f"set_course_cat_{cat}")
    builder.button(text="ðŸ”™ Orqaga", callback_data="admin_courses")
    builder.adjust(2)
    
    await safe_edit_text(callback,
        "ðŸŽ“ <b>KATEGORIYA TANLASH</b>\n\n"
        "Kurs uchun yangi kategoriya tanlang:",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data == "admin_edit_course_description")
async def handle_admin_edit_course_description(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs tavsifini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    course_id = data.get('editing_course_id')
    
    if not course_id:
        await callback.answer("âŒ Kurs tanlanmagan!", show_alert=True)
        return
    
    await safe_edit_text(callback,
        "âœï¸ <b>TAVSIF O'ZGARTIRISH</b>\n\n"
        "Yangi kurs tavsifini kiriting:",
        reply_markup=Keyboards.back_button("admin_courses")
    )
    await state.set_state(UserStates.waiting_course_description)
    await callback.answer()

@router.callback_query(F.data == "admin_edit_course_price")
async def handle_admin_edit_course_price(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs narxini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    course_id = data.get('editing_course_id')
    
    if not course_id:
        await callback.answer("âŒ Kurs tanlanmagan!", show_alert=True)
        return
    
    await safe_edit_text(callback,
        "ðŸ’° <b>NARX O'ZGARTIRISH</b>\n\n"
        "Yangi narxni kiriting (XP da):",
        reply_markup=Keyboards.back_button("admin_courses")
    )
    await state.set_state(UserStates.waiting_course_price)
    await callback.answer()

@router.callback_query(F.data == "admin_edit_course_title")
async def handle_admin_edit_course_title(callback: CallbackQuery, state: FSMContext):
    """Admin: Kurs nomini o'zgartirish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    data = await state.get_data()
    course_id = data.get('editing_course_id')
    
    if not course_id:
        await callback.answer("âŒ Kurs tanlanmagan!", show_alert=True)
        return
    
    await safe_edit_text(callback,
        "âœï¸ <b>NOM O'ZGARTIRISH</b>\n\n"
        "Yangi kurs nomini kiriting:",
        reply_markup=Keyboards.back_button("admin_courses")
    )
    await state.set_state(UserStates.waiting_course_title)
    await callback.answer()

@router.callback_query(F.data == "admin_podcast_sections")
async def handle_admin_podcast_sections(callback: CallbackQuery):
    """Admin: Podcast bo'limlari"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    # admin_podcasts ga yo'naltirish
    callback.data = "admin_podcasts"
    await callback.answer("ðŸŽ™ Podcastlar bo'limiga o'tilmoqda...")

@router.callback_query(F.data == "admin_send_movie_by_code")
async def handle_admin_send_movie_by_code(callback: CallbackQuery, state: FSMContext):
    """Admin: Kod orqali film yuborish"""
    user_id = callback.from_user.id
    if not await check_is_admin(user_id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    await safe_edit_text(callback,
        "ðŸŽ¬ <b>KOD ORQALI FILM YUBORISH</b>\n\n"
        "Film kodini kiriting:",
        reply_markup=Keyboards.back_button("admin_movies")
    )
    await state.set_state(UserStates.waiting_movie_code)
    await callback.answer()

@router.callback_query(F.data == "mindmap_file")
async def handle_mindmap_file(callback: CallbackQuery):
    """Mindmap fayl"""
    await callback.answer("ðŸ—º Mindmap fayli hozircha mavjud emas!", show_alert=True)

@router.callback_query(F.data == "quiz_skip")
async def handle_quiz_skip(callback: CallbackQuery, state: FSMContext):
    """Quiz savolini o'tkazib yuborish"""
    user_id = callback.from_user.id
    data = await state.get_data()
    
    current_q = data.get('current_question', 0)
    total_q = data.get('total_questions', 10)
    
    if current_q < total_q - 1:
        await state.update_data(current_question=current_q + 1)
        await callback.answer("â­ Savol o'tkazib yuborildi!")
    else:
        await callback.answer("Bu oxirgi savol edi!")

# =============================================================================
# GURUH FUNKSIYALARI
# =============================================================================

@router.message(F.new_chat_members)
async def handle_bot_added_to_group(message: Message):
    """Bot guruhga qo'shilganda xush kelibsiz xabari"""
    bot_info = await message.bot.get_me()
    
    for member in message.new_chat_members:
        if member.id == bot_info.id:
            text = f"""
ðŸŽ‰ <b>Assalomu alaykum!</b>

Men <b>{bot_info.first_name}</b> - bilim va o'yin botiman!

<b>ðŸ“š Guruhda ishlatish:</b>
â€¢ /quiz - Test menyu
â€¢ /book [nom] - Kitob qidirish
â€¢ /battle - Live Battle o'yini
â€¢ /group_top - Guruh reytingi

<b>âš¡ Live Battle:</b>
Adminlar /battle buyrug'i bilan o'yin boshlashi mumkin.
Har bir to'g'ri javob = 1 XP!

<b>ðŸ”¥ Streak Bonus:</b>
Ketma-ket 3 marta g'olib = +10 XP bonus!

ðŸ“± Shaxsiy chat: @{bot_info.username}
            """
            
            builder = InlineKeyboardBuilder()
            builder.button(text="ðŸ“± Shaxsiy chatga o'tish", url=f"https://t.me/{bot_info.username}?start=welcome")
            builder.button(text="ðŸ“– Qo'llanma", callback_data="group_help")
            builder.adjust(1)
            
            await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            break

@router.callback_query(F.data == "group_help")
async def handle_group_help(callback: CallbackQuery):
    """Guruh qo'llanmasi"""
    text = """
ðŸ“– <b>GURUH QO'LLANMASI</b>

<b>ðŸŽ¯ Asosiy buyruqlar:</b>
â€¢ /quiz - Quiz menyu (shaxsiy chatga yo'naltiradi)
â€¢ /book [nom] - Kitob qidirish
â€¢ /battle - Live Battle boshlash (faqat admin)
â€¢ /group_top - Haftalik reyting

<b>âš¡ Live Battle qoidalari:</b>
1. Admin /battle buyrug'ini yuboradi
2. Test turi va vaqt tanlanadi
3. Ishtirokchilar poll orqali javob beradi
4. Har bir to'g'ri javob = 1 XP
5. G'olib e'lon qilinadi

<b>ðŸ”¥ Bonuslar:</b>
â€¢ Streak: 3 ta ketma-ket g'oliblik = +10 XP
â€¢ Guruhda test ulashish = +20 XP

<b>ðŸ’¡ Maslahat:</b>
Shaxsiy chatda ko'proq imkoniyatlar mavjud!
    """
    await callback.answer()
    await callback.message.answer(text, parse_mode=ParseMode.HTML)

@router.message(Command("group_top", "top"))
async def handle_group_top(message: Message):
    """Guruh haftalik reytingi"""
    if message.chat.type == "private":
        await message.answer("âŒ Bu buyruq faqat guruhlarda ishlaydi!")
        return
    
    chat_id = message.chat.id
    
    # Haftalik eng faol foydalanuvchilarni olish (bu guruhda battle o'ynagan)
    text = f"""
ðŸ† <b>HAFTALIK REYTING</b>
ðŸ“ {message.chat.title or 'Guruh'}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    """
    
    # Global top 10 XP bo'yicha (guruhga xos emas, lekin motivatsiya uchun)
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT user_id, full_name, weekly_xp, battle_streak, battles_won
            FROM users 
            WHERE weekly_xp > 0
            ORDER BY weekly_xp DESC
            LIMIT 10
        ''')
        rows = await cursor.fetchall()
    
    if rows:
        medals = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"]
        for i, row in enumerate(rows):
            medal = medals[i] if i < 3 else f"{i+1}."
            name = row[1] or f"User_{row[0]}"
            weekly_xp = row[2] or 0
            streak = row[3] or 0
            wins = row[4] or 0
            
            streak_icon = "ðŸ”¥" if streak >= 3 else ""
            text += f"\n{medal} <b>{name[:15]}</b>: {weekly_xp} XP {streak_icon}"
            if wins > 0:
                text += f" ({wins}ðŸ†)"
    else:
        text += "\n<i>Hali hech kim XP yig'magan</i>"
    
    text += "\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    text += "\nðŸ’¡ <i>/battle bilan o'yin boshlang!</i>"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âš¡ Battle boshlash", callback_data="start_group_battle")
    builder.button(text="ðŸ“Š Batafsil", callback_data="detailed_leaderboard")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "detailed_leaderboard")
async def handle_detailed_leaderboard(callback: CallbackQuery):
    """Batafsil leaderboard"""
    bot_info = await callback.bot.get_me()
    
    text = """
ðŸ“Š <b>BATAFSIL STATISTIKA</b>

Shaxsiy chatda to'liq statistikani ko'ring:
â€¢ O'zingizning XP, Gold, Level
â€¢ Yutuqlar va badgelar
â€¢ Battle tarixi
â€¢ Va boshqalar...
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“± Statistikani ko'rish", url=f"https://t.me/{bot_info.username}?start=my_dashboard")
    
    await safe_edit_text(callback, text, reply_markup=builder.as_markup())
    await callback.answer()

@router.message(Command("share_quiz"))
async def handle_share_quiz_command(message: Message):
    """Guruhda quiz ulashish"""
    if message.chat.type == "private":
        await message.answer("âŒ Bu buyruq faqat guruhlarda ishlaydi!\n\nGuruhga test ulashish uchun guruhda /share_quiz [test_id] yuboring.")
        return
    
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            "ðŸ“ <b>Test ulashish</b>\n\n"
            "Foydalanish: /share_quiz [test_id]\n\n"
            "Test ID ni shaxsiy chatda 'Mening testlarim' bo'limidan toping.",
            parse_mode=ParseMode.HTML
        )
        return
    
    try:
        quiz_id = int(args[1])
    except ValueError:
        await message.answer("âŒ Noto'g'ri test ID!")
        return
    
    user_id = message.from_user.id
    
    # Testni tekshirish
    async with db.connect() as conn:
        cursor = await conn.execute('SELECT title, user_id, questions FROM quizzes WHERE id = ?', (quiz_id,))
        quiz = await cursor.fetchone()
        
        if not quiz:
            await message.answer("âŒ Test topilmadi!")
            return
        
        quiz_title = quiz[0]
        quiz_owner = quiz[1]
        questions = quiz[2]
        
        # Savollar sonini olish
        try:
            import json
            q_list = json.loads(questions) if questions else []
            q_count = len(q_list)
        except:
            q_count = 0
        
        # Share bonus berish (faqat o'z testi uchun)
        if quiz_owner == user_id:
            await conn.execute('UPDATE users SET xp = xp + 20 WHERE user_id = ?', (user_id,))
            await conn.commit()
            bonus_text = "\n\nðŸŽ <b>+20 XP</b> ulashganingiz uchun!"
        else:
            bonus_text = ""
    
    bot_info = await message.bot.get_me()
    
    text = f"""
ðŸ“ <b>{quiz_title}</b>

ðŸ“Š Savollar: {q_count} ta
ðŸ‘¤ Ulashuvchi: {message.from_user.full_name}

ðŸŽ¯ Testni yechish uchun quyidagi tugmani bosing!{bonus_text}
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸŽ¯ Testni yechish", url=f"https://t.me/{bot_info.username}?start=play_quiz_{quiz_id}")
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

# =============================================================================
#                    GROUP COMMANDS - /quiz, /book, /share
# =============================================================================

@router.message(Command("quiz"))
async def handle_quiz_command(message: Message):
    """Guruhda quiz menyusi"""
    user_id = message.from_user.id
    
    if message.chat.type == "private":
        # Private chatda AI Quiz menyusiga yo'naltirish
        await handle_ai_quiz_menu(message)
        return
    
    # Guruhda
    text = """
ðŸ§  <b>QUIZ MENYU</b>

Guruhda quiz o'ynash uchun quyidagilardan birini tanlang:
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âš¡ Live Battle", callback_data="group_live_battle")
    builder.button(text="ðŸŽ¯ Tezkor Quiz", callback_data="group_quick_quiz")
    builder.button(text="ðŸ“š Kitob Quiz", callback_data="battle_start_book")
    builder.button(text="ðŸŽ¬ Film Quiz", callback_data="battle_start_movie")
    builder.adjust(2, 2)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(Command("book"))
async def handle_book_command(message: Message):
    """Kitob qidirish komandasi - guruh va private"""
    user_id = message.from_user.id
    args = message.text.split(maxsplit=1)
    
    if len(args) < 2:
        await message.answer(
            "ðŸ“š <b>KITOB QIDIRISH</b>\n\n"
            "Foydalanish: /book [kitob nomi]\n"
            "Masalan: /book Alisher Navoiy",
            parse_mode=ParseMode.HTML
        )
        return
    
    search_query = args[1].strip()
    
    # Kitob qidirish
    async with db.connect() as conn:
        cursor = await conn.execute('''
            SELECT id, title, author, genre, file_id
            FROM books 
            WHERE title LIKE ? OR author LIKE ?
            LIMIT 5
        ''', (f'%{search_query}%', f'%{search_query}%'))
        books = await cursor.fetchall()
    
    if not books:
        await message.answer(f"âŒ '{search_query}' bo'yicha kitob topilmadi!")
        return
    
    text = f"ðŸ“š <b>QIDIRUV NATIJALARI:</b> '{search_query}'\n\n"
    
    builder = InlineKeyboardBuilder()
    for book_id, title, author, genre, file_id in books:
        text += f"ðŸ“– <b>{title}</b>\n"
        text += f"   âœï¸ {author or 'Noma`lum'}\n\n"
        builder.button(text=f"ðŸ“¥ {title[:25]}", callback_data=f"download_book_{book_id}")
    
    builder.adjust(1)
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(Command("share"))
async def handle_share_command(message: Message):
    """Ulashish komandasi"""
    user_id = message.from_user.id
    bot_info = await message.bot.get_me()
    
    # Referral link
    referral_link = f"https://t.me/{bot_info.username}?start=ref_{user_id}"
    
    text = f"""
ðŸ“¤ <b>ULASHISH</b>

ðŸ”— <b>Sizning taklif havolangiz:</b>
<code>{referral_link}</code>

ðŸ‘† Havolani nusxalab do'stlaringizga yuboring!

ðŸŽ <b>Bonuslar:</b>
â€¢ Har bir do'st uchun: +50 XP
â€¢ 5 ta do'st = Premium 1 kun
â€¢ 10 ta do'st = Premium 3 kun
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“Š Referral statistikam", callback_data="referral_dashboard")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "group_live_battle")
async def handle_group_live_battle(callback: CallbackQuery):
    """Guruhda live battle boshlash"""
    if callback.message.chat.type == "private":
        await callback.answer("Bu faqat guruhlarda ishlaydi!")
        return
    
    # Battle komandasi ishlatiladi
    callback.message.text = "/battle"
    await handle_battle_command(callback.message)
    await callback.answer()

@router.callback_query(F.data == "group_quick_quiz")
async def handle_group_quick_quiz(callback: CallbackQuery):
    """Tezkor quiz boshlash"""
    if callback.message.chat.type == "private":
        await callback.answer("Bu faqat guruhlarda ishlaydi!")
        return
    
    # Quick battle
    callback.data = "battle_start_quick"
    await handle_battle_start(callback)

# =============================================================================
#                    LIVE BATTLE QUIZ - WAYGROUND STYLE
# =============================================================================

# Global battle storage (production uchun Redis yoki DB ishlatish kerak)
active_battles = {}

@router.message(Command("battle"))
async def handle_battle_command(message: Message):
    """Live Battle Quiz boshlash (faqat admin)"""
    if message.chat.type == "private":
        await message.answer(
            "âš¡ <b>LIVE BATTLE</b>\n\n"
            "Bu buyruq faqat guruhlarda ishlaydi!\n"
            "Guruhga qo'shilib, /battle buyrug'ini yuboring.",
            parse_mode=ParseMode.HTML
        )
        return
    
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # Admin tekshirish (guruh admini yoki bot admini)
    try:
        chat_member = await message.bot.get_chat_member(chat_id, user_id)
        is_group_admin = chat_member.status in ['creator', 'administrator']
    except:
        is_group_admin = False
    
    is_bot_admin = Config.is_admin(user_id)
    
    if not is_group_admin and not is_bot_admin:
        await message.answer("âŒ Faqat guruh adminlari battle boshlashi mumkin!")
        return
    
    # Faol battle borligini tekshirish
    if chat_id in active_battles:
        await message.answer("âš ï¸ Bu guruhda allaqachon faol battle bor! Avval uni tugating.")
        return
    
    text = """
âš¡ <b>LIVE BATTLE QUIZ</b>

Guruh a'zolari bilan real vaqtda raqobatlashing!

<b>ðŸŽ¯ Battle turi tanlang:</b>
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ§  AI Quiz (5 savol)", callback_data="battle_start_ai_5")
    builder.button(text="ðŸ§  AI Quiz (10 savol)", callback_data="battle_start_ai_10")
    builder.button(text="ðŸ“š Kitob Quiz", callback_data="battle_start_book")
    builder.button(text="ðŸŽ¬ Film Quiz", callback_data="battle_start_movie")
    builder.button(text="â± Tezkor (3 savol, 10s)", callback_data="battle_start_quick")
    builder.button(text="âŒ Bekor qilish", callback_data="battle_cancel")
    builder.adjust(2, 2, 2)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data.startswith("battle_start_"))
async def handle_battle_start(callback: CallbackQuery):
    """Battle boshlash"""
    if callback.message.chat.type == "private":
        await callback.answer("Bu faqat guruhlarda ishlaydi!")
        return
    
    chat_id = callback.message.chat.id
    user_id = callback.from_user.id
    
    # Admin tekshirish
    try:
        chat_member = await callback.bot.get_chat_member(chat_id, user_id)
        is_group_admin = chat_member.status in ['creator', 'administrator']
    except:
        is_group_admin = False
    
    if not is_group_admin and not Config.is_admin(user_id):
        await callback.answer("Faqat adminlar battle boshlashi mumkin!")
        return
    
    battle_type = callback.data.replace("battle_start_", "")
    
    # Battle konfiguratsiya
    configs = {
        "ai_5": {"questions": 5, "time_per_q": 20, "name": "AI Quiz"},
        "ai_10": {"questions": 10, "time_per_q": 20, "name": "AI Quiz"},
        "book": {"questions": 5, "time_per_q": 25, "name": "Kitob Quiz"},
        "movie": {"questions": 5, "time_per_q": 25, "name": "Film Quiz"},
        "quick": {"questions": 3, "time_per_q": 10, "name": "Tezkor Quiz"}
    }
    
    config = configs.get(battle_type, configs["ai_5"])
    
    # Battle yaratish
    battle_id = f"battle_{chat_id}_{int(time.time())}"
    active_battles[chat_id] = {
        "id": battle_id,
        "type": battle_type,
        "config": config,
        "started_by": user_id,
        "participants": {},
        "current_question": 0,
        "questions": [],
        "status": "waiting",
        "started_at": datetime.now().isoformat()
    }
    
    text = f"""
âš¡ <b>BATTLE BOSHLANDI!</b>

ðŸŽ¯ <b>Turi:</b> {config['name']}
â“ <b>Savollar:</b> {config['questions']} ta
â± <b>Vaqt:</b> {config['time_per_q']}s har savol

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ“¢ ISHTIROK ETISH UCHUN:</b>

Quyidagi tugmani bosing va battle'ga qo'shiling!
Savollar 10 soniyadan keyin boshlanadi...
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âœ… Ishtirok etaman!", callback_data=f"battle_join_{chat_id}")
    builder.button(text="ðŸš€ Hozir boshlash", callback_data=f"battle_force_start_{chat_id}")
    builder.adjust(1)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    await callback.answer("Battle yaratildi!")
    
    # 10 soniyadan keyin avtomatik boshlash
    asyncio.create_task(auto_start_battle(callback.bot, chat_id, callback.message.message_id))

async def auto_start_battle(bot, chat_id: int, message_id: int):
    """Battle'ni avtomatik boshlash"""
    await asyncio.sleep(10)
    
    if chat_id not in active_battles:
        return
    
    battle = active_battles[chat_id]
    if battle["status"] != "waiting":
        return
    
    # Battle boshlash
    await start_battle_questions(bot, chat_id, message_id)

@router.callback_query(F.data.startswith("battle_join_"))
async def handle_battle_join(callback: CallbackQuery):
    """Battle'ga qo'shilish"""
    chat_id = int(callback.data.replace("battle_join_", ""))
    user_id = callback.from_user.id
    
    if chat_id not in active_battles:
        await callback.answer("Bu battle allaqachon tugagan!")
        return
    
    battle = active_battles[chat_id]
    
    if user_id in battle["participants"]:
        await callback.answer("Siz allaqachon qo'shilgansiz!")
        return
    
    battle["participants"][user_id] = {
        "name": callback.from_user.full_name,
        "score": 0,
        "correct": 0,
        "wrong": 0,
        "time_total": 0
    }
    
    await callback.answer(f"âœ… Qo'shildingiz! Ishtirokchilar: {len(battle['participants'])}")

@router.callback_query(F.data.startswith("battle_force_start_"))
async def handle_battle_force_start(callback: CallbackQuery):
    """Battle'ni zudlik bilan boshlash"""
    chat_id = int(callback.data.replace("battle_force_start_", ""))
    user_id = callback.from_user.id
    
    if chat_id not in active_battles:
        await callback.answer("Battle topilmadi!")
        return
    
    battle = active_battles[chat_id]
    
    # Admin tekshirish
    if battle["started_by"] != user_id and not Config.is_admin(user_id):
        await callback.answer("Faqat battle yaratgan odam boshlashi mumkin!")
        return
    
    if len(battle["participants"]) < 1:
        await callback.answer("Kamida 1 ishtirokchi kerak!")
        return
    
    await start_battle_questions(callback.bot, chat_id, callback.message.message_id)
    await callback.answer("Battle boshlandi!")

async def start_battle_questions(bot, chat_id: int, message_id: int):
    """Battle savollarini boshlash"""
    if chat_id not in active_battles:
        return
    
    battle = active_battles[chat_id]
    battle["status"] = "active"
    config = battle["config"]
    
    # AI orqali savollar yaratish
    questions = await generate_battle_questions(config["questions"], battle["type"])
    battle["questions"] = questions
    
    if not questions:
        await bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text="âŒ Savollar yaratishda xatolik yuz berdi. Qaytadan urinib ko'ring.",
            parse_mode=ParseMode.HTML
        )
        del active_battles[chat_id]
        return
    
    # Ishtirokchilar ro'yxati
    participants_text = ", ".join([p["name"][:15] for p in battle["participants"].values()])
    if not participants_text:
        participants_text = "Hech kim qo'shilmadi"
    
    await bot.edit_message_text(
        chat_id=chat_id,
        message_id=message_id,
        text=f"ðŸš€ <b>BATTLE BOSHLANDI!</b>\n\n"
             f"ðŸ‘¥ Ishtirokchilar: {participants_text}\n"
             f"â“ Savollar: {len(questions)} ta\n\n"
             f"<i>Birinchi savol 3 soniyada...</i>",
        parse_mode=ParseMode.HTML
    )
    
    await asyncio.sleep(3)
    
    # Savollarni ketma-ket yuborish
    for i, question in enumerate(questions):
        if chat_id not in active_battles:
            break
        
        battle["current_question"] = i
        await send_battle_question(bot, chat_id, question, i + 1, len(questions), config["time_per_q"])
        
        # Vaqt kutish
        await asyncio.sleep(config["time_per_q"] + 3)
    
    # Natijalarni ko'rsatish
    await show_battle_results(bot, chat_id)

# =============================================================================
# MISSING FUNCTIONS FOR ADAPTIVE QUIZ
# =============================================================================

async def generate_quiz_with_ai(topic: str, difficulty: str, count: int = 1) -> dict:
    """AI yordamida quiz savollari generatsiya qilish"""
    import json
    import aiohttp
    import re
    
    questions = []
    
    if not Config.OPENAI_API_KEY:
        logger.warning("OpenAI API key mavjud emas")
        return {"questions": []}
    
    try:
        difficulty_prompts = {
            "easy": "oson, boshlang'ich darajadagi",
            "medium": "o'rta, o'rtacha qiyinlikdagi", 
            "hard": "qiyin, chuqur bilim talab qiladigan"
        }
        
        diff_text = difficulty_prompts.get(difficulty, "o'rta")
        
        prompt = f"""Generate {count} quiz questions in Uzbek language about "{topic}".
        
        Difficulty level: {diff_text}
        
        Format: JSON array with objects containing:
        - "question": question text in Uzbek
        - "options": array of 4 options in Uzbek
        - "correct": index of correct answer (0-3)
        
        Make questions engaging and educational.
        Return ONLY valid JSON array, no other text."""
        
        headers = {
            "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": Config.OPENAI_MODEL,
            "messages": [
                {"role": "system", "content": "You are a quiz generator. Return only valid JSON."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.8,
            "max_tokens": 1500
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(Config.OPENAI_API_URL, headers=headers, json=data, timeout=30) as resp:
                if resp.status == 200:
                    result = await resp.json()
                    content = result['choices'][0]['message']['content']
                    # JSON ni ajratib olish
                    json_match = re.search(r'\[[\s\S]*\]', content)
                    if json_match:
                        questions = json.loads(json_match.group())
    except Exception as e:
        logger.error(f"generate_quiz_with_ai error: {e}")
    
    return {"questions": questions[:count] if questions else []}

async def explain_wrong_answer(question: str, user_answer: str, correct_answer: str, topic: str) -> str:
    """AI yordamida noto'g'ri javobni tushuntirish"""
    import aiohttp
    
    if not Config.OPENAI_API_KEY:
        return "Kechirasiz, tushuntirishni olish imkoni yo'q. OpenAI API mavjud emas."
    
    try:
        prompt = f"""Quyidagi savol va javoblar uchun qisqa tushuntirish beril (o'zbek tilida):
        
        Mavzu: {topic}
        Savol: {question}
        Foydalanuvchi javobi: {user_answer}
        To'g'ri javob: {correct_answer}
        
        Nima uchun to'g'ri javob to'g'ri va foydalanuvchi javobi xato?
        Qisqa (2-3 gap) va tushunarli tushuntiring.
        Faqat o'zbek tilida javob ber."""
        
        headers = {
            "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": Config.OPENAI_MODEL,
            "messages": [
                {"role": "system", "content": "Sen o'qituvchisan. Savollarga qisqa va tushunarli tushuntirish berasan."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 300
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(Config.OPENAI_API_URL, headers=headers, json=data, timeout=20) as resp:
                if resp.status == 200:
                    result = await resp.json()
                    return result['choices'][0]['message']['content'].strip()
    except Exception as e:
        logger.error(f"explain_wrong_answer error: {e}")
    
    return f"To'g'ri javob: {correct_answer}. Bu savolni yaxshiroq o'rganish tavsiya etiladi."

def get_next_difficulty(current_difficulty: str, is_correct: bool, consecutive_correct: int, consecutive_wrong: int) -> str:
    """Keyingi savol qiyinligini aniqlash (adaptive logic)"""
    
    difficulties = ["easy", "medium", "hard"]
    current_idx = difficulties.index(current_difficulty) if current_difficulty in difficulties else 1
    
    if is_correct:
        # To'g'ri javob - qiyinlashtirish
        if consecutive_correct >= 2:
            # 2 marta ketma-ket to'g'ri - qiyinlashtir
            return difficulties[min(current_idx + 1, 2)]
        elif consecutive_correct >= 1 and current_difficulty == "easy":
            # Easy dan medium ga o'tish
            return "medium"
    else:
        # Noto'g'ri javob - osonlashtirish
        if consecutive_wrong >= 2:
            # 2 marta ketma-ket xato - osonlashtir
            return difficulties[max(current_idx - 1, 0)]
        elif consecutive_wrong >= 1 and current_difficulty == "hard":
            # Hard dan medium ga o'tish
            return "medium"
    
    # O'zgarishsiz qolish
    return current_difficulty

async def start_group_battle(chat_id: int, user):
    """Guruhda battle boshlash (Wayground uchun)"""
    import time
    
    user_id = user.id
    
    # Faol battle borligini tekshirish
    if chat_id in active_battles:
        await bot.send_message(chat_id, "âš ï¸ Bu guruhda allaqachon faol battle bor!")
        return
    
    # Battle yaratish
    battle_id = f"wg_battle_{chat_id}_{int(time.time())}"
    config = {"questions": 5, "time_per_q": 20, "name": "Wayground Battle"}
    
    active_battles[chat_id] = {
        "id": battle_id,
        "type": "wayground",
        "config": config,
        "started_by": user_id,
        "participants": {
            user_id: {
                "name": user.full_name,
                "score": 0,
                "correct": 0,
                "wrong": 0,
                "time_total": 0
            }
        },
        "current_question": 0,
        "questions": [],
        "status": "waiting",
        "started_at": datetime.now().isoformat()
    }
    
    text = f"""
âš¡ <b>WAYGROUND BATTLE!</b>

ðŸŽ¯ <b>Boshlagan:</b> {user.full_name}
â“ <b>Savollar:</b> {config['questions']} ta
â± <b>Vaqt:</b> {config['time_per_q']}s har savol

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ðŸ“¢ ISHTIROK ETISH UCHUN:</b>

Quyidagi tugmani bosing!
Savollar 10 soniyadan keyin boshlanadi...
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="âœ… Ishtirok etaman!", callback_data=f"battle_join_{chat_id}")
    builder.button(text="ðŸš€ Hozir boshlash", callback_data=f"battle_force_start_{chat_id}")
    builder.adjust(1)
    
    msg = await bot.send_message(chat_id, text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    # 10 soniyadan keyin avtomatik boshlash
    asyncio.create_task(auto_start_battle(bot, chat_id, msg.message_id))

async def generate_battle_questions(count: int, battle_type: str) -> list:
    """Battle uchun savollar yaratish"""
    questions = []
    
    if not Config.OPENAI_API_KEY:
        # Fallback savollar
        fallback = [
            {"q": "Quyidagilardan qaysi biri dasturlash tili?", "options": ["Python", "HTML", "CSS", "SQL"], "correct": 0},
            {"q": "1+1 nechaga teng?", "options": ["1", "2", "3", "4"], "correct": 1},
            {"q": "Eng katta sayyora qaysi?", "options": ["Yer", "Mars", "Yupiter", "Saturn"], "correct": 2},
        ]
        return fallback[:count]
    
    try:
        prompt = f"""Generate {count} quiz questions in Uzbek language. 
        Format: JSON array with objects containing:
        - "q": question text
        - "options": array of 4 options
        - "correct": index of correct answer (0-3)
        
        Topics: general knowledge, science, technology, history.
        Make questions engaging and educational.
        Return ONLY valid JSON array, no other text."""
        
        headers = {
            "Authorization": f"Bearer {Config.OPENAI_API_KEY}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": Config.OPENAI_MODEL,
            "messages": [
                {"role": "system", "content": "You are a quiz generator. Return only valid JSON."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.8,
            "max_tokens": 2000
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(Config.OPENAI_API_URL, headers=headers, json=data, timeout=30) as resp:
                if resp.status == 200:
                    result = await resp.json()
                    content = result['choices'][0]['message']['content']
                    # JSON ni ajratib olish
                    json_match = re.search(r'\[[\s\S]*\]', content)
                    if json_match:
                        questions = json.loads(json_match.group())
    except Exception as e:
        logger.error(f"generate_battle_questions error: {e}")
    
    return questions[:count] if questions else []

async def send_battle_question(bot, chat_id: int, question: dict, num: int, total: int, time_limit: int):
    """Battle savolini yuborish - Telegram native quiz poll yoki inline buttons"""
    if chat_id not in active_battles:
        return
    
    battle = active_battles[chat_id]
    q_text = question.get("q", "Savol")
    options = question.get("options", ["A", "B", "C", "D"])
    correct_idx = question.get("correct", 0)
    
    # Use native Telegram quiz poll for better UX
    use_native_poll = battle.get("use_native_poll", True)
    
    if use_native_poll:
        try:
            # Telegram quiz poll - native experience
            poll_msg = await bot.send_poll(
                chat_id=chat_id,
                question=f"â“ Savol {num}/{total}: {q_text[:255]}",  # Max 300 chars
                options=options[:10],  # Max 10 options
                type="quiz",
                correct_option_id=correct_idx,
                is_anonymous=False,
                open_period=time_limit,  # Auto-close after time_limit seconds
                explanation=f"âœ… To'g'ri javob: {options[correct_idx]}" if correct_idx < len(options) else None
            )
            battle["current_message_id"] = poll_msg.message_id
            battle["current_poll_id"] = poll_msg.poll.id
            
            # Track poll answers
            if "poll_answers" not in battle:
                battle["poll_answers"] = {}
            battle["poll_answers"][poll_msg.poll.id] = {
                "question_idx": num - 1,
                "correct": correct_idx,
                "answered_users": set()
            }
            return
        except Exception as e:
            logger.warning(f"Native poll failed, falling back to buttons: {e}")
    
    # Fallback: Inline buttons
    text = f"""
â“ <b>SAVOL {num}/{total}</b>

{q_text}

â± Vaqt: {time_limit} soniya
    """
    
    builder = InlineKeyboardBuilder()
    for i, opt in enumerate(options):
        builder.button(text=f"{chr(65+i)}) {opt}", callback_data=f"battle_answer_{chat_id}_{num-1}_{i}")
    builder.adjust(2, 2)
    
    msg = await bot.send_message(chat_id, text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    battle["current_message_id"] = msg.message_id

@router.poll_answer()
async def handle_poll_answer(poll_answer):
    """Telegram native quiz poll javoblarini qabul qilish"""
    user_id = poll_answer.user.id
    poll_id = poll_answer.poll_id
    selected_options = poll_answer.option_ids
    
    # Find which battle this poll belongs to
    for chat_id, battle in active_battles.items():
        if "poll_answers" in battle and poll_id in battle["poll_answers"]:
            poll_info = battle["poll_answers"][poll_id]
            
            # Check if user already answered
            if user_id in poll_info["answered_users"]:
                return
            poll_info["answered_users"].add(user_id)
            
            # Add participant if not exists
            if user_id not in battle["participants"]:
                battle["participants"][user_id] = {
                    "name": poll_answer.user.full_name or f"User {user_id}",
                    "score": 0,
                    "correct": 0,
                    "wrong": 0,
                    "time_total": 0
                }
            
            participant = battle["participants"][user_id]
            
            # Check answer
            if selected_options and selected_options[0] == poll_info["correct"]:
                participant["score"] += 10
                participant["correct"] += 1
            else:
                participant["wrong"] += 1
            
            return
    
    logger.debug(f"Poll answer for unknown poll: {poll_id}")

@router.callback_query(F.data.startswith("battle_answer_"))
async def handle_battle_answer(callback: CallbackQuery):
    """Battle javobini qabul qilish (inline button fallback)"""
    parts = callback.data.split("_")
    chat_id = int(parts[2])
    q_index = int(parts[3])
    answer = int(parts[4])
    user_id = callback.from_user.id
    
    if chat_id not in active_battles:
        await callback.answer("Battle tugagan!")
        return
    
    battle = active_battles[chat_id]
    
    if user_id not in battle["participants"]:
        # Kechikib qo'shilganlar
        battle["participants"][user_id] = {
            "name": callback.from_user.full_name,
            "score": 0,
            "correct": 0,
            "wrong": 0,
            "time_total": 0
        }
    
    if battle["current_question"] != q_index:
        await callback.answer("Bu savol allaqachon tugagan!")
        return
    
    # Javobni tekshirish
    question = battle["questions"][q_index]
    correct = question.get("correct", 0)
    
    participant = battle["participants"][user_id]
    
    if answer == correct:
        participant["score"] += 10
        participant["correct"] += 1
        await callback.answer("âœ… To'g'ri! +10 ball")
    else:
        participant["wrong"] += 1
        correct_option = question["options"][correct] if correct < len(question["options"]) else "?"
        await callback.answer(f"âŒ Noto'g'ri! Javob: {correct_option}")

async def show_battle_results(bot, chat_id: int):
    """Battle natijalarini ko'rsatish"""
    if chat_id not in active_battles:
        return
    
    battle = active_battles[chat_id]
    participants = battle["participants"]
    
    if not participants:
        await bot.send_message(chat_id, "âŒ Hech kim ishtirok etmadi!")
        del active_battles[chat_id]
        return
    
    # Natijalarni saralash
    sorted_participants = sorted(
        participants.items(), 
        key=lambda x: x[1]["score"], 
        reverse=True
    )
    
    text = """
ðŸ† <b>BATTLE NATIJALARI</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    """
    
    medals = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"]
    
    for i, (user_id, data) in enumerate(sorted_participants[:10]):
        medal = medals[i] if i < 3 else f"{i+1}."
        text += f"\n{medal} <b>{data['name'][:20]}</b>"
        text += f"\n   ðŸ“Š {data['score']} ball | âœ… {data['correct']} | âŒ {data['wrong']}"
        text += "\n"
    
    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # G'olibga XP berish
    if sorted_participants:
        winner_id, winner_data = sorted_participants[0]
        xp_reward = 50 + (winner_data["correct"] * 5)
        
        try:
            async with db.connect() as conn:
                await conn.execute('UPDATE users SET xp = xp + ?, battles_won = COALESCE(battles_won, 0) + 1 WHERE user_id = ?', (xp_reward, winner_id))
                await conn.commit()
        except Exception as e:
            logger.error(f"Battle XP error: {e}")
        
        text += f"\n\nðŸŽ‰ <b>G'OLIB:</b> {winner_data['name']}"
        text += f"\nðŸŽ <b>Mukofot:</b> +{xp_reward} XP"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ“Š Excel yuklab olish", callback_data=f"battle_export_{chat_id}")
    builder.button(text="ðŸ”„ Yangi Battle", callback_data="start_group_battle")
    builder.adjust(1)
    
    await bot.send_message(chat_id, text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    # Battle'ni o'chirish
    del active_battles[chat_id]

@router.callback_query(F.data.startswith("battle_export_"))
async def handle_battle_export(callback: CallbackQuery):
    """Battle natijalarini Excel ga eksport qilish"""
    await callback.answer("ðŸ“Š Excel eksport tez orada qo'shiladi!", show_alert=True)

@router.callback_query(F.data == "battle_cancel")
async def handle_battle_cancel(callback: CallbackQuery):
    """Battle'ni bekor qilish"""
    chat_id = callback.message.chat.id
    
    if chat_id in active_battles:
        del active_battles[chat_id]
    
    await callback.message.edit_text("âŒ Battle bekor qilindi.", parse_mode=ParseMode.HTML)
    await callback.answer()

# Duplicate start_group_battle handler removed - see line ~30969

# =============================================================================
# TELEGRAM STARS PAYMENT SYSTEM (INTERNATIONAL USERS)
# =============================================================================

STARS_PRICES = {
    'premium_week': {'stars': 150, 'usd': 2.99, 'days': 7, 'type': 'premium'},
    'premium_month': {'stars': 500, 'usd': 9.99, 'days': 30, 'type': 'premium'},
    'exclusive_week': {'stars': 200, 'usd': 3.99, 'days': 7, 'type': 'exclusive'},
    'exclusive_month': {'stars': 750, 'usd': 14.99, 'days': 30, 'type': 'exclusive'}
}

@router.message(Command("stars"))
async def cmd_stars_payment(message: Message):
    """Telegram Stars orqali to'lov"""
    user_id = message.from_user.id
    
    text = """
â­ <b>TELEGRAM STARS BILAN TO'LOV</b>

Xalqaro foydalanuvchilar uchun qulay to'lov tizimi!
Visa, Mastercard va boshqa kartalar qabul qilinadi.

<b>Premium tariflar:</b>
ðŸ‘‘ Premium 1 hafta â€” â­ 150 (~$2.99)
ðŸ‘‘ Premium 1 oy â€” â­ 500 (~$9.99)

<b>Exclusive tariflar:</b>
ðŸ’Ž Exclusive 1 hafta â€” â­ 200 (~$3.99)
ðŸ’Ž Exclusive 1 oy â€” â­ 750 (~$14.99)

ðŸ‘‡ Tarifni tanlang:
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ‘‘ Premium 1 hafta (â­150)", callback_data="stars_buy_premium_week")
    builder.button(text="ðŸ‘‘ Premium 1 oy (â­500)", callback_data="stars_buy_premium_month")
    builder.button(text="ðŸ’Ž Exclusive 1 hafta (â­200)", callback_data="stars_buy_exclusive_week")
    builder.button(text="ðŸ’Ž Exclusive 1 oy (â­750)", callback_data="stars_buy_exclusive_month")
    builder.button(text="ðŸ”™ Orqaga", callback_data="main_menu")
    builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data.startswith("stars_buy_"))
async def handle_stars_buy(callback: CallbackQuery):
    """Telegram Stars orqali sotib olish"""
    plan_key = callback.data.replace("stars_buy_", "")
    user_id = callback.from_user.id
    
    if plan_key not in STARS_PRICES:
        await callback.answer("Noto'g'ri tarif!", show_alert=True)
        return
    
    plan = STARS_PRICES[plan_key]
    stars_amount = plan['stars']
    plan_type = plan['type']
    days = plan['days']
    
    plan_names = {
        'premium_week': 'Premium 1 haftalik',
        'premium_month': 'Premium 1 oylik',
        'exclusive_week': 'Exclusive 1 haftalik',
        'exclusive_month': 'Exclusive 1 oylik'
    }
    
    try:
        # Create Telegram Stars invoice
        from aiogram.types import LabeledPrice
        
        prices = [LabeledPrice(label=plan_names.get(plan_key, 'Premium'), amount=stars_amount)]
        
        await bot.send_invoice(
            chat_id=user_id,
            title=f"ðŸŒŸ {plan_names.get(plan_key, 'Premium')}",
            description=f"Nexus Bot {plan_type.title()} obunasi - {days} kun",
            payload=f"stars_{plan_key}_{user_id}",
            provider_token="",  # Empty for Telegram Stars
            currency="XTR",  # Telegram Stars currency
            prices=prices,
            start_parameter=f"stars_{plan_key}"
        )
        
        await callback.answer("ðŸ’³ To'lov oynasi ochildi!", show_alert=False)
        
    except Exception as e:
        logger.error(f"Stars invoice error: {e}")
        await callback.answer(f"âŒ Xatolik: {str(e)[:100]}", show_alert=True)

@router.pre_checkout_query()
async def handle_pre_checkout(pre_checkout_query):
    """Telegram Stars to'lovini tasdiqlash"""
    try:
        await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)
    except Exception as e:
        logger.error(f"Pre-checkout error: {e}")
        await bot.answer_pre_checkout_query(
            pre_checkout_query.id, 
            ok=False, 
            error_message="To'lovni tasdiqlashda xatolik. Qayta urinib ko'ring."
        )

@router.message(F.successful_payment)
async def handle_successful_payment(message: Message):
    """Muvaffaqiyatli Telegram Stars to'lovi"""
    user_id = message.from_user.id
    payment = message.successful_payment
    
    payload = payment.invoice_payload
    total_amount = payment.total_amount
    currency = payment.currency
    
    # Parse payload: stars_premium_week_12345
    parts = payload.split("_")
    if len(parts) >= 3:
        plan_key = f"{parts[1]}_{parts[2]}"
    else:
        plan_key = "premium_month"
    
    plan = STARS_PRICES.get(plan_key, STARS_PRICES['premium_month'])
    days = plan['days']
    plan_type = plan['type']
    
    try:
        # Premium aktivatsiya
        from datetime import datetime, timedelta
        premium_until = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d %H:%M:%S')
        
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE users SET 
                    subscription_type = ?,
                    premium_until = ?,
                    total_spent = total_spent + ?
                WHERE user_id = ?
            ''', (plan_type, premium_until, total_amount, user_id))
            
            # Payment record
            import uuid
            payment_id = str(uuid.uuid4())[:8]
            await conn.execute('''
                INSERT INTO payments (payment_id, user_id, amount, currency, payment_method, status, description)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (payment_id, user_id, total_amount, currency, 'telegram_stars', 'completed', f'Stars: {plan_key}'))
            
            await conn.commit()
        
        # Success message
        plan_names = {
            'premium_week': 'Premium 1 haftalik',
            'premium_month': 'Premium 1 oylik',
            'exclusive_week': 'Exclusive 1 haftalik',
            'exclusive_month': 'Exclusive 1 oylik'
        }
        
        await message.answer(
            f"""
ðŸŽ‰ <b>TO'LOV MUVAFFAQIYATLI!</b>

âœ… <b>Tarif:</b> {plan_names.get(plan_key, 'Premium')}
â­ <b>Miqdor:</b> {total_amount} Stars
ðŸ“… <b>Amal qilish:</b> {days} kun
ðŸ—“ <b>Tugash:</b> {premium_until[:10]}

ðŸŽ Barcha premium imkoniyatlar aktivlashtirildi!

/start - Bosh menyuga qaytish
            """,
            parse_mode=ParseMode.HTML
        )
        
        # Admin notification
        await notify_admin_payment(user_id, message.from_user.full_name, plan_key, total_amount, 'stars')
        
        logger.info(f"Stars payment success: user={user_id}, plan={plan_key}, amount={total_amount}")
        
    except Exception as e:
        logger.error(f"Stars payment processing error: {e}")
        await message.answer("âŒ To'lov qayta ishlashda xatolik. Admin bilan bog'laning.")

# =============================================================================
# ADMIN PAYMENT NOTIFICATION SYSTEM
# =============================================================================

async def notify_admin_payment(user_id: int, user_name: str, plan: str, amount: int, method: str):
    """Adminga to'lov haqida xabar yuborish"""
    try:
        admin_ids = Config.ADMIN_IDS if hasattr(Config, 'ADMIN_IDS') else []
        
        if not admin_ids:
            # Fallback: get admins from database
            async with db.connect() as conn:
                cursor = await conn.execute('SELECT user_id FROM admin_users LIMIT 5')
                rows = await cursor.fetchall()
                admin_ids = [row[0] for row in rows]
        
        plan_names = {
            'premium_week': 'Premium 1 hafta',
            'premium_month': 'Premium 1 oy',
            'exclusive_week': 'Exclusive 1 hafta',
            'exclusive_month': 'Exclusive 1 oy'
        }
        
        method_names = {
            'stars': 'â­ Telegram Stars',
            'card': "ðŸ’³ Karta o'tkazmasi",
            'click': 'ðŸ“± Click',
            'payme': 'ðŸ“± Payme'
        }
        
        text = f"""
ðŸ’° <b>YANGI TO'LOV!</b>

ðŸ‘¤ <b>Foydalanuvchi:</b> {user_name}
ðŸ†” <b>ID:</b> <code>{user_id}</code>
ðŸ“¦ <b>Tarif:</b> {plan_names.get(plan, plan)}
ðŸ’µ <b>Miqdor:</b> {amount:,} {'Stars' if method == 'stars' else "so'm"}
ðŸ’³ <b>Usul:</b> {method_names.get(method, method)}
ðŸ“… <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}

âœ… To'lov avtomatik tasdiqlandi.
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ‘¤ Profilni ko'rish", callback_data=f"admin_user_info_{user_id}")
        builder.button(text="ðŸ“Š To'lovlar", callback_data="admin_payments")
        builder.adjust(2)
        
        for admin_id in admin_ids:
            try:
                await bot.send_message(admin_id, text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.warning(f"Admin notify failed for {admin_id}: {e}")
                
    except Exception as e:
        logger.error(f"notify_admin_payment error: {e}")

async def notify_admin_receipt(user_id: int, user_name: str, plan: str, amount: int, receipt_file_id: str):
    """Adminga chek kelgani haqida xabar (manual verification uchun)"""
    try:
        admin_ids = Config.ADMIN_IDS if hasattr(Config, 'ADMIN_IDS') else []
        
        if not admin_ids:
            async with db.connect() as conn:
                cursor = await conn.execute('SELECT user_id FROM admin_users LIMIT 5')
                rows = await cursor.fetchall()
                admin_ids = [row[0] for row in rows]
        
        plan_names = {
            'premium_week': 'Premium 1 hafta',
            'premium_month': 'Premium 1 oy',
            'exclusive_week': 'Exclusive 1 hafta',
            'exclusive_month': 'Exclusive 1 oy'
        }
        
        text = f"""
ðŸ§¾ <b>YANGI TO'LOV CHEKI!</b>

ðŸ‘¤ <b>Foydalanuvchi:</b> {user_name}
ðŸ†” <b>ID:</b> <code>{user_id}</code>
ðŸ“¦ <b>Tarif:</b> {plan_names.get(plan, plan)}
ðŸ’µ <b>Miqdor:</b> {amount:,} so'm
ðŸ“… <b>Vaqt:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}

â³ <b>Tekshirishni kutmoqda...</b>
        """
        
        builder = InlineKeyboardBuilder()
        builder.button(text="âœ… Tasdiqlash", callback_data=f"admin_approve_payment_{user_id}_{plan}")
        builder.button(text="âŒ Rad etish", callback_data=f"admin_reject_payment_{user_id}_{plan}")
        builder.button(text="ðŸ‘¤ Profil", callback_data=f"admin_user_info_{user_id}")
        builder.adjust(2, 1)
        
        for admin_id in admin_ids:
            try:
                # Send receipt image with buttons
                await bot.send_photo(
                    admin_id, 
                    photo=receipt_file_id, 
                    caption=text, 
                    reply_markup=builder.as_markup(), 
                    parse_mode=ParseMode.HTML
                )
            except Exception as e:
                logger.warning(f"Admin receipt notify failed for {admin_id}: {e}")
                
    except Exception as e:
        logger.error(f"notify_admin_receipt error: {e}")

@router.callback_query(F.data.startswith("admin_approve_payment_"))
async def handle_admin_approve_payment(callback: CallbackQuery):
    """Admin: To'lovni tasdiqlash"""
    if not await check_is_admin(callback.from_user.id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    parts = callback.data.replace("admin_approve_payment_", "").split("_")
    user_id = int(parts[0])
    plan_key = f"{parts[1]}_{parts[2]}" if len(parts) >= 3 else "premium_month"
    
    # Get plan details
    plan_days = {'premium_week': 7, 'premium_month': 30, 'exclusive_week': 7, 'exclusive_month': 30}
    plan_types = {'premium_week': 'premium', 'premium_month': 'premium', 'exclusive_week': 'exclusive', 'exclusive_month': 'exclusive'}
    
    days = plan_days.get(plan_key, 30)
    plan_type = plan_types.get(plan_key, 'premium')
    
    try:
        from datetime import datetime, timedelta
        premium_until = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d %H:%M:%S')
        
        async with db.connect() as conn:
            await conn.execute('''
                UPDATE users SET subscription_type = ?, premium_until = ?
                WHERE user_id = ?
            ''', (plan_type, premium_until, user_id))
            await conn.commit()
        
        # Notify user
        try:
            await bot.send_message(
                user_id,
                f"ðŸŽ‰ <b>TO'LOV TASDIQLANDI!</b>\n\n"
                f"âœ… Sizning {plan_type.title()} obunangiz {days} kunga aktivlashtirildi!\n"
                f"ðŸ“… Tugash sanasi: {premium_until[:10]}\n\n"
                f"Rahmat! /start - Bosh menyu",
                parse_mode=ParseMode.HTML
            )
        except:
            pass
        
        await callback.message.edit_caption(
            caption=callback.message.caption + f"\n\nâœ… <b>TASDIQLANDI</b> ({callback.from_user.full_name})",
            parse_mode=ParseMode.HTML
        )
        await callback.answer("âœ… To'lov tasdiqlandi!")
        
    except Exception as e:
        logger.error(f"Approve payment error: {e}")
        await callback.answer(f"âŒ Xatolik: {e}", show_alert=True)

@router.callback_query(F.data.startswith("admin_reject_payment_"))
async def handle_admin_reject_payment(callback: CallbackQuery):
    """Admin: To'lovni rad etish"""
    if not await check_is_admin(callback.from_user.id, db):
        await callback.answer("Siz admin emassiz!")
        return
    
    parts = callback.data.replace("admin_reject_payment_", "").split("_")
    user_id = int(parts[0])
    
    try:
        # Notify user
        try:
            await bot.send_message(
                user_id,
                "âŒ <b>TO'LOV RAD ETILDI</b>\n\n"
                "Sizning to'lov chekingiz rad etildi.\n"
                "Iltimos, to'g'ri chek yuboring yoki admin bilan bog'laning.\n\n"
                "/premium - Qayta urinish",
                parse_mode=ParseMode.HTML
            )
        except:
            pass
        
        await callback.message.edit_caption(
            caption=callback.message.caption + f"\n\nâŒ <b>RAD ETILDI</b> ({callback.from_user.full_name})",
            parse_mode=ParseMode.HTML
        )
        await callback.answer("âŒ To'lov rad etildi!")
        
    except Exception as e:
        logger.error(f"Reject payment error: {e}")
        await callback.answer(f"âŒ Xatolik: {e}", show_alert=True)

# =============================================================================
# WAYGROUND - GURUH BILAN ISHLASH TIZIMI
# =============================================================================

@router.message(Command("wayground"))
async def cmd_wayground(message: Message):
    """Wayground - Guruh bilan ishlash"""
    chat_type = message.chat.type
    
    if chat_type in ['group', 'supergroup']:
        # Guruhda
        text = """
ðŸŽ¯ <b>WAYGROUND - Guruh Rejimi</b>

Guruh bilan birgalikda ishlash uchun tayyor!

<b>Buyruqlar:</b>
/wg_test - Guruh testi boshlash
/wg_battle - Mini battle o'tkazish
/wg_stats - Guruh statistikasi
/wg_leaderboard - Guruh reytingi

ðŸ‘‡ Kerakli buyruqni tanlang:
        """
        builder = InlineKeyboardBuilder()
        builder.button(text="ðŸ“ Guruh Test", callback_data="wg_start_test")
        builder.button(text="âš”ï¸ Mini Battle", callback_data="wg_start_battle")
        builder.button(text="ðŸ“Š Statistika", callback_data="wg_group_stats")
        builder.button(text="ðŸ† Reyting", callback_data="wg_leaderboard")
        builder.adjust(2, 2)
    else:
        # Shaxsiy chatda
        text = """
ðŸŽ¯ <b>WAYGROUND</b>

Guruh bilan birgalikda o'qish va bellashuv platformasi!

<b>Imkoniyatlar:</b>
â€¢ ðŸ‘¥ Guruh testlari yaratish
â€¢ âš”ï¸ Mini battle o'tkazish
â€¢ ðŸ“Š Guruh progressini kuzatish
â€¢ ðŸ† Reyting va yutuqlar

<b>Foydalanish:</b>
1. Botni guruhga qo'shing
2. /wayground buyrug'ini yuboring
3. Test yoki battle boshlang!
        """
        builder = InlineKeyboardBuilder()
        builder.button(text="âž• Guruhga qo'shish", url=f"https://t.me/{Config.BOT_USERNAME}?startgroup=wayground")
        builder.button(text="ðŸŽ¯ WebApp ochish", web_app=WebAppInfo(url=f"{Config.WEBAPP_URL}?section=wayground"))
        builder.adjust(1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.message(Command("wg_test"))
async def cmd_wg_test(message: Message, state: FSMContext):
    """Guruh testi boshlash"""
    if message.chat.type not in ['group', 'supergroup']:
        await message.answer("âŒ Bu buyruq faqat guruhlarda ishlaydi!")
        return
    
    user_id = message.from_user.id
    chat_id = message.chat.id
    
    text = """
ðŸ“ <b>GURUH TEST</b>

Test mavzusini va savollar sonini tanlang:
    """
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ§  Umumiy bilim (5)", callback_data=f"wg_quiz_general_5_{chat_id}")
    builder.button(text="ðŸ§  Umumiy bilim (10)", callback_data=f"wg_quiz_general_10_{chat_id}")
    builder.button(text="ðŸ“š Fan (5)", callback_data=f"wg_quiz_science_5_{chat_id}")
    builder.button(text="ðŸ“š Fan (10)", callback_data=f"wg_quiz_science_10_{chat_id}")
    builder.button(text="ðŸŒ Tarix (5)", callback_data=f"wg_quiz_history_5_{chat_id}")
    builder.button(text="ðŸ’» IT (5)", callback_data=f"wg_quiz_it_5_{chat_id}")
    builder.button(text="âŒ Bekor", callback_data="wg_cancel")
    builder.adjust(2, 2, 2, 1)
    
    await message.answer(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data.startswith("wg_quiz_"))
async def handle_wg_quiz_start(callback: CallbackQuery):
    """Wayground guruh quiz boshlash"""
    parts = callback.data.replace("wg_quiz_", "").split("_")
    topic = parts[0]
    count = int(parts[1])
    chat_id = int(parts[2])
    
    await callback.message.edit_text("â³ Test savolari yaratilmoqda...")
    
    try:
        # Generate quiz
        quiz_data = await generate_quiz_with_ai(topic, "medium", count)
        
        if not quiz_data or not quiz_data.get('questions'):
            await callback.message.edit_text("âŒ Test yaratishda xatolik. Qayta urinib ko'ring.")
            return
        
        questions = quiz_data['questions']
        
        # Store quiz in active_battles for tracking
        battle_id = f"wg_{chat_id}_{int(datetime.now().timestamp())}"
        active_battles[chat_id] = {
            "type": "wayground_quiz",
            "id": battle_id,
            "questions": questions,
            "current_q": 0,
            "participants": {},
            "started_at": datetime.now(),
            "topic": topic
        }
        
        await callback.message.edit_text(
            f"ðŸŽ¯ <b>GURUH TEST BOSHLANDI!</b>\n\n"
            f"ðŸ“š Mavzu: {topic.title()}\n"
            f"â“ Savollar: {count} ta\n\n"
            f"â± Har bir savol uchun 30 soniya!",
            parse_mode=ParseMode.HTML
        )
        
        await asyncio.sleep(2)
        
        # Send first question as poll
        await send_wg_question(callback.message.chat.id, 0)
        
    except Exception as e:
        logger.error(f"WG quiz start error: {e}")
        await callback.message.edit_text(f"âŒ Xatolik: {e}")

async def send_wg_question(chat_id: int, q_index: int):
    """Wayground savolini yuborish"""
    if chat_id not in active_battles:
        return
    
    battle = active_battles[chat_id]
    questions = battle.get("questions", [])
    
    if q_index >= len(questions):
        # Quiz tugadi
        await show_wg_results(chat_id)
        return
    
    question = questions[q_index]
    q_text = question.get("question", question.get("q", "Savol"))
    options = question.get("options", ["A", "B", "C", "D"])
    correct_idx = question.get("correct", 0)
    
    battle["current_q"] = q_index
    
    try:
        poll_msg = await bot.send_poll(
            chat_id=chat_id,
            question=f"â“ Savol {q_index + 1}/{len(questions)}: {q_text[:255]}",
            options=options[:10],
            type="quiz",
            correct_option_id=correct_idx,
            is_anonymous=False,
            open_period=30,
            explanation=f"âœ… To'g'ri javob: {options[correct_idx]}" if correct_idx < len(options) else None
        )
        
        battle["current_poll_id"] = poll_msg.poll.id
        battle["poll_answers"] = battle.get("poll_answers", {})
        battle["poll_answers"][poll_msg.poll.id] = {
            "question_idx": q_index,
            "correct": correct_idx,
            "answered_users": set()
        }
        
        # Schedule next question
        asyncio.create_task(schedule_next_wg_question(chat_id, q_index + 1, 35))
        
    except Exception as e:
        logger.error(f"Send WG question error: {e}")

async def schedule_next_wg_question(chat_id: int, next_q: int, delay: int):
    """Keyingi savolni rejalashtirish"""
    await asyncio.sleep(delay)
    if chat_id in active_battles:
        await send_wg_question(chat_id, next_q)

async def show_wg_results(chat_id: int):
    """Wayground test natijalarini ko'rsatish"""
    if chat_id not in active_battles:
        return
    
    battle = active_battles[chat_id]
    participants = battle.get("participants", {})
    
    if not participants:
        await bot.send_message(chat_id, "ðŸ˜” Hech kim ishtirok etmadi.", parse_mode=ParseMode.HTML)
        del active_battles[chat_id]
        return
    
    sorted_participants = sorted(
        participants.items(),
        key=lambda x: x[1].get('score', 0),
        reverse=True
    )
    
    text = """
ðŸ† <b>TEST NATIJALARI</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    """
    
    medals = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"]
    
    for i, (user_id, data) in enumerate(sorted_participants[:10]):
        medal = medals[i] if i < 3 else f"{i+1}."
        text += f"\n{medal} <b>{data.get('name', 'User')[:20]}</b>"
        text += f"\n   âœ… {data.get('correct', 0)} to'g'ri | âŒ {data.get('wrong', 0)} noto'g'ri"
        text += "\n"
    
    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # G'olibga XP
    if sorted_participants:
        winner_id, winner_data = sorted_participants[0]
        xp_reward = 30 + (winner_data.get("correct", 0) * 5)
        
        try:
            async with db.connect() as conn:
                await conn.execute('UPDATE users SET xp = xp + ? WHERE user_id = ?', (xp_reward, winner_id))
                await conn.commit()
        except:
            pass
        
        text += f"\n\nðŸŽ‰ <b>G'OLIB:</b> {winner_data.get('name', 'User')}"
        text += f"\nðŸŽ <b>Mukofot:</b> +{xp_reward} XP"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ”„ Yana test", callback_data="wg_start_test")
    builder.button(text="âš”ï¸ Battle", callback_data="wg_start_battle")
    builder.adjust(2)
    
    await bot.send_message(chat_id, text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)
    
    del active_battles[chat_id]

@router.callback_query(F.data == "wg_start_test")
async def handle_wg_start_test(callback: CallbackQuery):
    """Wayground test boshlash tugmasi"""
    if callback.message.chat.type not in ['group', 'supergroup']:
        await callback.answer("Faqat guruhlarda ishlaydi!", show_alert=True)
        return
    
    text = """
ðŸ“ <b>GURUH TEST</b>

Test mavzusini tanlang:
    """
    chat_id = callback.message.chat.id
    
    builder = InlineKeyboardBuilder()
    builder.button(text="ðŸ§  Umumiy (5)", callback_data=f"wg_quiz_general_5_{chat_id}")
    builder.button(text="ðŸ§  Umumiy (10)", callback_data=f"wg_quiz_general_10_{chat_id}")
    builder.button(text="ðŸ“š Fan (5)", callback_data=f"wg_quiz_science_5_{chat_id}")
    builder.button(text="ðŸ’» IT (5)", callback_data=f"wg_quiz_it_5_{chat_id}")
    builder.adjust(2)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "wg_start_battle")
async def handle_wg_start_battle(callback: CallbackQuery):
    """Wayground mini battle"""
    if callback.message.chat.type not in ['group', 'supergroup']:
        await callback.answer("Faqat guruhlarda ishlaydi!", show_alert=True)
        return
    
    chat_id = callback.message.chat.id
    
    # Use existing battle system
    await start_group_battle(chat_id, callback.from_user)

@router.callback_query(F.data == "wg_group_stats")
async def handle_wg_group_stats(callback: CallbackQuery):
    """Guruh statistikasi"""
    chat_id = callback.message.chat.id
    
    text = f"""
ðŸ“Š <b>GURUH STATISTIKASI</b>

ðŸ†” Guruh ID: <code>{chat_id}</code>
ðŸ“… Bugun: {datetime.now().strftime('%Y-%m-%d')}

<i>Batafsil statistika tez orada...</i>
    """
    
    await callback.message.edit_text(text, parse_mode=ParseMode.HTML)

@router.callback_query(F.data == "wg_leaderboard")
async def handle_wg_leaderboard(callback: CallbackQuery):
    """Guruh reytingi"""
    await callback.answer("ðŸ† Reyting tez orada!", show_alert=True)

@router.callback_query(F.data == "wg_cancel")
async def handle_wg_cancel(callback: CallbackQuery):
    """Bekor qilish"""
    await callback.message.delete()

# =============================================================================
#                           FASTAPI WEB SERVER
# =============================================================================

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn

app = FastAPI(title="Nexus Bot API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request models
class QuizRequest(BaseModel):
    topic: str = "general"
    difficulty: str = "medium"
    count: int = 5
    user_id: Optional[int] = None

@app.post("/generateQuiz")
async def generate_quiz_api(request: QuizRequest):
    """Web app uchun quiz yaratish API"""
    try:
        user_id = request.user_id
        count = request.count
        
        # 1. User va Subscription aniqlash
        user = None
        subscription_type = 0
        if user_id:
            user = await db.get_user(user_id)
            if user:
                subscription_type = user.get('subscription_type', 0)
                await db.update_user_activity(user_id)
        
        # 2. Limitlarni tekshirish
        
        # Savollar soni limiti
        max_questions = Config.MAX_QUESTIONS_PER_QUIZ.get(subscription_type, 30)
        if count > max_questions:
            # Agar limitdan oshsa, limitgacha qisqartiramiz (yoki xato qaytarish mumkin)
            count = max_questions
        
        # Kunlik limit tekshirish (agar user bo'lsa)
        if user_id:
            daily_limit = Config.DAILY_QUIZ_LIMITS.get(subscription_type, 2)
            
            # Bugungi yaratgan quizlari sonini olish
            # Bu yerda oddiy counter ishlatamiz (databasega yangi jadval yoki ustun kerak bo'lishi mumkin)
            # Hozircha ai_limit dan foydalanamiz yoki alohida hisoblaymiz
            # Oddiylik uchun: ai_conversations jadvalidan bugungi quizlarni sanash
            async with db.connect() as conn:
                today = datetime.now().date().isoformat()
                cursor = await conn.execute('''
                    SELECT COUNT(*) FROM ai_conversations 
                    WHERE user_id = ? AND message LIKE 'QUIZ_GENERATION%' 
                    AND date(timestamp) = ?
                ''', (user_id, today))
                today_count = (await cursor.fetchone())[0]
            
            if today_count >= daily_limit:
                 return {
                    "success": False,
                    "error": f"Kunlik limit tugadi! Siz kuniga {daily_limit} ta test yarata olasiz. Cheksiz test uchun Premium oling.",
                    "questions": [],
                    "limit_reached": True
                }

        # 3. Quiz yaratish
        questions = await generate_quiz_with_ai(request.topic, request.difficulty, count)
        
        # 4. Usage ni saqlash (limit uchun)
        if user_id and questions:
            # AI conversation ga yozib qo'yamiz (count uchun)
            await db.save_ai_conversation(
                user_id, 
                f"QUIZ_GENERATION: {request.topic} ({count})", 
                "Quiz generated", 
                len(questions)
            )
        
        return {
            "success": True,
            "questions": questions,
            "count": len(questions)
        }
    except Exception as e:
        logger.error(f"Generate quiz API error: {e}")
        return {
            "success": False,
            "error": str(e),
            "questions": []
        }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

@app.get("/stats")
async def get_stats():
    """Public stats"""
    try:
        stats = await db.get_system_stats()
        return {
            "users": stats.get('total_users', 0),
            "books": stats.get('total_books', 0),
            "movies": stats.get('total_movies', 0),
            "courses": stats.get('total_courses', 0)
        }
    except:
        return {"users": 0, "books": 0, "movies": 0, "courses": 0}

# =============================================================================
#                           MAIN FUNCTION
# =============================================================================

async def main():
    """Asosiy funksiya - Bot va FastAPI serverni ishga tushirish"""
    global bot, dp, db, nexus_agent
    
    # Initialize bot and dispatcher
    bot = Bot(token=Config.BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    dp = Dispatcher()
    dp.include_router(router)
    
    # Initialize Nexus Agent
    nexus_agent = NexusAgent(
        openai_api_key=Config.OPENAI_API_KEY,
        bing_api_key=Config.BING_SEARCH_API_KEY,
        model=Config.OPENAI_MODEL
    )
    
    # Initialize database
    Config.setup_dirs()
    db_path = os.path.join(Config.DATA_DIR, "nexus.db")
    db = DatabaseManager(db_path)
    await db.init_db()
    
    # Start background workers
    asyncio.create_task(trial_expiry_checker_worker(bot, db))
    asyncio.create_task(mining_farm_auto_collect_worker(bot, db))
    asyncio.create_task(leaderboard_reset_worker(bot, db))
    asyncio.create_task(supabase_payment_sync_worker(bot, db))
    
    print("âœ… Bot muvaffaqiyatli ishga tushirildi!")
    
    # Start FastAPI server in a separate thread
    import threading
    
    def run_api():
        uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
    
    api_thread = threading.Thread(target=run_api, daemon=True)
    api_thread.start()
    print("âœ… FastAPI server ishga tushirildi (http://localhost:8000)")
    
    # Start bot polling
    await dp.start_polling(bot)

# =============================================================================

if __name__ == "__main__":
    print("=" * 50)
    print("ðŸ¤– NEXUS MEDIA BOT")
    print("=" * 50)
    print("Bot ishga tushmoqda...")
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nðŸ›‘ Bot to'xtatildi!")
    except Exception as e:
        logger.error(f"Bot ishga tushishda xatolik: {e}", exc_info=True)



